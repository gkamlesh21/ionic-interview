[
    {
        "folder": "JavaScript",
        "title": "JavaScript",
        "url": "/folder/JavaScript",
        "icon": "logo-javascript",
        "question": [
            {
                "name": "What are the data types supported by JavaScript?",
                "description": "<ul><li><span>Number</span></li><li><span>String</span></li><li><span>Boolean</span></li><li><span>Array</span></li><li><span>Object</span></li><li><span>Undefined</span></li><li><span>Null</span></li></ul>"
            },
            {
                "name": "What is the object and array type?",
                "description": "<p>The object type refers to a compound value where you can set properties (named locations) that each hold their own values of any type.</p><p><img src='./assets/js/object.png'></p><p>An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions:</p><p><img src='./assets/js/array.png'></p>"
            },
            {
                "name": "Is JavaScript an interpreted language or compiled language?",
                "description": "<p><strong>JavaScript&nbsp;</strong>is a special case where you directly execute your source code. A webpage will directly execute your JavaScript. So, for that reason many people think JavaScript as a interpreted language. <strong>However there is a compilation step just before the interpretation step in JavaScript. So, JS is both compiled and interpreted language.</strong></p><p><strong>var a = 10; <br>   var b = 20; <br>  console.log(a+b)</strong></p><p>Compilation Step – During this step the compiler mainly registers the variable declarations.</p><p>When the compiler goes to line 1, it encounters <code>var a</code> and registers it in the global scope and then goes to line 3 and registers the <code>var b</code>.</p><p>Interpretation Step – During this the actual execution takes place. </p><p>the interpreter starts at line 1 and see a variable a and ask the compiler, if it have a variable “a” in Global scope and the compiler have it. So, it assigns the value 10 to it. Next the same step is repeated for line 3 and interpreter assigns 20 to variable “b”. Now once the interpreter goes to line 5, it finds console. It first looks for console at global scope from the compiler but don’t find it. So, it checks in the JavaScript global and finds it. Inside the console there are variable a and b, which it finds at global scope. It then adds them using addition operator and display the result.</p>"
            },
            {
                "name": "Difference between variables created using let var or const?",
                "description": "<p>Variables declared using the <code>var</code> keyword are scoped to the function in which they are created, or if created outside of any function, to the global object.<br><code>let</code> and <code>const</code> are block scoped, meaning they are only accessible within the nearest set of curly braces (function, if-else block, or for-loop).</p><p><img src='./assets/js/let-var-const.png'></p><p><code>var</code> allows variables to be hoisted, meaning they can be referenced in code before they are declared. <code>let</code> and <code>const</code> will not allow this, instead throwing an error.</p><p><img src='./assets/js/let-var-const1.png'></p><p>Redeclaring a variable with <code>var</code> will not throw an error, but <code>let</code> and <code>const</code> will.</p><p><img src='./assets/js/let-var-const2.png'></p><p><code>let</code> and <code>const</code> differ in that <code>let</code> allows reassigning the variable's value while <code>const</code> does not.</p><p><img src='./assets/js/let-var-const3.png'></p>"
            },
            {
                "name": "What is TypeScript and why would I use it in place of JavaScript?",
                "description": "<p>TypeScript is a superset of JavaScript which primarily provides optional static typing, classes and interfaces. One of the big benefits is to enable IDEs to provide a richer environment for spotting common errors as you type the code. For a large JavaScript project, adopting TypeScript might result in more robust software, while still being deployable where a regular JavaScript application would run.</p>"
            },
            {
                "name": "Difference between (equality operator) == and === ?",
                "description": "<p> JavaScript has both strict and type-converting equality comparison. For strict comparison we use === and for type-converting comparison we use == .</p><p><strong>Strict Comparison(===)</strong><br>For strict comparison the items been compared must be the same type.</p><ul> <li>Two strings are strictly equal when they have the same sequence of characters, same length, and same characters in corresponding positions.<p><img src='./assets/js/equaltwostring.png'></p></li><li>Two numbers are strictly equal when they are numerically equal (have the same number value). NaN is not equal to anything, including NaN. Positive and negative zeros are equal to one another.<p><img src='./assets/js/equaltwonum.png'></p></li><li>Two Boolean operands are strictly equal if both are true or both are false.<p><img src='./assets/js/equaltwobool.png'></p></li><li>Two objects are strictly equal if they refer to the same Object.<p><img src='./assets/js/equaltwoobj.png'></p></li><li>Null and Undefined types are not equal<p><img src='./assets/js/nullundefined.png'></p></li></ul><p><strong>Type-converting comparison</strong><br>The==does a type conversion before comparing, if both items are of different types.</p><p><img src='./assets/js/equality1.png'></p>"
            },
            {
                "name": "Difference between null and undefined?",
                "description": "<p>Both&nbsp;<em>null&nbsp;</em>and&nbsp;<em>undefined&nbsp;</em> represents empty values.</p><p>In JavaScript, <code>undefined</code> means a variable has been declared but has not yet been assigned a value, </p><p><code>null</code> is an assignment value. It can be assigned to a variable as a representation of no value:</p><p><code>undefined</code> is of the type undefined, where as <code>null</code> is an object</p><p><code>null !== undefined</code> but <code>null == undefined</code></p>"
            },
            {
                "name": "Difference between 'undefined' and 'not defined' in JavaScript",
                "description": "<p>In JavaScript if you try to use a variable that doesn't exist and has not been declared, then JavaScript will throw an error <code>var_name is not defined</code> and the script will stop execute thereafter.<br>But If you use <code>typeof undeclared_variable</code> then it will return <code>undefined</code></p><p>Example of undefined:<br><code>var x; // declaring x<br>console.log(x); //output: undefined</code></p><p>Example of not defined:<br><code>console.log(y); // Output: ReferenceError: y is not defined</code></p>"
            },
            {
                "name": "Difference between function declaration and function expression?",
                "description": "<p>Function declaration is like most other traditional languages, but in JavaScript we use the keyword “function”.<br>In function expression we assign an anonymous function to an variable. They are very useful when we pass function as arguments to other function or return an function.</p><p><img src='./assets/js/function.png'></p><p>One of the key difference is that, we can call a function declaration even before defining it but same is not true for function expression and it will give reference error.</p>"
            },
            {
                "name": "What is Coercion in JavaScript?",
                "description": "<p>In JavaScript conversion between different two build-in types called coercion. Coercion comes in two forms in JavaScript: explicit and implicit.<p>Explicit coercion:<br><img src='./assets/js/explicit.png'></p><p>Implicit coercion:<br><img src='./assets/js/implicit.png'></p></p>"
            },
            {
                "name": "What is Scope in JavaScript?",
                "description": "<p>Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime. In other words, scope determines the visibility of variables and other resources in areas of your code.</p>"
            },
            {
                "name": "What is a closure and how do we use it?",
                "description": "<p>Closures are one of the most complex topic in JavaScript, but they are everywhere in JavaScript.<br><br>Closures are basically, the inner function having access to the variables in the outer function scope, even after the outer function has returned. To use a closure, simply define a function inside another function and expose it. To expose a function, return it.</p><p>Consider the below code. The variable <strong>b</strong> have an scope in outer function i.e. from line 4 to line 10. So, at line 13 when we call the outer function, it can access the value of b.</p><p>So, how does the innerFn() access the value of <strong>b</strong>. This is where the JS feature of Closures comes into play.<br><br><em>When the “var inner” is created at line 6, the JS engine not only stores the function object information but also its scope information.&nbsp;</em>So, it stores a scope of variable <strong>b</strong> inside the inner function object.<br><br>Now it doesn’t matter where you call inner, whether in this file or some third party file. It will always remember the value of <strong>a</strong> and <strong>b</strong>, as if a snapshot is been taken.</p><p><img src='./assets/js/closure.png'></p>"
            },
            {
                "name": "Explain the concept of hoisting in JavaScript?",
                "description": "<p>Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope before code execution. Remember that JavaScript only hoists declarations, not initialisation. Variables declared or initialized with the var keyword will have their declaration 'moved' up to the top of their module/function-level scope, which we call as hoisting. However, only the declaration is hoisted, the assignment (if there is one), will stay where it is.<br><img src='./assets/js/hoisting.png'></p>"
            },
            {
                "name": "Name the different loops in JavaScript?",
                "description": "<p><code>for</code> - loops through a block of code a number of times<br><code>for/in</code> - loops through the properties of an object<br><code>for/of</code> - loops through the values of an iterable object<br><code>while</code> - loops through a block of code while a specified condition is true<br><code>do/while</code> - also loops through a block of code while a specified condition is true</p>"
            },
            {
                "name": "Explain ”new” in JavaScript?",
                "description": "<p><strong>New keyword</strong> in JavaScript is used to create an instance of an object that has a constructor function. On calling the constructor function with ‘new’ operator, the following actions are taken:</p><ul><li>A new empty object is created.</li><li>The new object's internal ‘Prototype’ property (__proto__) is set the same as the prototype of the constructing function.</li><li>The ‘this’ variable is made to point to the newly created object. It binds the property which is declared with ‘this’ keyword to the new object.</li><li>A newly created object is returned when the constructor function returns a non-primitive value (custom JavaScript object). If the constructor function returns a primitive value, it will be ignored. At the end of the function, ‘this’ is returned if there is no return statement in the function body.</li></ul>"
            },
            {
                "name": "List all DOM events ",
                "description": "<ul><li><strong>onblur</strong> - The onblur event occurs when an HTML element loses focus. event is often used on input fields. event is often used with form validation (when the user leaves a form field).</li><li><strong>onchange</strong> - The onchange event occurs when the value of an HTML element is changed.  This event is similar to the oninput event. The difference is that the oninput event occurs immediately after the value of an element has changed, while onchange occurs when the element loses focus, after the content has been changed. The other difference is that the onchange event also works on &lt;select&gt; elements.</li><li><strong>onclick</strong> - The onclick event occurs when the user clicks on an HTML element.</li><li><strong>oncontextmenu</strong> - The oncontextmenu event occurs when the user right-clicks an HTML element to open the context menu.</li><li><strong>onfocus, onfocusin</strong> - The onfocus event occurs when an element gets focus. This event is often used on input fields.</li><li><strong>onfocusout</strong> - The onfocusout event occurs when an element looses focus. This event is often used on input fields. This event is often used with form validation (when the user leaves a form field).</li><li><strong>oninput</strong> - The oninput event occurs when an element gets user input. This event occurs when the value of an &lt;input&gt; or &lt;textarea&gt; element is changed. This event is similar to the onchange event. The difference is that the oninput event occurs immediately after the value of an element has changed, while onchange occurs when the element loses focus, after the content has been changed. The other difference is that the onchange event also works on &lt;select&gt; elements.</li><li><strong>onkeydown</strong> - The onkeydown event occurs when the user presses a key on the keyboard.</li><li><strong>onkeyup</strong> - The onkeyup event occurs when the user releases a key on the keyboard.</li><li><strong>onload</strong> - The onload event occurs when an object has been loaded. onload is most often used within the <body> element to execute a script once a web page has completely loaded all content (including images, script files, CSS files, etc.). The onload event can be used to check the visitor's browser type and browser version, and load the proper version of the web page based on the information.</li><li><strong>onscroll</strong> - The onscroll event occurs when an element's scrollbar is being scrolled. use the CSS overflow style property to create a scrollbar for an element.</li><li><strong>onselect</strong> - The onselect event occurs after some text has been selected in an element. The onselect event is mostly used on &lt;input type=\"text\"&gt; or &lt;textarea&gt; elements.</li></ul>"
            },
            {
                "name": "“this” Keyword",
                "description": "<p><strong><code>this</code></strong> keyword is one of the most used keywords in JavaScript. But when it comes to regular functions and arrow functions, it behaves in entirely different ways.</p><br><p>In regular function, <strong><code>this</code></strong> changes according to the way that function is invoked.</p><ul><li><strong>Simple Invocation: <code>this</code></strong> equals the global object or maybe undefined if you are using strict mode.<br><img src='./assets/js/simplethis.png'></li><li><strong>Method Invocation: <code>this</code></strong> equals the object that owns the method.<br><img src='./assets/js/methodthis.png'></li><li><strong>Indirect Invocation: <code>this</code></strong> equals the first argument.<br><img src='./assets/js/indirectthis.png'></li><li><strong>Constructor Invocation: <code>this</code></strong> equals the newly created instance.<br><img src='./assets/js/constructorthis.png'></li></ul><br><br><p>But, in the arrow functions, the behavior of <strong><code>this</code></strong> changes completely.</p><p>Arrow functions don't have their own “this”, and they don’t redefine the value of “<code>this</code>” within the function. </p><p>Regardless of how you execute arrow functions, <code>this</code> inside an arrow function always refers to <code>this</code> from the outer context. This means that <code>this</code> keyword is <strong>lexically </strong>bound in arrow functions. <br>For Example: <br><img src='./assets/js/this.png'></p><p>This behavior of arrow functions makes them really useful when using callbacks inside methods.</p><p>You don't need to use workarounds like <code>const self = this</code> or <code>callback.bind(this)</code> with arrow functions, and it prevents any mistakes that can be caused by the use of <code>this</code> within callbacks.</p>"
            },
            {
                "name": "How does the \"this\" keyword work? Provide some code examples",
                "description": "<p>In JavaScript <em>this</em> always refers to the “owner” of the function we're executing, or rather, to the object that a function is a method of.<br><img src='./assets/jsCode/foo.png'></p>"
            },
            {
                "name": "What is event bubbling and capturing in JavaScript?",
                "description": "<p>When an event happens on an element, it first runs on which it was clicked, then on its parent, then all the way up on other ancestors. It is the default behaviour of the browser.</p><p><strong>Event capturing</strong> is the opposite of bubbling and it means when you click on parent element, it goes till the child.</p><p>We will first see <strong>Event Bubbling</strong>. The HTML contains an parent element containing a child element called <em>Child1</em>. When we click on the “Child1” button, first the console log of child is displayed and then the parent is displayed.</p><p><img src='./assets/js/eventbubble.jpg'></p><p>We will now see <strong>Event Capturing</strong>. The HTML contains an parent element containing a child element called <em>Child1</em>. When we click on the button, first the console log of parent is displayed and then the child is displayed. Notice that in addEventListener we have to pass a value of <strong>true</strong>.</p><p><img src='./assets/js/eventcapture.jpg'></p>"
            },
            {
                "name": "IIFE - Immediate Invoke Function Expression",
                "description": "<p>An IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined.</p><P>It is a design pattern which is also known as a Self-Executing Anonymous Function and contains two major parts:</P><ol> <li>The first is the anonymous function with lexical scope enclosed within the <code>Grouping Operator</code> <code>()</code>. This prevents accessing variables within the IIFE idiom as well as polluting the global scope.</li><li>The second part creates the immediately invoked function expression <code>()</code> through which the JavaScript engine will directly interpret the function.</li></ol>"
            },
            {
                "name": "What are promises JavaScript?",
                "description": "<p>Promises in JavaScript are like promises in real life. You promise to do something, and then it is done or not done. A promise may be in one of 3 possible states: resolve, rejected, or pending.<br><br>They are mainly used to do asynchronous task like calling a REST api and getting the result back. So, these network calls takes time. When the network call is been made, the promise is in Pending state. Once the network call is successful the promise returns a resolve and if it fails it returns resolve.The resolve is captured by the then() callback function and reject captured by catch() callback function.</p><p>Consider the below example. Here inside <em>promiseCleanRoom</em> we generate a random number between 0 and 1. If the number is greater the 0.5, we send a resolve or else we send a reject.<br>Depending on the case either .then is executed or .catch is executed.<br><strong>Resolve Case</strong><img src='./assets/js/promise.png'><br><strong>Reject Case</strong><img src='./assets/js/promise_reject.png'></p>"
            },
            {
                "name": "Explain callback functions / Higher Order functions in JavaScript?",
                "description": "<p>A callback function, also known as a higher-order function, is a function that is passed to another function as a parameter, and the callback function is executed inside the that Function.</p><p>Callback function are used everywhere in JavaScript. In JavaScript, functions are first-class citizens. They can be “stored in variables, passed as arguments to functions, created within functions, and returned from functions”.</p><p>Let's look at the example below. Here we call function <em>mainFunc</em> with function “x” as argument and then from inside <em>mainFunc</em>, calling it after some console log.</p><p><img src='./assets/js/anonomous.jpg'></p><p>When we use anonymous function inside our function call for callback like in the below code.</p><p><img src='./assets/js/mainfunc.png'></p><p>The in-built for Each, map, reduce, filter uses callback functions internally. Check the below example and here we are passing a function, just like above <em>calc</em> code.</p><p><img src='./assets/js/otherexample.jpg'></p>"
            },
            {
                "name": "Explain recursion in JavaScript?",
                "description": "<p>Recursion is a technique for iterating over an operation by having a function call itself repeatedly until it arrives at a result.<br>Now, in recursive function there are two parts. One is <strong>termination condition</strong> and other is the <strong>recursion</strong> itself. &nbsp;The termination condition is very important or else the recursion never stops and goes into infinite loop.</p><p>Let consider the below simple example to add numbers from the current passed number backwards till 1. Say we pass 3, then 3+2+1 = 6. In the below example <em>If(n≤0)</em> is the termination condition and <em>return n + add(n-1);</em> is the recursion.</p><p><img src='./assets/js/recursive.jpg'></p><p>The recursion works as shown in the diagram below.<br>It works like loop, so the first call will go to recursion part and give “3 + add(2)”.</p><p>Now the add(2) will be called and will be expended into “2 + add(1)”.<br>After that add(1) will be called and expanded into “1 + add(0)”.</p><p>Finally the add(0) will trigger the termination condition <em>If(n≤0)&nbsp;</em>and produce 0.<br>After this everything will be added 3 + 2 + 1 + 0 to give 6.</p><p><img src='./assets/js/recursiveoutput.jpg'></p>"
            },
            {
                "name": "What are spread operators and rest parameters?",
                "description": "<p><em>Spread operators(…)&nbsp;</em>were introduced in JavaScript in ES6 version. Just like plus(+) and minus(-) are operators, spread(…) is also an operator in JavaScript. Basically Spread operator spreads on demand.</p><p>When you pass arguments to a function using Spread operators they are called <em>Rest parameters</em>.</p><p><strong>#Replace Apply when calling functions: </strong>when you want to pass the elements of an array as arguments to a function. You can simplify the code above and avoid using null<br><img src='./assets/js/replace-apply.png'><br><strong>#Easy array manipulation:</strong> use it when you want to expand an array with another one without using a combination of push, splice, concat, etc.<br><img src='./assets/js/easy-replace.png'><br><strong>#Copy an array:</strong> spread syntax makes a copy by value, so that future manipulations will not affect the original array:<br><img src='./assets/js/copy-array.png'><br><strong>#Concatenate arrays:</strong> it is an easier way to insert an array of values at the start of an existing array without using unshift and apply:<br><img src='./assets/js/concat-array.png'><br><strong>#Converting string to array:</strong> this feature allows you can convert a string to an array of characters:<br><img src='./assets/js/covert-string.png'></p>"
            },
            {
                "name": "Differences between rest parameter and spread operator?",
                "description": "<p>Rest parameter is used to take a variable number of arguments and turns into an array while the spread operator takes an array or an object and spreads it</p><p>Rest parameter is used in function declaration whereas the spread operator is used in function calls.</p>"
            },
            {
                "name": "Explain Destructuring in ES6?",
                "description": "<p>Destructuring is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. You can also handle nested structure by using nested destructuring syntax.</p><p><strong>Object Destructuring - You use an object literal on the left-hand-side of an assignment expression</strong> for object destructuring.</p><p><img src='./assets/js/objdestructure2.jpg'></p><p><strong>Nested Object Destructuring</strong><br>If there is nested object as in below case, we can destructure it by adding it's value to another object syntax</p><p><img src='./assets/js/objdestructure3.jpg'></p><p><strong>Array Destructuring</strong><br>Array destructuring is similar to object destructuring, but here instead of keys you assign any variable.</p><p><img src='./assets/js/objdestructure4.jpg'></p><p><strong>Skipping Items</strong><br>It is possible to skip items in array destructuring by omitting items with comma(,).</p><p><img src='./assets/js/objdestructure5.jpg'></p></div>"
            },
            {
                "name": "Explain async await in JavaScript?",
                "description": "<p>Async await help in allowing us to write completely synchronous-looking code while performing asynchronous tasks behind the scenes.</p><p>Async await are basically promises under the hood. But they have made the code for promises very easier to implement. If promises had simplified the code for callbacks, then async await have simplified the code for promises.<br><br>Let's first check a nested promise example. Here we have three functions which return promises- <em>cleanRoom, removeGarbage and winPizza</em>. Now, when the <em>cleanRoom</em> function is run and resolve is returned from the promise, then the immediate .then block will be run . In the .then we are returning the next <em>removeGarbage</em> and in its .then we are returning the <em>winPizza</em>. We are passing the message from one function to other, so it will be appended.</p><p>Here, instead of three functions we have one function cleaningTheRoom, which have a keyword “async” infront of it. It means that the function will have await statement(s). In the “await” we can have the value returned by a Promise stored in a variable. This type of code is much more cleaner then promise.</p>"
            },
            {
                "name": "Explain Promise.all with async-await?",
                "description": "<p>The <em>Promise.all &nbsp;</em>method returns a single Promise that resolves when all of the promises in the <em>iterable</em> argument have resolved or when the <em>iterable</em> argument contains no promises. It rejects with the reason of the first promise that rejects.</p><p><img src='./assets/js/promiseall.jpg'></p><p>We should use <em>Promise.all</em> in only cases like above, where the result of one Promise is not dependent on other promise.</p>"
            },
            {
                "name": "How do we handle errors in async-await function?",
                "description": "<p>In Promises we handle any error or reject in the .catch block. Let's look at the below example, where we are sending reject() from Promise inside a function expression. So, now the error will be caught by the .catch block and then we are displaying the same in console log.</p><p><strong>try…catch block available in JavaScript</strong></p><p><img src='./assets/js/tryCatch.png'></p>"
            },
            {
                "name": "What are constructor functions in JavaScript?",
                "description": "<p>A constructor is a function that creates an instance of a class which is typically called an “object”. In JavaScript, a constructor gets called when you declare an object using the new keyword. The purpose of a constructor is <b>to create an object and set values if there are any object properties present</b>.</p><p><img src='./assets/js/constructorfunction.png'></p>"
            },
            {
                "name": "How to make variables private in Constructor functions?",
                "description": "<p>Now, we implement the same in JavaScript using Closures. We have two closure functions <strong>setName</strong> and <strong>getName</strong> which are basically “setters” and “getters”. Now, the variable <strong>_name</strong> is private and cannot be accessed outside the function by <em>person._name</em> and we can access it only by <em>person.getName()</em></p><p><img src='./assets/js/privatevarconstructor.jpg'></p>"
            },
            {
                "name": "What are Prototypes and how do we use them in JavaScript?",
                "description": "<p>In JavaScript everything is an Object. So whenever we create an function, there is a one object which is created for that function. But actually there is another object which is created which is known as the <em>Prototype</em> object.</p><p>Now, let's look how to create an function using prototype and the benefit of it. The below code have two function <em>haveFun</em> and <em>drinkBreak</em>. The function <em>haveFun</em> is an normal function inside the Constructor function. The function <em>drinkBreak</em> is created outside and added to the Prototype Object using it's reference prototype.</p><p><img src='./assets/js/functionprototype.jpg'></p><p>Both the function seems to be doing the same thing, then what's the benefit.<br>The benefit of declaring function using prototype is that it's created once in the Prototype object. So, now whenever we create a new instance of the Constructor function the function is not created again. As in the below screenshot, you can see that <strong>emp1</strong> and <strong>emp2</strong> both have <strong>name</strong> and <strong>haveFun</strong>. But the <strong>drinkBreak</strong> is inside the <strong>__proto__</strong>, which is a reference to Prototype object.</p><p><img src='./assets/js/functionprototype1.jpg'></p>"
            },
            {
                "name": "What are the limitations of JavaScript?",
                "description": "<ol> <li><strong>Writing files on server</strong> - JavaScript cannot directly write files on server. However, they can do this using server-side script</li><li><strong>Disable JavaScript</strong> - Due to security reasons, every web browser provides an option to disable JavaScript.</li><li><strong>Networking</strong> - It cannot be used for Networking applications.</li><li><strong>Browser Compatibility</strong> - Applications may behave differently in different web browsers. To support all modern browsers, you need to write cross browser codes.</li><li><strong>Security</strong> - Since the code executes on client's computer, the chances are high for vulnerability and can be exploited for malicious purposes</li><li><strong>Databases</strong> - JavaScript cannot access databases. You need AJAX and a server-side script for this.</li></ol>"
            },
            {
                "name": "Javascript Objects",
                "description": "<ul><li><strong>Defenition</strong> - An Object is a Javascript data type which can represent an entity containing certain properties or behaviors/methods. These properties can be <em>changed</em> or <em>deleted</em> or <em>new properties</em> can be <em>added</em> to the object.</li><li><strong>Object Properties</strong> - A property(data property) has a <em>name</em> and a <strong><em>value</em></strong> assigned to it as a key-value pair. In addition, each property has some meta data which can control its state/value. Object properties can be any of the three primitive data types, or any of the abstract data types, such as another object. Object properties are usually variables that are used internally in the object's methods, but can also be globally visible variables that are used. Syntax:<br><strong><code>objectName.objectPropertyName = propertyValue;</code></strong></li><li><strong>Object Methods</strong> - Methods are the functions that let the object do something or let something be done to it. There is a small difference between a function and a method – at a function is a standalone unit of statements and a method is attached to an object and can be referenced by the this keyword.</li></ul>"
            },
            {
                "name": "What are the ways of creating objects in JavaScript?",
                "description": "<ul><li>Object creation with Object Literal<br><img src='./assets/js/object2.png'></li><li>Object creation with function / constructor method<br><img src='./assets/js/object1.png'></li><li>Object Creation using Object.create() method<br><img src='./assets/js/objectcreate.png'></li><li>Object Creation with Function based<br><img src='./assets/js/objectfunction.png'></li></ul>"
            },
            {
                "name": "Explain Object.create() in JavaScript?",
                "description": "<p>In JavaScript every object is created from a global “Object”(Notice the capital ‘O’). If we look at it in console, it have many properties and create been one of it.</p><p><img src='./assets/js/objectprototype.png'></p><p>The <em>Object.create()</em> method creates a new object, using an existing object as the prototype of the newly created object.</p>"
            },
            {
                "name": "Different ways to make an object non-extensible?",
                "description": "<p>You can mark an object non-extensible in 3 ways,</p><ol> <li><strong>Object.freeze()</strong> - simply converts an object passed as the argument into a frozen state. An object called by this method can not have any further changes on it. <ul> <li>Cannot add new properties.</li><li> Cannot remove existing properties.</li><li> Cannot change existing property values.</li><li> Cannot reconfigure any existing property. writable and configurable are set to false.</li><li> Cannot change its prototype.</li></ul> <p> Trying to make any changes mentioned above after an object being frozen will fail and will throw errors in strict mode.</p><p><strong><em>Object.isFrozen()</em></strong> is an Object method to check if an object is frozen by passing the object as the argument, where the return type is a boolean</p></li><br><li> <strong>Object.seal() </strong>simply converts an object passed as the argument into a sealed state. An object called by this method can not have any new properties being added. But it <strong>can change</strong> existing property values as long as <em>writable</em> metadata is true. <ul> <li>Cannot add new properties.</li><li> Cannot remove existing properties.</li><li> Cannot reconfigure any existing property.</li><li> Cannot convert a data property to accessor property or vice versa.</li></ul> <p><strong><em>Object.isSealed()</em></strong> is an Object method to check if an object is sealed by passing the object as the argument, where the return type is a boolean</p></li><br><li> <strong>Object.preventExtensions() </strong>simply converts an object passed as the argument into a non-extensible state. An object called by this method can not have any new properties being added. This method inherits functionality from its superset object.seal. Hence, it <strong>can change</strong> existing property values as long as <em>writable</em> metadata is true. In contrast to sealed objects, non-extensible objects can be deleted or reconfigured. <p><strong><em>Object.isExtensible()</em></strong> is an Object method to check if an object is extensible by passing the object as the argument.</p></li></ol>"
            },
            {
                "name": "Difference between const vs Object.freeze()",
                "description": "<p>In <strong>const</strong> reassignment of the variable is not allowed but the value referenced by the const variable can still be changed. <br><br>#Ex. Value is Immutable<br> <img src='./assets/js/const-object.png'> <br><br>#Binding is Mutable<br> <img src='./assets/js/const-object1.png'><br><br>#Mutable binding with object<br> <img src='./assets/js/const-object2.png'></p><br><br><p><strong>Object.freeze()</strong> prevents modification or extension to the existing value of an object. <br><br>Ex. Ignoring the value modification to an object<br> <img src='./assets/js/const-object3.png'> <br><br>#But the same work on binding<br> <img src='./assets/js/const-object4.png'></p>"
            },
            {
                "name": "Difference between Object.values() vs Object.entries()",
                "description": "<p><code>Object.values()</code> takes an object and returns an array with the values, in the same order that a for…in loop function would give us. Object.values doesn’t follow the prototype chain and only iterates over the value that are directly on the provided object.<br><img src='./assets/js/object-value.png'></p><p><strong>Object.entries()</strong> returns an array with arrays of key-value pairs:<br><img src='./assets/js/object-entries.png'></p>"
            },
            {
                "name": "Difference between native, host and user objects?",
                "description": "<ul><li>Native objects are objects that are part of the JavaScript language defined by the ECMAScript specification, such as <code>String</code>, <code>Math</code>, <code>RegExp</code>, <code>Object</code>, <code>Function</code>, etc.</li><li>Host objects are provided by the runtime environment (browser or Node), such as <code>window</code>, <code>XMLHTTPRequest</code>,<code>DOM</code> nodes etc.</li><li><code>User objects</code> are objects defined in the javascript code. For example, User object created for profile information</li></ul>"
            },
            {
                "name": "'Deep-Freeze' object in JavaScript?",
                "description": "<p>To make an object immutable, we generally use utilize <code>Object.freeze()</code>, which prevents the addition of new properties and prevent deletion and changes to existing properties to some extent. However, while <code>Object.freeze()</code> provides somewhat kind of a solution, it only handles the problem to the next nesting level, as in reality it performs a shallow freeze during its process. This means that properties that are objects or arrays can still be mutated:</p><p><img src='./assets/js/freezeexample.png'></p><p>Here to solve the issue we can use recursion method, by checking if each property is itself an object using, <code>Object.isFrozen()</code> method which is returning <code >false</code>, then apply <code>Object.freeze()</code> to it:</p><p><img src='./assets/js/deepfreezeexample.png'></p>"
            },
            {
                "name": "How do you check if a key exists in an object?",
                "description": "<ul> <li>Traditional way <br><strong>var user = {name:'test'} <br>//Test condition <br>user.name === undefined //Output <br> true</strong> </li><li> The <strong><code>hasOwnProperty()</code></strong> method returns a boolean indicating whether the object has the specified property or not in it. <br><strong>object_name.hasOwnProperty('key_name')</strong> </li><li>Using <code>'in'</code> operator - <br><strong>!(keyName in objectName);</strong></li></ul>"
            },
            {
                "name": "How to create an array in JavaScript?",
                "description": "<ul><li>Using Array Literal<br><strong>var department = ['HR', 'Finance', 'Operations', 'Marketing'];</strong></li><li>Using keyword new<br><strong>var department = new Array('HR', 'Finance', 'Operations', 'Marketing');</strong></li></ul>"
            },
            {
                "name": "List different ways of empty array in Javascript?",
                "description": "<p>In Javascript,&nbsp;there are many ways to empty an array in Javascript, below we have listed 4 major</p><p><img src='./assets/js/emptyarray.png'></p>"
            },
            {
                "name": "JavaScript has dynamic types. How?",
                "description": "<p>In JavaScript, you can use the same variable to hold different data types. This is why it is called that JavaScript has dynamic types.</p><p><img src='./assets/js/variabletypes.png'></p>"
            },
            {
                "name": "instanceof / typeof operator in JavaScript",
                "description": "<p>If you want to check the type of an object at runtime, then use the instanceof operator where the result is a boolean.<br><br>where as typeof operator is used to find the data type of a JavaScript variable where the result is a string.</p>"
            },
            {
                "name": "Remove element from an array in JavaScript (splice)",
                "description": "<p>To remove a single element from an array in JavaScript, the splice() method is used. With that you can also replace, and/or add elements in an array.</p><p>We are using the splice() method to remove a single element by setting the location from where it start, and the number of elements to be removed. Here, we have set 1, therefore only a single element will get removed:</p><strong>myArr.splice(3, 1);</strong>"
            },
            {
                "name": "String Reference",
                "description": "<ul> <li><strong>charAt(x)</strong> - This function will return the character at the x position within the string.<br><img src='./assets/js/stringcharat.png'><br><br></li><li><strong>charCodeAt(x)</strong> - This function will return the unicode value of the character at position ‘x’ within the string.<br><img src='./assets/js/stringchartat.png'><br><br></li><li><strong>concat(v1,v2..)</strong> - This function combines one or more strings(argv1,v2 etc) into existing one.<br><img src='./assets/js/stringconcat.png'><br><br></li><li><strong>fromCharcode(c1,c2)</strong> - This function will return a string created by using specified sequence of unicode values(argc1,c2).<br><img src='./assets/js/stringfromcharcode.png'><br><br></li><li><strong>indexOf(substr, [start])</strong> - Searches and (if found) returns the index number of the searched character or substring within the string. If not found, -1 is returned. “Start” is an optional argument specifying the position within string to begin the search. Default is 0.<br><img src='./assets/js/stringindexof.png'><br><br></li><li><strong>lastIndexOf(substr, [start])</strong> - Searches and (if found) returns the index number of the searched character or substring within the string. Searches the string from end to the beginning. If not found, -1 is returned. “Start” is an optional argument specifying the position within string to begin the search. Default is string.length-1.<br><img src='./assets/js/stringlastindexof.png'><br><br></li><li><strong>match(regexp)</strong> - Executes a search for a match within a string based on a regular expression. It returns an array of information or null if no match is found.<br><img src='./assets/js/stringmatch.png'><br><br></li><li><strong>replace(regexp/substr, replacetext)</strong> - Searches and replaces the regular expression (or sub string) portion (match) with the replaced text instead.<br><img src='./assets/js/stringreplace.png'><br><br></li><li><strong>search(regexp)</strong> - Tests for a match in a string. It returns the index of the match, or -1 if not found.<br><img src='./assets/js/stringsearch.png'><br><br></li><li><strong>slice(start, [end])</strong> - This function returns a substring of the string based on the “start” and “end” index arguments, NOT including the “end” index itself. “End” is optional, and if none is specified, the slice includes all characters from “start” to end of the string.<br><img src='./assets/js/stringslice.png'><br><br></li><li><strong>split(delimiter, [limit])</strong> - This will split a string into many according to the specified delimiter, and returns an array containing each element. The optional “limit” is an integer that lets you specify the maximum number of elements to return.<br><img src='./assets/js/stringsplit.png'><br><br></li><li><strong>substr(start, [length])</strong> - This function returns the characters in a string beginning at “start” and through the specified number of characters, “length”. “Length” is optional, and if omitted, up to the end of the string is assumed.<br><img src='./assets/js/stringsubstr.png'><br><br></li><li><strong>substring(from, [to])</strong> - It returns the characters in a string between “from” and “to” indexes, NOT including “to” itself. “To” is optional, and if omitted, up to the end of the string is assumed.<br><img src='./assets/js/stringsubstring.png'><br><br></li><li><strong>toLowerCase()</strong> - This will return the string with all of its characters converted to lowercase.<br><img src='./assets/js/stringlowercase.png'><br><br></li><li><strong>toUpperCase()</strong> - This will return the string with all of its characters converted to uppercase.<br><img src='./assets/js/stringuppercase.png'><br><br></li><li><strong>includes()</strong> - It is used to check whether a string contains the specified string or characters.<br><img src='./assets/js/stringincludes.png'><br><br></li><li><strong>endsWith()</strong> - This function checks whether a string ends with specified string or characters.<br><img src='./assets/js/stringendwith.png'><br><br></li><li><strong>repeat()</strong> - This returns a new string with a specified number of copies of an existing string.<br><img src='./assets/js/stringrepeat.png'><br><br></li><li><strong>valueOf()</strong> - It is used to return the primitive value of a String object.<br><img src='./assets/js/stringvalueof.png'><br><br></li><li><strong>trim()</strong> - This function removes whitespace from both ends of a string.<br><img src='./assets/js/stringtrim.png'><br><br></li></ul>"
            },
            {
                "name": "toString() vs join()?",
                "description": "<p>array.toString() and array.join() does the same thing of converting an array into a string. Since toSting() does not accept any arguments its is less preferred while in join() one can pass arguments. Ex. [1,2,3].join(', ')</p>"
            },
            {
                "name": "How do you make first letter of the string in an uppercase?",
                "description": "<img src='./assets/js/first-letter-capital.png'>"
            },
            {
                "name": "How to convert string to title case with javascript?",
                "description": "<img src='./assets/js/first-letter-capital1.png'>"
            },
            {
                "name": "How do you check whether a string contains a substring?",
                "description": "<p>There are 3 possible ways to check whether a string contains a substring or not,</p><ul><li>Using includes(): String.includes() method to test a string contains a substring<br><img src='./assets/js/substring.png'></li><li>Using indexOf(): String.indexOf() which returns the index of a substring. If the index value is not equal to -1 then it means the substring exist in the main string.<br><img src='./assets/js/substring1.png'></li><li>Using RegEx: The advanced solution is using Regular expression's test method(RegExp.test), which allows for testing for against regular expressions<br><img src='./assets/js/substring2.png'></li></ul>"
            },
            {
                "name": "Search for a string in a string with JavaScript (search() / includes())",
                "description": "<p>To search for a string in a string, use the search() method. The method searches a string for a specified value. The returned value is the position of the match. However, -1 is returned if the match isn’t found.</p><p>Where as the <code>includes()</code> method returns true if a string contains a specified string, otherwise false</p>"
            },
            {
                "name": "How to create a Cookie with JavaScript?",
                "description": "<p>Cookies has a plain text record of fields: Expires, Domain, Path, Secure, etc. They are generally used to track preferences, commissions, etc. It stores information on your computer in the form of plain text. Cookies are saved in name-value pairs. It gets deleted when the web browser is closed.</p><p>The document.cookie property is used in JavaScript to create cookies. With the same property, you can also read and delete cookies.</p><p>Create a cookie:</p><strong>document.cookie = 'username=Knowledge Hut';</strong><p>Add an expiry date to the cookie created above:</p><strong>document.cookie = 'username= Knowledge Hut; expires=Thu, 12 Dec 2018 12:00:00 UTC';</strong><p>To read a cookie in JavaScript:</p><strong>var a = document.cookie;</strong><p>The above displays the cookies in name-value form i.e.:</p><strong>cookie1=value; cookie2=value;</strong><p>To delete a cookie, you need to just set the cookie to the past date (expire). The date is included using the expires parameter:</p><strong>document.cookie = 'username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';</strong>"
            },
            {
                "name": "What are the different types of pop-up boxes in JavaScript?",
                "description": "<p><strong>Alert Box</strong> - The alert box is for an alert or message to the user. User needs to click “OK”. The alert() method is used to add a message in the alert:</p><p><strong>Prompt Box</strong> - To input a value from the user and display it, use the prompt box. Users need to click “OK” to return the entered input, else click “Cancel” to return null.</p><p><strong>Confirm Box</strong> - The confirm box is used in JavaScript to take user's consent or accept something. User need to click “OK” to return true, else click “Cancel” to return false.</p>"
            },
            {
                "name": "Explain join() vs concat() in Javascript",
                "description": "<p>To join two or more strings, use the JavaScript <code>string.concat(string1, string2, ..., stringX)</code> method. A new string is returned with the joined strings.</p><p>The <code>array.join(separator)</code> method returns an array as a string. The elements will be separated by a specified separator. The default separator is comma (,).</p><p><code>join()</code> does not change the original array.</p>"
            },
            {
                "name": "Remove whitespace from both sides of a string in JavaScript",
                "description": "<p>The <code>trim()</code> method is used to remove whitespace from both sides of a string.</p><p><code><strong>var myStr = \" &nbsp; &nbsp; Cup of tea! &nbsp; &nbsp;\";</code></strong></p><code><strong>myStr.trim( )</strong></code>"
            },
            {
                "name": "Role of “use strict” in JavaScript",
                "description": "<p>The “use strict” is a literal expression introduced in ECMAScript version 5. It indicates that the code should be executed in \"strict mode\", which in turn considered a good practice.</p><ul> <li>The key use of this mode is if you won’t declare a variable and use it, then an error would be visible.<br><img src='./assets/js/strict.png'></li><li><strong>Case1: It is not allowed to delete a variable in strict mode</strong><br><img src='./assets/js/strict1.png'><br><code>Error: Deletion of an unqualified identifier in strict mode</code></li><li><strong>Case 2: Using Octal numeric literals are not allowed</strong><br><img src='./assets/js/strict2.png'><br><code>Error: Octal literals are not allowed in strict mode</code></li></ul>"
            },
            {
                "name": "Role of JSON.stringify() in JavaScript",
                "description": "<p>When data is sent to a web server, it has to be in the form of string. The <code>JSON.stringify()</code> method is used in JavaScript to convert an object to string.</p>"
            },
            {
                "name": "Anonymous functions vs JavaScript closures",
                "description": "<p><strong>JavaScript Closures</strong> - A closure is a function in JavaScript which have access to the parent scope, even after closing the parent function.</p><p><strong>Anonymous functions</strong> - Creating a function without a name is what we call Anonymous functions. Let us see an example:</p>"
            },
            {
                "name": "What does “javascript:void(0)” mean?",
                "description": "<p>The javascript:void(0) evaluates an expression even if its addition to a web page brings unwanted output.<br><br>Use the void(0) to get the undefined primitive value. Here, we are preventing the page from loading on clicking the hyperlink:</p>"
            },
            {
                "name": "What is NaN in JavaScript?",
                "description": "<p>NaN suggests that the entered value is not a legal number. It is a JavaScript property, which can also be considered as a \"Not-a-Number\" value.</p><p>To determine the entered value is a number or not, you can use the Number.isNaN() method. If the result is “True”, then it would that the given value is not a number, whereas “False” would mean the value is a legal Number.</p>"
            },
            {
                "name": "How to unset a JavaScript variable?",
                "description": "<p>The “undefined” is used to unset a variable in JavaScript.</p><p>Declare and initialize a variable:</p><strong>var a = 50;</strong><p>Now reassign the variable with undefined since we wish to unset it:</p><strong>a = undefined; </strong><p>The output displays undefined:</p>"
            },
            {
                "name": "What is a fat arrow function in JavaScript?",
                "description": "<p>Generally, in JavaScript we create functions using the function keyword:</p><p><img src='./assets/js/function1.png'></p><p>Using the Fat arrow function reduces line of code and even avoids you to write the keyword “function” again and again.</p><p>The syntax of fat arrow function includes =&gt;, wherein it shows fat arrow:</p><strong>arg =&gt; exp</strong><p>For multiple arguments:</p><strong>(arg1 [, arg2]) =&gt; exp</strong>"
            },
            {
                "name": "Difference between substr() vs substring() vs slice() in JavaScript?",
                "description": "<p>The substr() and substring() methods are simpler, yet they have some differences. The 2nd argument of the substring() method is the index to halt the search, whereas the 2nd&nbsp;parameter of substr() is the maximum length.</p><p><strong>substr() method</strong> - The substr() method returns the characters in a string beginning at the specified location. It goes through the number of characters which is specified by the user.</p><p>The parameters of substr(start, len):</p><ul><li>start&nbsp;− Location start extracting characters.</li><li>length&nbsp;− The count of characters to extract.</li></ul><strong><code>let str = \"Hello world!\"; <br> str.substr(1, 4) <br> // Console Returns \"ello\"</code></strong><p><strong>substring() method</strong> - The substring() method returns subset of a string.</p><p>The parameters of substring(i1, i2):</p><ul><li>i1&nbsp;– Index from where you want the substring.</li><li>i2&nbsp;− Index till when you want the substring.</li></ul><strong><code>let str = \"Hello world!\"; <br> str.substring(1, 4) <br> // Console Returns \"ell\"</code></strong><p></p>"
            },
            {
                "name": "What is prototypal inheritance?",
                "description": "<p>Prototypal inheritance is to add new capabilities to a constructor function using Prototype.<br>Let's first understand what are Constructor functions. They are basically JavaScript way to implement the concept of Classes.<br>Let's consider the example below, where we have a “Car” constructor function. In it we have a “model”, which we are also returning by getModel(). Now we can create a new instance of it by using the “new” keyword. Each instance will have its own “this” and have its own getModel().</p><p><img src='./assets/js/functionprototype2.jpg'></p><p>Now, the problem is that every time we create a new instance we get a new copy of <em>getModel().</em> Suppose we have 100 instances, then we will have 100 copies.</p><p>In JavaScript as you know everything is an Object. Whenever a function is created there are two object one is the function object another is the prototype object. Now to access the <strong>Prototype</strong> object we have a property on the function object also known as “<strong>prototype</strong>”.</p><p>We should somehow move the logic for&nbsp;<em>getModel()</em> outside our Constructor function and that is where the concept of Prototype helps.</p><p><img src='./assets/js/functionprototype3.jpg'></p><p>We get the same result and this is known as <strong>Prototypal Inheritance</strong>. Also, each new instance don’t have its own getModel(), which we can see in below console log.</p><p><img src='./assets/js/functionprototype4.jpg'></p>"
            },
            {
                "name": "Is JavaScript synchronous or asynchronous and what is event loop?",
                "description": "<p>JavaScript is a synchronous, blocking, single-threaded language. That just means that only one operation can be in progress at a time.</p><p>Many people think JavaScript is asynchronous because we can do async tasks like setTimeout, callbacks, promises in it. But the asynchronous behaviour of JavaScript(setTimeout, callbacks, promises) is not a part of JavaScript itself and built on top of JavaScript language in browser and accessed through browser APIs.</p><p>The browser have a Call Stack, Browser API and Message Queue and the order of their processing is called <strong>event loop</strong>.</p><p><img src='./assets/js/eventloop.png'></p><p>The output will be A C B , even after the setTimeout() was set to display “b” after 0 ms. This happens because of the internal working of the browser.</p><p>The main() is pushed into Call Stack, which then console logs A. Then it is popped out and the setTimeout is pushed into Call Stack. Now the setTimeout() uses Browser API, so it is pushed there and the console log C is pushed into Call Stack.</p><ul><li>Even with the delay of 0ms the exec() for setTimeout have to go to the Message Queue.</li><li>After all the statements of main() is run and the Call Stack is empty, then only the exec() from Message Queue can be pushed to the Call Stack.</li></ul><p>This is how event loop works and the asynchronous, non-blocking part of JavaScript comes from.</p>"
            },
            {
                "name": "Explain ”this” with call, apply and bind in JavaScript?",
                "description": "<p>Every function in JavaScript have call, apply and bind methods. These methods can be used to set the custom value of “this” to the execution context of the function.</p><p> <strong>call</strong><strong> - It's a predefined method in javascript. This method invokes a method (function) by specifying the owner object.<br/></strong>Let's say that we have an object called <strong>obj</strong>. It only has one property called <strong>num</strong>, which has a value of 3. Let's also make a function called <strong>addNumbers</strong>.</p><p> Now, in <strong>addNumbers</strong> we have this.num. But how do we pass the value obj.num to it. We need to pass it a context, which means the value of “this”. We will do this my call method by passing a first argument as obj, so the “this” is the obj now.</p><p><img src='./assets/js/call1.png'/></p><p> <strong>apply</strong><strong><br/></strong>It is totally similar to call, but the only difference is that we can pass array as the second argument. We will use the same code for apply also. But now we have an <em>arr</em>, to be passed as second argument.</p><p><img src='./assets/js/apply1.png'/></p><p> <strong>bind</strong><strong><br/></strong>Bind works in a bit different way then call and apply. It works by returning a copy of the function. We will take the returned function in <strong>bindFunc</strong> and then execute it in the next line.</p><p><img src='./assets/js/bind2.png'/></p>"
            },
            {
                "name": "When would you use the bind function?",
                "description": "<p>A good use of the <code>bind</code> function is when you have a particular function that you want to call with a specific this value. You can then use <code>bind</code> to pass a specific object to a function that uses a <code>this</code> reference.</p><br> <img src='./assets/js/bind1.png'>"
            },
            {
                "name": "Explain nested promises JavaScript?",
                "description": "<p>Nested promises are set of promises in which , the result of one promise we call another in the .then statement. It is very useful in practical applications, where the result of fetch from an API endpoint will result in sending the data to another endpoint. Nested promises can also be done with callback functions, but the code get complicated soon.</p><p>Let's look at an example of nested promises. Here we have three functions which return promises- <em>coinTossed, gotCoinTossedResult and happyTeam</em>. Now only the <em>coinTossed</em> is returning resolve() or reject() depending on random number. The other two functions are returning only resolve() for simplicity sake.</p><p>Now, when the <em>coinTossed</em> function is run and return a resolve(), then the immediate .then block will be run or else we will go to the .catch block. In the .then we are returning the next <em>gotCoinTossedResult&nbsp;</em>and in its .then we are returning the <em>happyTeam</em>. We are passing the message from one function to other, so it will be appended.</p><p><img src='./assets/js/cointoss.png'></p>"
            },
            {
                "name": "Explain currying in JavaScript and implement multiply(2)(3)(4)(10) using it?",
                "description": "<p>Currying is a technique of evaluating function with <em>multiple arguments</em>, into sequence of function with single argument.</p><p>In other words, when a function, instead of taking all arguments at one time, takes the first one and return a new function that takes the second one and returns a new function which takes the third one, and so forth, until all arguments have been fulfilled.</p><p><img src='./assets/js/currying.png'></p><p>Currying works because of JavaScript concept of closures. The closure created by the nested functions to retain access to each of the arguments. So inner function which do “return a * b * c * d” have access to all arguments.</p>"
            },
            {
                "name": "Explain sub-classes and inheritance in ES6?",
                "description": "<p>The concept of Sub-classes and inheritance is like that in other languages like Java and C++. The sub-class can inherit properties from its parent class and can also override or update an existing method.</p><p><img src='./assets/js/subclass.png'></p>"
            },
            {
                "name": "Why JavaScript 'var null' throw error but 'var undefined' doesn't?",
                "description": "<p><code><strong>null (var null)</strong></code> - In JavaScript, null is a reserved identifier, therefore we cannot use it as an identifier in JavaScript. An error can be seen if we will write:</p><p><img src='./assets/js/null.png'></p><p>The web browser throws an error for “var null” since it is a reserved identifier, The following is the error visible</p><strong>SyntaxError: Unexpected token null </strong><p><code><strong>undefined (var undefined)</strong></code> - The undefined is not a reserved identifier, therefore if you will write the following, then no error would be thrown:</p><p><img src='./assets/js/undefined.png'></p><p><strong>Output</strong></p><strong>Undefined</strong>"
            },
            {
                "name": "Format numbers as currency string in JavaScript",
                "description": "<p>The number formatter would allow you to format numbers as the currency you want it to work.</p><ul> <li>USD - <br><img src='./assets/js/formatus.png'></li><li>EUR - <br><img src='./assets/js/formateur.png'></li></ul>"
            },
            {
                "name": "Difference between parseInt(string) and Number(string) in JavaScript?",
                "description": "<p>The parseInt() method parses up to the first non-digit and returns the parsed value, whereas Number() converts the string into a number, which can also be a float.</p><strong><code>&lt;script&gt; <br> document.write(parseInt(\"20demo\")); <br>&lt;/script&gt;</code><br><br> //Output <br> 20 </strong><p>Using the Number(string), the same value returns NaN:</p><strong><code>&lt;script&gt; <br> document.write(Number(\"20demo\")); <br>&lt;/script&gt;</code><br><br> //Output <br> NaN </strong><p>Let us now workaround for a float value with both Number(string) and parseInt(string)</p><strong><code>&lt;script&gt; <br> document.write(Number(\"12.99demo\"));<br>document.write(\"<br>\"+parseInt(\"12.99demo\")); <br>&lt;/script&gt;</code><br><br>//Output <br>NaN<br>12 </strong>"
            },
            {
                "name": "How to check whether entered value is NaN in JavaScript?",
                "description": "<p>To check whether a value entered is a NaN or not, use the Number.isNaN() method. This method returns true if the value is not a number, else false is returned.</p><strong>var a = 'z'; </strong><p><strong>isNaN(a); </strong></p>"
            },
            {
                "name": "How to detect a mobile device with JavaScript?",
                "description": "<p>To detect a mobile device, let's say Android device, use the navigator.userAgent.match. Here, we have set it in a function:</p><strong> Android: function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return navigator.userAgent.match(/Android/i);<br>&nbsp; &nbsp; &nbsp; &nbsp; },</strong><p>For iOS:</p><strong>&nbsp; &nbsp;iOS: function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return navigator.userAgent.match(/iPhone|iPad/i);<br>&nbsp; &nbsp; &nbsp; &nbsp; },</strong> </div>"
            },
            {
                "name": "Difference between some() vs every() in javascript",
                "description": "<p>The <code>some()</code> method checks if any of the elements in an array pass a test (provided as a function)., where as the <code>every()</code> method returns true if all elements in an array passes the test (provided as a function).</p><p><code>some()</code> executes the function once for each element in the array: which means, during the execution If it finds an array element where the function is returning a <em>true</em> value against the test condition, then some() method returns true (and does not check the remaining values), Otherwise it returns false</p><p>The <code>every()</code> method executes the function once for each element present in the array: which means, during the execution If it finds an array element where the function is returning a <em>false</em> value against the test condition, then every() method returns false (and does not check the remaining values), Otherwise it returns true</p><p><strong>Both</strong> does not execute the function for empty array elements.</p><p><strong>Both</strong> does not change the original array.</p>"
            },
            {
                "name": "What is the value of typeof undefined == typeof NULL?",
                "description": "<p>The expression will be evaluated to true, since NULL will be treated as any other undefined variable.<br>Note: JavaScript is case-sensitive and here we are using NULL instead of null.</p>"
            },
            {
                "name": "How to check if an object is an array or not? (object array)",
                "description": "<p><img src='./assets/js/arrayorobject.png'></p>"
            },
            {
                "name": "Why Browser Object Model (BOM) introduced in JavaScript?",
                "description": "<p>To interact with the browser, the Browser Object Model has some properties and methods. Some examples include, the height and width of the window/ screen.</p><p>Some of its methods include:</p><ul><li>window.open() – To open a new window</li><li>window.close() – To close the current window</li><li>window.moveTo() – To move the current window</li><li>window.resizeTo() – To resize the current window</li></ul>"
            },
            {
                "name": "How would you check if a number is an integer?",
                "description": "<p>From Method<br><code>Number.isInteger(value);</code></p><p>From Code<br><code>function isInt(num) {<br> &nbsp;&nbsp;&nbsp;&nbsp; return num % 1 === 0;<br> }</code></p>"
            },
            {
                "name": "Difference between DOMContentLoaded and load Events",
                "description": "<p>These two events <strong>DOMContentLoaded</strong> and <strong>load</strong> are used to check when a webpage has loaded completely. Still, there are some factors that determine the preference of one over the other.</p><p><strong>DOMContentLoaded</strong> event gets executed once the basic HTML document is loaded and its parsing has taken place. This event doesn’t wait for the completion of the loading of add-ons such as stylesheets, sub-frames and images/pictures.</p><p><img src='./assets/js/dom.png'></p><p><strong>Advantages of using DOMContentLoaded event:</strong></p><ul><li>It helps in improving user experience as it shows messages or content much faster.</li><li>It takes lesser time in loading the page.</li></ul><br><br><p><strong>load</strong> event performs its execution differently. This event gets completed once all the components i.e. DOM hierarchy along with associated features of a webpage such as CSS files, JavaScript files, images/pictures, and external links are loaded. So basically, the load event helps in knowing when the page has fully-loaded.</p><p><img src='./assets/js/load.png'></p><p><strong>Advantages of using load event:</strong></p><ul><li>This event helps in knowing when all the components of the webpage is loaded.</li></ul>"
            },
            {
                "name": "Array Reference",
                "description": "<ul> <li><strong>map( )</strong> - This method creates a new array with the results of calling a provided function on every element in this array. <br><img src='./assets/js/arraymap.png'><br><br></li><li><strong>filter( )</strong> - This method creates a new array with only elements that passes the condition inside the provided function.<br><img src='./assets/js/arrayfilter.png'><br><br></li><li><strong>sort( )</strong> - This method is used to arrange/sort array's elements either in ascending or descending order.<br><img src='./assets/js/arraysort.png'><br><br></li><li><strong>forEach( )</strong> - This method helps to loop over array by executing a provided callback function for each element in an array.<br><img src='./assets/js/arrayforeach.png'><br><br></li><li><strong>concat( )</strong> - This method is used to merge two or more arrays and returns a new array, without changing the existing arrays.<br><img src='./assets/js/arrayconcat.png'><br><br></li><li><strong>every( )</strong> - This method checks every element in the array that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arrayevery.png'><br><br></li><li><strong>some( )</strong> - This method checks if at least one element in the array that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arraysome.png'><br><br></li><li><strong>includes( )</strong> - This method checks if an array includes the element that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arrayincludes.png'><br><br></li><li><strong>join( )</strong> - This method returns a new string by concatenating all of the array's elements separated by the specified separator.<br><img src='./assets/js/arrayjoin.png'><br><br></li><li><strong>reduce( )</strong> - <p>Reduce the values of an array to a single value (going left-to-right) and for right-to-left use reduceRight().<br>The reduce() method executes a provided function for each value of the array (from left-to-right)<br>The return value of the function is stored in an accumulator (result/total)<br><img src='./assets/js/reduce.png'><br><br></li><li><strong>find( )</strong> - This method returns the value of the first element in an array that pass the test in a testing function.<br><img src='./assets/js/arrayfind.png'><br><br></li><li><strong>findIndex( )</strong> - This method returns the index of the first element in an array that pass the test in a testing function.<br><img src='./assets/js/arrayfindindex.png'><br><br></li><li><strong>indexOf( )</strong> - This method returns the index of the first occurrence of the specified element in the array, or -1 if it is not found.<br><img src='./assets/js/arrayindexof.png'><br><br></li><li><strong>fill( )</strong> - This method fills the elements in an array with a static value and returns the modified array.<br><img src='./assets/js/arrayfill.png'><br><br></li><li><strong>slice( )</strong> - This method returns a new array with specified start to end elements.<br><img src='./assets/js/arrayslice.png'><br><br></li><li><strong>reverse( )</strong> - This method reverses an array in place. Element at last index will be first and element at 0 index will be last.<br><img src='./assets/js/arrayreverse.png'><br><br></li><li><strong>push( )</strong> - This method adds one or more elements to the end of array and returns the new length of the array.<br><img src='./assets/js/arraypush.png'><br><br></li><li><strong>pop( )</strong> - Remove an item from the end of an array and returns the item(string) which was removed from that array<br><img src='./assets/js/pop.png'><br><br></li><li><strong>shift( )</strong> - This method removes an item from the start of an array and returns the item which was removed from that array<br><img src='./assets/js/arrayshift.png'><br><br></li><li><strong>unshift( )</strong> - This method adds one or more elements to the beginning of an array and returns the new length of the array.<br><img src='./assets/js/arrayunshift.png'><br><br></li></ul>"
            },
            {
                "name": "Methods to Search Through Arrays (include, find, filter)",
                "description": "<p>The <code>.includes()</code> method returns a boolean value and is perfect for telling you whether an element exists in an array or not. It gives a simple true or false answer.<br><strong>Syntax</strong>: <code>arr.includes(valueToFind, [fromIndex]); //fromIndex is optional</code><br><strong>Example</strong>: <code>const alligator = ['thick scales', 80, '4 foot tail', 'rounded snout'];<br>alligator.includes('thick scales'); // returns true</code></p><p>The <code>.find()</code> method is used to find and return the first occurence of an element in an array, under a defined testing function. and if the condition is not met, it returns <code>undefined</code><br><strong>Syntax</strong>: <code>array.find(testingFunction);</code><br><code>const trees = [<br> { name: 'birch', count: 4 },<br> { name: 'oak', count: 2 }<br> { name: 'maple', count: 5 },<br> { name: 'oak', count: 8 }<br> ];<br><br> const result = trees.find(tree => tree.name === 'oak');<br> // { name: 'oak', count, 2 }</code></p><p>The <code>.filter()</code> method is like the find() method, in that it requires a function passed and a condition for what will be returned. The main difference is, filter() always returns an array, even if there is only one matching element. But it will return all the matching elements, whereas find() only returns the first matching. The important thing with filter is that it returns all the elements matching your criteria.<br><strong>Syntax</strong>:<code>var newArray = array.filter(function(item) {<br> return condition;<br> });</code><br><code>var heroes = [ <br> {name: 'Batman', franchise: 'DC'}, <br> {name: 'Ironman', franchise: 'Marvel'}, <br> {name: 'Thor', franchise: 'Marvel'}, <br> {name: 'Superman', franchise: 'DC'} <br> ]; <br> <br> var marvelHeroes = heroes.filter(function(hero) { <br> return hero.franchise == 'Marvel'; <br> }); <br> <br> // [ {name: 'Ironman', franchise: 'Marvel'}, {name: 'Thor', franchise: 'Marvel'} ]</code></p>"
            },
            {
                "name": "Find the intersection of two arrays",
                "description": "<p> The logic here is to create a hashmap with the elements of the firstArray as the keys. <br>After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash <br>If it does exist, add that element to the new array.</p><p>Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added</p><p><img src='./assets/js/intersection.png'></p>"
            },
            {
                "name": "What is AJAX",
                "description": "<p>AJAX = Asynchronous JavaScript And XML.<br>AJAX is not a programming language.<br>AJAX just uses a combination of:</p><ul><li>A browser built-in <code>XMLHttpRequest</code> object (to request data from a web server)</li><li>JavaScript and HTML DOM (to display or use the data)</li></ul><p>Read data from a web server - after the page has loaded. Update a web page without reloading the page where as updates the DOM or the parts of a web page</p>"
            },
            {
                "name": "How do you make synchronous / asynchronous XML HTTP request?",
                "description": "<p>Browsers provide an XMLHttpRequest object which can be used to make asynchronous HTTP requests from JavaScript by passing 3rd parameter as true for asynchronous and false for synchronous.</p><p><img src='./assets/js/xmlhttprequest.png'></p><p><img src='./assets/js/xmlhttprequest1.png'></p>"
            },
            {
                "name": "What is memoization?",
                "description": "<p>Memoization is a programming technique which attempts to increase a function's performance by caching its previously computed results. Each time a memoized function is called, its parameters are used to index the cache. If the data is present, then it can be returned, without executing the entire function. Otherwise the function is executed and then the result is added to the cache<br><br><img src='./assets/js/memiozation.png'></p>"
            },
            {
                "name": "What is Temporal Dead Zone?",
                "description": "<p>Temporal Dead Zone is a behaviour that occurs with variables declared using let and const keywords.</p><p>It is a behaviour where we try to access a variable before it is initialized.<br><img src='./assets/js/deadZone.png'>.</p> "
            },
            {
                "name": "When should you NOT use arrow functions in ES6? Name three or more cases.",
                "description": "<p>Arrow functions should NOT be used:</p><ul><li>When we want function hoisting - as arrow functions are anonymous.</li><li>When we want to use this/arguments in a function - as arrow functions do not have this/arguments of their own, they depend upon their outer context.</li><li>When we want to use named function - as arrow functions are anonymous.</li><li>When we want to use function as a constructor - as arrow functions do not have their own this.</li><li>When we want to add function as a property in object literal and use object in it - as we can not access this (which should be object itself).</li></ul>"
            },
            {
                "name": "What is a first class function?",
                "description": "<p>In Javascript, functions are first class objects. First-class functions means when functions in that language are treated like any other variable.<br><img src='./assets/js/first-class.png'></p>"
            },
            {
                "name": "What is a first order function?",
                "description": "<p>First-order function is a function that doesn’t accept other function as an argument and doesn’t return a function as its return value.</p><br><img src='./assets/js/first-order.png'>"
            },
            {
                "name": "How would you create a private variable in JavaScript?",
                "description": "<p>To create a private variable in JavaScript that cannot be changed you need to create it as a local variable within a function. Even if the function is executed the variable cannot be accessed outside of the function. For example:<br><img src='./assets/js/private-variable.png'></p><p>To access the variable, a helper function would need to be created that returns the private variable.<br><img src='./assets/js/private-variable1.png'></p>"
            },
            {
                "name": "Difference between: `function Person(){}`, `var person = Person()`, and `var person = new Person()`?",
                "description": "<p><code>function Person(){}</code> is just a normal function declaration.<br><br><code>var person = Person()</code> invokes the <code>Person</code> as a function, and not as a constructor. Invoking as such is a common mistake if it the function is intended to be used as a constructor. Typically, the constructor does not return anything, hence invoking the constructor like a normal function will return <code>undefined</code> and that gets assigned to the variable intended as the instance.<br><br><code>var person = new Person()</code> creates an instance of the Person object using the <code>new</code> operator, which inherits from <code>Person.prototype</code><br><img src='./assets/js/share.png'></p><p><strong>What will happen if I write <code>Person.name = “John”;</code></strong><br>Answer : It will throw error Cannot assign to read-only property ‘name’.</p><br><p><strong>What will happen if I write </strong><br><code>var p1 = new Person(“YYY”,21); <br>p1.name =”ZZZ”; <br>console.log(p1.name);</code><br>Answer: ZZZ</p>"
            },
            {
                "name": "Difference between a `.forEach` vs `.map()` loop",
                "description": "<p>The main difference between <code>.forEach</code> and <code>.map()</code>, is that <code>.map()</code> utilizes <code>return statement</code> and actually returns a new Array of the same size.</p><p><strong><code>forEach</code></strong></p><ul><li>Iterates through the elements in an array.</li><li>Executes a callback for each element.</li><li>Does not return a value.</li></ul><p><img src='./assets/js/foreach.png'></p><p><strong><code>map</code></strong></p><ul><li>Iterates through the elements in an array.</li><li>'Maps' each element to a new element by calling the function on each element, creating a new array as a result.</li></ul><p><img src='./assets/js/map.png'></p>"
            },
            {
                "name": "Is JavaScript a pass-by-reference or pass-by-value language?",
                "description": "<p>In JavaScript, primitive data types are passed by value and non-primitive data types are passed by reference.<br><br>It's always pass by value, but for objects the value of the variable is a reference.  Because of this, when you pass an object and change its members, those changes persist outside of the function.  This makes it look like pass by reference.  But if you actually change the value of the object variable you will see that the change does not persist, proving it's really pass by value.<br><img src='./assets/js/pass.png'></p>"
            },
            {
                "name": "Boolean Reference",
                "description": "<p><table class='table table-striped'><tbody><tr><th style='width:20%'>Method</th><th>Description</th></tr><tr><td>toString()</td><td>Converts a boolean value to a string, and returns the result</td></tr><tr><td>valueOf()</td><td>Returns the primitive value of a boolean</td></tr></tbody></table></p>"
            },
            {
                "name": "Class Reference",
                "description": "<p>A class is a type of function, but instead of using the keyword function to initiate it, we use the keyword class, and the properties are assigned inside a constructor() method:</p><p>Class Methods<br><table class='table table-striped'><tbody><tr><th style='width:20%'>Method</th><th>Description</th></tr><tr><td>constructor()</td><td>A special method for creating and initializing objects created within a class</td></tr></tbody></table></p><p>Class Keywords<br><table class='table table-striped'><tbody><tr><th style='width:20%'>Keyword</th><th>Description</th></tr><tr><td>extends</td><td>It is used to create a child class of another class (parent)</td></tr><tr><td>static</td><td>The <code>static</code> keyword defines static methods for classes. Static methods are called directly on the class - without creating an instance/object of the class</td></tr><tr><td>super</td><td>The <code>super</code> keyword refers to the parent class. It is used to call the constructor of the parent class and to access the parent's properties and methods.</td></tr></tbody></table></p><p>Example of extends and Super keyword<br><img src='./assets/js/super-class.png'></p>"
            },
            {
                "name": "JSON Reference",
                "description": "<p><table class='table table-striped'><tbody><tr><th style='width:30%'>Method</th><th>Description</th></tr><tr><td>parse()</td><td>When receiving the data from a web server, the data is always in a string format. But you can convert this string value to javascript object using parse() method. <code>var userString = '{'name':'John','age':31}';<br> var userJSON = JSON.parse(userString);<br> console.log(userJSON);<br>// {name: 'John', age: 31}</code></td></tr><tr><td>stringify()</td><td>When sending data to a web server, the data has to be in a string format. You can achieve this by converting JSON object into a string using stringify() method.<code>var userJSON = {'name': 'John', age: 31}<br> var userString = JSON.stringify(user);<br> console.log(userString); <br>// '{'name':'John','age':31}'</code></td></tr></tbody></table></p>"
            },
            {
                "name": "Difference between splice() and slice()",
                "description": "<p>The <strong>slice()</strong> method returns a new array with a copy of sliced item from the original array. Here, the first optional argument marks the beginning index and the second optional argument marks the ending index. Where as index marked with negative number starts from the end of the array. <br>###Slice method won't mutate the original array but it returns the subset as new array.</p><p>The <strong>splice()</strong> method changes the content of the array in place and can be used to add or remove items from the array. It returns the removed items in the array. The first argument marks the array position for insertion or deletion, whereas the second optional argument marks the number of elements to be deleted. <br>###Splice method modifies the original array and returns the deleted array.</p>"
            },
            {
                "name": "Difference between filter() and map()",
                "description": "<p><strong>filter()</strong>: creates a new array with elements that fall under a given condition from an existing array.</p><p><strong>map()</strong>: 'Maps' each element to a new element by calling the function on each element, creating a new array as a result.</p>"
            },
            {
                "name": "Difference between findIndex() and indexof()",
                "description": "<p><strong>findIndex()</strong>: This function returns index of the first element of the given array which satisfies the testing function.</p><p><strong>indexof()</strong>: This function is used to find the index of the first occurrence of the element provided for search as the argument to the function. If the item is present more than once, the indexOf method returns the position of the first occurence.</p>"
            },
            {
                "name": "Difference between find() and filter()",
                "description": "<p><strong>find()</strong>: The find() method returns the first value that matches from the collection. Once it matches the value in findings, it will not check the remaining values in the array collection.</p><p><strong>filter()</strong>: creates a new array with elements that fall under a given condition from an existing array.</p>"
            },
            {
                "name": "Difference between console.dir and console.log?",
                "description": "<ul><li><code>console.log(input)</code>: The browser logs in a nicely formatted manner</li><li><code>console.dir(input)</code>:  The browser logs just the object with all its properties</li></ul>"
            },
            {
                "name": "Difference between window and document?",
                "description": "<table><thead><tr><th>Window</th><th>Document</th></tr></thead><tbody><tr><td>It is the root level element in any web page</td><td>It is the direct child of the window object. This is also known as Document Object Model(DOM)</td></tr><tr><td>By default window object is available implicitly in the page</td><td>You can access it via window.document or document.</td></tr><tr><td>It has methods like alert(), confirm() and properties like document, location</td><td>It provides methods like getElementById, getElementByTagName, createElement etc</td></tr></tbody></table>"
            },
            {
                "name": "What is a Regular Expression or RegExp?",
                "description": "<p>A regular expression is a sequence of characters that forms a search pattern. You can use this search pattern for searching data in a text. These can be used to perform all types of text search and text replace operations.</p><img src='./assets/js/searchStringPattern.png'>"
            },
            {
                "name": "What are modifiers in RegExp?",
                "description": "<p>Modifiers can be used to perform case-insensitive and global searches. Let's list down some of the modifiers,</p><table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody><tr><td>i</td><td>Perform case-insensitive matching</td></tr><tr><td>g</td><td>Perform a global match rather than stops at first match</td></tr><tr><td>m</td><td>Perform multiline matching</td></tr></tbody></table><br><img src='./assets/js/globalmodifier.png'>"
            },
            {
                "name": "What are RegExp patterns?",
                "description": "<p>Regular Expressions provided group of patterns in order to match characters. Basically they are categorized into 3 types,</p><ul><li><strong>Brackets:</strong> These are used to find a range of characters. For example, below are some use cases,<ul><li>[abc]: Used to find any of the characters between the brackets(a,b,c)</li><li>[0-9]: Used to find any of the digits between the brackets</li><li>(a|b): Used to find any of the alternatives separated with |</li></ul></li><li><strong>Metacharacters:</strong> These are characters with a special meaning For example, below are some use cases,<ul><li>d: Used to find a digit</li><li>s: Used to find a whitespace character</li><li>b: Used to find a match at the beginning or ending of a word</li></ul></li><li><strong>Quantifiers:</strong> These are useful to define quantities For example, below are some use cases,<ul><li>n+: Used to find matches for any string that contains at least one n</li><li>n*: Used to find matches for any string that contains zero or more occurrences of n</li><li>n?: Used to find matches for any string that contains zero or one occurrences of n</li></ul></li></ul>"
            },
            {
                "name": "What are generator functions?",
                "description": "<p>Introduced in ES6 version, generator functions are a special class of functions.</p><p><strong>They can be stopped midway and then continue from where it had stopped.</strong></p><p>Generator functions are declared with the <strong>function*</strong> keyword instead of the normal <strong>function</strong> keyword</p><p><code><strong>function* genFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;// Perform operation<br>}</strong></code></p><p>In normal functions, we use the <strong>return</strong> keyword to return a value and as soon as the return statement gets executed, the function execution stops:</p><p> <code><strong> function normalFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;return 22;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(2); // This line of code does not get executed<br>}</strong></code> </p><p>In the case of generator functions, when called, they do not execute the code, instead they return a <strong>generator object</strong>. This generator object handles the execution</p><p><code><strong> function* genFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 3;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 4;<br>}<br>genFunc(); // Returns Object [Generator]{}</strong></code></p><p>The generator object consists of a method called <strong>next()</strong> , this method when called, executes the code until the nearest <strong>yield</strong> statement, and returns the yield value.</p><p><img src='./assets/js/generator.png'></p><p>As you can see in the code above, the last line returns done:true , since the code reaches the return statement.</p>"
            },
            {
                "name": "Object Equality - How would you compare two objects in JavaScript?",
                "description": "<p>To check that, you can get the keys for both the objects. If the number of properties doesn't match, these two objects are not equal. Secondly, you will check each property whether they have the same value. If all the properties have same value, they are equal.</p><p><img src='./assets/js/objectcompare.png'></p>"
            },
            {
                "name": "Compare Async/Await and Generators usage to achive same functionality",
                "description": "<ul><li>Generator function are executed yield by yield i.e one yield-expression at a time by its iterator (the next method) where as Async-await, they are executed sequential await by await.</li><li>Async/await makes it easier to implement a particular use case of Generators.</li><li>The return value of Generator is always {value: X, done: Boolean} where as for Async function it will always be a promise that will either resolve to the value X or throw an error.</li><li>Async function can be decomposed into Generator and promise implementation like:</li></ul><p><img src='./assets/js/asyncAwaitGenerator.png'></p>"
            },
            {
                "name": "True False Rapid Fire",
                "description": "<p><strong>Question: </strong>Is<code>'false'</code>is!1?<br><strong>Answer: </strong>No.Because,it's a string with length greater than 0. Only empty string is false.</p><p><strong>Question: </strong> Is <code>' '</code> is false?<br><strong>Answer: </strong> No. Because, it's not an empty string.There is a white space in it.</p><p><strong>Question: </strong>What about<code>{}</code>?<br><strong>Answer: </strong>!0.It's an object. An object without any property is an object can't be falsy.</p><p><strong>Question: </strong>Tell me about<code>[]</code>?<br><strong>Answer: </strong>This is also truthy.It's an array object (array is child of object) is truthy.</p><p><strong>Question: </strong>You talked bout <code>''</code> to be falsy. What about <code>new String('')</code>?<br><strong>Answer: </strong> Though you are passing empty string to the string constructor, it is creating an String object. More precisely a instance of String object. It becomes an object. Hence, it is not false. so, it is truthy.</p><p><strong>Question: </strong> Tell me about <code>new Boolean(false)</code><br><strong>Answer: </strong> truthy. As it creates an instance of the Boolean object which is an object. Object is truthy.</p><p><strong>Question: </strong> <code>Boolean(function(){})</code><br><strong>Answer: </strong> <code>true</code> if you pass a truthy value to Boolean, it will be true.</p><p><strong>Question: </strong> <code>Boolean(/foo/)</code><br><strong>Answer: </strong> <code>true</code></p><p><strong>Question: </strong> <code>true%1</code><br><strong>Answer: </strong> 0. When you are trying to find reminder of true, true becomes 1 and reminder of 1 while dividing by 1 is 0. you will get same result if you doe <code>false%1</code></p><p><strong>Question: </strong> <code>''%1</code><br><strong>Answer: </strong>0</p>"
            },
            {
                "name": "Rapid Fire",
                "description": "<p><strong>Question: </strong> What is <code>typeof []</code><br><strong>Answer: </strong> Object. Actually Array is derived from Object. If you want to check array use <code>Array.isArray(arr)</code></p><p><strong>Question: </strong> What is <code>typeof arguments</code><br><strong>Answer: </strong> Object. arguments are array like but not array. it has length, can access by index but can't push pop, etc.</p><p><strong>Question: </strong> What is <code>2+true</code><br><strong>Answer: </strong> 3. The plus operator between a number and a boolean or two boolean will convert boolean to number. Hence, true converts to 1 and you get result of 2+1</p><p><strong>Question: </strong> What is <code>'6'+9</code><br><strong>Answer: </strong> 69. If one of the operands of the plus (+) operator is string it will convert other number or boolean to string and perform a concatenation. For the same reason, <code>'2'+true</code> will return '2true'</p><p><strong>Question: </strong> What is the value of <code>4+3+2+'1'</code><br><strong>Answer: </strong> 91 . The addition starts from the left, 4+3 results 7 and 7+2 is 9. So far, the plus operator is performing addition as both the operands are number. After that 9 + '1' where one of the operands is string and plus operator will perform concatenation.</p><p><strong>Question: </strong> What is the value of <code>'1'+2+4</code><br><strong>Answer: </strong> '124'. For this one '1' + 2 will produce '12' and '12'+4 will generates '124'.</p><p><strong>Question: </strong> What is the value of <code>-'34'+10</code><br><strong>Answer: </strong> -24. minus(-) in front of a string is an unary operator that will convert the string to a number and will make it negative. Hence, -'34' becomes, -34 and then plus (+) will perform simple addition as both the operands are number.</p><p><strong>Question: </strong> What is the value of <code>+'dude'</code><br><strong>Answer: </strong> NaN. The plus (+) operator in front of a string is an unary operator that will try to convert the string to number. Here, JavaScript will fail to convert the 'dude' to a number and will produce NaN.</p><p><strong>Question: </strong> If you have <code>var y=1, x=y=typeof x;</code> What is the value of x?<br><strong>Answer: </strong> 'undefined'</p><p><strong>Question: </strong> for <code>var a=(2, 3, 5);</code> what is the value of a?<br><strong>Answer: </strong> 5. The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand.</p><p><strong>Question: </strong> for <code>var a=(1, 5 - 1) * 2</code> what is the value of a?<br><strong>Answer: </strong> 8</p><p><strong>Question: </strong> What is the value of <code>!'bang'</code><br><strong>Answer: </strong> false. <code>!</code> is NOT. If you put <code>!</code> in front of truthy values, it will return false. Using !! (double bang) is a tricky way to check anything truthy or falsy by avoiding implicit type conversion of==comparison.</p><p><strong>Question: </strong> What is the value of <code>parseFloat('12.3.4')</code><br><strong>Answer: </strong> 12.3</p><p><strong>Question: </strong> What is the value of <code>Math.max([2,3,4,5]);</code><br><strong>Answer: </strong> NaN</p><p><strong>Question: </strong> <code>3 instanceof Number</code><br><strong>Answer: </strong> false</p><p><strong>Question: </strong><code>null==undefined</code><br><strong>Answer: </strong> true</p><p><strong>Question: </strong>What is the value of <code>!!function(){};</code><br><strong>Answer: </strong> true</p><p><strong>Question: </strong> What is the value of <code>typeof bar</code><br><strong>Answer: </strong> 'undefined'</p><p><strong>Question: </strong> What is the value of <code>typeof null</code><br><strong>Answer: </strong> 'object'</p><p><strong>Question: </strong> If <code> var a=2, b=3</code> what would be value of <code>a &amp;&amp; b</code><br><strong>Answer: </strong> 3</p><p><strong>Question: </strong> What would be consoled <code>var foo='outside'; function logIt(){console.log(foo); var foo='inside';}logIt();</code><br><strong>Answer: </strong> undefined</p><p><strong>Question: </strong> What is <code>-5%2</code><br><strong>Answer: </strong>-1. the result of remainder always get the symbol of first operand</p><p><strong>Question: </strong> Why <code>.1+.2 !=.3</code><br><strong>Answer: true - floating point errors in internally representing certain numbers. 0.1 + 0.2 does not nicely come out to 0.3</strong></p><p><strong>Question: <code>42..toString()</code></strong><br><strong>Anwser:</strong> <code>'42'</code></p><p><strong>Question: </strong> <code>4.2..toString</code><br><strong>Anwser:</strong> //SyntaxError: Unexpected token .</p><p><strong>Question: </strong><code>42 . toString()</code><br><strong>Anwser:</strong> <code>'42'</code></p><p><strong>Question: </strong> <code>typeof(NaN)</code><br><strong>Anwser:</strong>'number'</p><p><strong>Question: </strong> <code>2 in [1,2]</code><br><strong>Anwser:</strong> false. Because 'in' returns whether a particular property/index available in the Object. In this case object has index 0 and 1 but don't have 2. Hence you get false.</p>"
            },
            {
                "name": "Draw a Simple JavaScript Dom (Document Object Model).",
                "description": "<p><img src='./assets/js/jsdom.png'></p>"
            },
            {
                "name": "What Is Garbage Collection in JavaScript?",
                "description": "<p>This type of <em>automatic memory management</em> monitors memory allocation to reclaim and free up allocated memory blocks that are no longer needed by the JavaScript program.</p>"
            },
            {
                "name": "List the 7 Error Types in JavaScript.",
                "description": "<ul><li><strong>EvalError:</strong> Error regarding the global function <em>eval()</em></li><li><strong>InternalError:</strong> Internal error in the JS engine (stack overflow, etc)</li><li><strong>RangeError: </strong>Numeric variable or parameter is outside of valid range</li><li><strong>ReferenceError:</strong> Invalid variable reference</li><li><strong>SyntaxError:</strong> Syntax error while parsing code in <em>eval()</em></li><li><strong>TypeError:</strong> Parameter or variable not of a valid type</li><li><strong>URIError:</strong> Invalid parameters passed to <em>decodeURI()</em> or <em>encodeURI()</em></li></ul>"
            },
            {
                "name": "What’s the Difference Between the Javascript Engine & Javascript Runtime?",
                "description": "<p>The JavaScript engine converts JavaScript code into machine code that can be executed by the computer, while the JavaScript runtime is the environment in which the code is executed, such as a web browser or <strong>Node.js</strong></p>"
            },
            {
                "name": "How Can You Optimize the Performance of a Javascript Application?",
                "description": "<ul><li>Minimize use of global variables</li><li>Use caching &amp; memoization</li><li>Compressing code</li><li>Use object &amp; array literals instead of constructors</li><li>Avoid unnecessary function calls</li></ul>"
            },
            {
                "name": "How Can You Measure the Performance of a JavaScript Function?",
                "description": "<p>You can use <em>performance.now()</em> to return high-resolution timestamps in milliseconds and thus calculate the time it takes for a function to execute, as shown below.<br><img src='./assets/js/performance.png'></p>"
            },
            {
                "name": "How does a javascript engine work / Works behind the scenes ?",
                "description": "<p>Every browser provides a JavaScript engine that runs the JavaScript code.</p><p><strong>Execution Context</strong> - When the JavaScript engine scans a script file, it makes an environment called the Execution Context that handles the entire transformation and execution of the code. <br>During the context runtime, the parser parses the source code and allocates memory for the variables and functions. The source code is generated and gets executed. <br>There are two types of execution contexts: global and function. The global execution context is created when a JavaScript script first starts to run, and it represents the global scope in JavaScript. A function execution context is created whenever a function is called, representing the function's local scope.</p><p><strong>Phases of the JavaScript Execution Context</strong> -<br>#1. In <strong>Creation Phase</strong>, the JavaScript engine creates the execution context and sets up the script's environment. The <strong>Creation Phase</strong> includes creating the global and function execution contexts, creating the scope chain, and allocating memories for the variables and functions.<br>#2. During the <strong>Execution Phase</strong>, the JavaScript engine executes the code line by line. This includes evaluating and executing statements.</p><br><br><p><strong>Call Stack</strong> - To keep the track of all the contexts, including global and functional, the JavaScript engine uses a <strong>call stack</strong>. A call stack is also known as an 'Execution Context Stack', 'Runtime Stack', or 'Machine Stack'. <br>When the engine first starts executing the script, it creates a global context and pushes it on the stack. Whenever a function is invoked, similarly, the JS engine creates a function stack context for the function and pushes it to the top of the call stack and starts executing it. <br>When execution of the current function is complete, then the JavaScript engine will automatically remove the context from the call stack and it goes back to its parent.</p><p><img src='./assets/js/callstack.png'><br><br>In this example, the JS engine creates a global execution context that enters the creation phase.</p><p>First it allocates memory for <code>funcA</code>, <code>funcB</code>, the <code>getResult</code> function, and the <code>res</code> variable. Then it invokes <code>getResult()</code>, which will be pushed on the call stack.</p><p>Then <code>getResult()</code> will call <code>funcB()</code>. At this point, <code>funcB</code>'s context will be stored on the top of the stack. Then it will start executing and call another function <code>funcA()</code>. Similarly, <code>funcA</code>'s context will be pushed. </p><p>Once execution of each function is done, it will be removed from the call stack.</p>"
            },
            {
                "name": "Difference between TypeScript and JavaScript",
                "description": "<table><tbody><tr><td><strong>TypeScript</strong></td><td><strong>JavaScript</strong></td></tr><tr><td>Superset of JavaScript developed to overcome code complexity for large projects.</td><td>A scripting language that helps create dynamic web page content.</td></tr><tr><td>Errors can be found and corrected during compile time.</td><td>Errors can be found only during run-time as it is an interpreted language.</td></tr><tr><td>Strongly typed, supports both static and dynamic typing.</td><td>Weakly typed, no option for static typing.</td></tr><tr><td>Converted into JavaScript code to be understandable for browsers.</td><td>Can be directly used in browsers.</td></tr><tr><td>Since it is a superset, all the JavaScript libraries, and other JavaScript code works without any changes.</td><td>JS libraries work by default.</td></tr><tr><td>There is support for ES3, ES4, ES5 and ES6.</td><td>No support for compiling additional ES3, ES4, ES5 or ES6 features.</td></tr><tr><td>Supports modules, generics and interfaces to define data.</td><td>No support for modules, generics or interface.</td></tr><tr><td>Functions can have optional parameters.</td><td>Functions cannot have optional parameters.</td></tr><tr><td>Numbers and strings are considered as interfaces.</td><td>Number and string are objects.</td></tr><tr><td>Powerful and intuitive language for large projects.</td><td>Neat and clean, most suitable for simple web applications.</td></tr><tr><td>Community support is still growing.</td><td>Huge community support with lots of documentation and support for solving issues.</td></tr><tr><td>Prototyping is possible</td><td>No support for prototyping.</td></tr><tr><td>Takes time to learn and code, scripting knowledge is a must.</td><td>Can be learned on the go, no prior scripting experience is needed.</td></tr><tr><td>Proper build setup (npm package) is required for static type definitions</td><td>No build setup is required.</td></tr></tbody></table>"
            },
            {
                "name": "What are the benefits of using spread syntax in ES6 and how is it different from rest syntax?",
                "description": "<p>ES6's spread syntax is very useful when coding in a functional paradigm as we can easily create copies of arrays or objects without resorting to <code>Object.create</code>, <code>slice</code>, or a library function. This language feature is used often in Redux and rx.js projects.<br><img src='./assets/js/es6spread.png'></p><p>ES6's rest syntax offers a shorthand for including an arbitrary number of arguments to be passed to a function. It is like an inverse of the spread syntax, taking data and stuffing it into an array rather than unpacking an array of data, and it works in function arguments, as well as in array and object destructuring assignments.<br><img src='./assets/js/es6rest.png'></p>"
            },
            {
                "name": "What are the differences between ES6 class and ES5 function constructors?",
                "description": "<p>ES6 class constructors work quite the same as class constructors in other object-oriented languages. They are used to create new objects.</p><p>ES5 function constructors are also used to create objects. The above example can be modified as following through the use of function constructors.</p><table><thead><tr><th><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ES6 class constructors</strong></th><th><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ES5 function constructors</strong></th></tr></thead><tbody><tr><td>As discussed above ES6 class constructors creates objects by adding function to their prototypes (Blueprint).</td><td>ES5 function constructors also create objects along with inheritance property.&nbsp;</td></tr><tr><td>It ensures that<i> this</i> keyword used by the developer is referring to the object being created by the developer.&nbsp;</td><td>Any function can be used as a function constructor and it primarily focuses on the creation of reusable object creation code.</td></tr><tr><td>Its syntax is similar to object creation in other object-oriented programming languages.</td><td>Its syntax is unique and is not generally found in other object-oriented programming languages.</td></tr><tr><td>This can be said to be a syntax base for constructor functions and instantiate objects using a new operator.</td><td>This also uses a new operator for object creation but focuses on how the objects are being instantiated.</td></tr></tbody></table>"
            },
            {
                "name": "enums in JavaScript and typescript",
                "description": "<p>Enums in Javascript - <br><img src='./assets/js/enumjs.png'></p><p>Enums in Typescript - <br><img src='./assets/js/enumts.png'></p>"
            },
            {
                "name": "What are the actual uses of ES6 WeakMap?",
                "description": "<p><strong>WeakMaps</strong> provide a way to extend objects from the outside without interfering with garbage collection. Whenever you want to extend an object but can't because it is sealed - or from an external source - a WeakMap can be applied.</p><p><strong>WeakMap</strong> is only available for ES6 and above. A WeakMap is a collection of key and value pairs where the key must be an object.<br><img src='./assets/js/weakmap.png'></p><p>The interesting aspect of the WeakMaps is the fact that it holds a weak reference to the key inside the map. A weak reference means that if the object is destroyed, the garbage collector will remove the entire entry from the WeakMap, thus freeing up memory.</p>"
            },
            {
                "name": "Explain the Prototype Design Pattern",
                "description": "<p><em>The Prototype Pattern</em> creates new objects, but rather than creating non-initialized objects it returns objects that are initialized with values it <em>copied</em> from a prototype - or sample - object. The Prototype pattern is also referred to as the Properties pattern.</p><p>An example of where the Prototype pattern is useful is the initialization of business objects with values that match the default values in the database. The prototype object holds the default values that are copied over into a newly created business object.</p><p>Classical languages rarely use the Prototype pattern, but JavaScript being a prototypal language uses this pattern in the construction of new objects and their prototypes.</p>"
            },
            {
                "name": "When should you NOT use arrow functions in ES6 ",
                "description": "<p>Arrow functions should NOT be used:</p><ul><li>When we want function hoisting - as arrow functions are anonymous.</li><li>When we want to use this/arguments in a function - as arrow functions do not have this/arguments of their own, they depend upon their outer context.</li><li>When we want to use named function - as arrow functions are anonymous.</li><li>When we want to use function as a constructor - as arrow functions do not have their own this.</li><li>When we want to add function as a property in object literal and use object in it - as we can not access this (which should be object itself).</li></ul>"
            },
            {
                "name": "Differences between Map and WeakMap",
                "description": "<p>The functional mechanism of Map and WeakMap is same but they have little differences.</p><p>1) A <strong>WeakMap </strong>accepts only objects as keys whereas a <strong>Map</strong>,in addition to objects, accepts primitive datatype such as strings, numbers etc.</p><p>2) <strong>WeakMap </strong>objects doesn't avert garbage collection if there are no references to the object which is acting like a key. Therefore there is no method to retrieve keys in <strong>WeakMap</strong>, whereas in <strong>Map </strong>there are methods such as Map.prototype.keys() to get the keys.</p><p>3) There is no size property exists in <strong>WeakMap</strong>.</p>"
            },
            {
                "name": "What does the tsconfig option lib do",
                "description": "<p>With <code>--lib</code> you can specify a list of <strong>built-in API</strong> declaration groups that you can choose to include in your project.</p><p>For instance, if you expect your runtime to have support for <code>Map, Set, and Promise</code> (e.g. most evergreen browsers today), just include: <strong>--lib es2015.collection, es2015.promise</strong></p><p>Similarly, you can exclude declartions you do not want to include in your project. For example, DOM, if you are working on a node project using <code>--lib es5, es6</code></p>"
            },
            {
                "name": "How do you add an element at the begining of an array? How do you add one at the end?",
                "description": "<p><img src='./assets/jsCode/addelement.png'></p>"
            },
            {
                "name": "How do you clone an object?",
                "description": "<p><strong><code>var obj = {a: 1 ,b: 2}<br>var objclone = Object.assign({},obj);</code></strong></p><p>Now the value of <code>objclone</code> is <code>{a: 1 ,b: 2}</code> but points to a different object than <code>obj</code>.</p><p>Note the potential pitfall, though: <code>Object.assign()</code> will just do a shallow copy, <em>not</em> a deep copy.  This means that nested objects aren’t copied.  They still refer to the same nested objects as the original:<br><img src='./assets/js/objclone.png'></p>"
            },
            {
                "name": "What advantages are using arrow functions?",
                "description": "<ul><li><em>Compactness</em>: Arrow functions are easier to read and write.</li><li><em>Clarity</em>: When almost everything is an arrow function, any regular function immediately sticks out for defining the scope. A developer can always look up the next-higher function statement to see what this <code>this </code>object is.</li><li><em>Scope safety</em>: Until arrow functions, every new function defined its own value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an \"object method\", etc.). An arrow function does not create its own this, the <code>this </code>value of the enclosing execution context is used.</li></ul>"
            },
            {
                "name": "What does the term Transpiling stand for?",
                "description": "<p>There's no way to polyfill new syntax that has been added to the language. So the better option is to use a tool that converts your newer code into older code equivalents. This process is commonly called&nbsp;<strong>transpiling</strong>, a term for&nbsp;<em>transforming + compiling</em>.</p><p>Typically you insert the&nbsp;<em>transpiler</em>&nbsp;into your build process, similar to your code linter or your minifier. There are quite a few great transpilers for you to choose from:</p><ul><li><p><strong>Babel</strong>: Transpiles ES6+ into ES5</p></li><li><p><strong>Traceur</strong>: Transpiles ES6, ES7, and beyond into ES5</p></li></ul>"
            },
            {
                "name": "Difference between Relative path and absolute path",
                "description": "<b>A relative path describes the location of a file relative to the current (working) directory*.</b>"
            },
            {
                "name": "Difference between Function, Method and Constructor calls in JavaScript",
                "description": "<p>In JavaScript, a <strong>function</strong> is a piece of reusable code that has the potential to take input values, perhaps do something with them, and potentially return a value.</p><p>Now, if the same function is called with the new keyword preceding it, it is known as <strong>constructor</strong> since it creates and returns a new object. (The collection of all objects that were generated using the same function constructor is then known as a class)</p><p>Likewise suppose a JavaScript Object contains as property in the form of function definition then it becomes a <strong>method</strong></p>"
            },
            {
                "name": "What are Service Workers and when can you use them?",
                "description": "<p>It’s a technology that allows your web application to use cached resources first, and provide default experience offline, before getting more data from the network later. This principle is commonly known as Offline First.</p><p>Service Workers actively use promises. A Service Worker has to be installed,activated and then it can react on fetch, push and sync events.</p><p>As of 2017, Service Workers are not supported in IE and Safari.</p>"
            }
        ]
    },
    {
        "folder": "JavaScript Coding",
        "title": "JavaScript Coding",
        "url": "/folder/JavaScript Coding",
        "icon": "logo-javascript",
        "question": [
            {
                "name": "Output - What is the result of X, Y, Z / A, B C object?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/xyzObjectProblem.png'></p><p><strong>Solution - </strong><br><img src='./assets/jsCode/xyzObject.png'></p><p>Adding objects as properties of another object should be done carefully.</p><p>Writing x[y]={name:”Vivek”}, is same as writing x[‘object Object’]={name:”Vivek”},</p><p>While setting a property of an object, javascript coerces the parameter into a string.</p><p>Therefore, since y is an object, it will be converted to ‘object Object’.</p><p>Both x[y] and x[z] are referencing the same property.</p>"
            },
            {
                "name": "Output - Console results of string and numbers?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/stringNumberConsole.png'></p><p><strong>Solution - </strong><br><img src='./assets/jsCode/stringNumberConsoleResult.png'></p><br><br><p><strong>Problem</strong><br><img src='./assets/jsCode/stringNumberConsole1.png'></p><p><strong>Solution - </strong><br><img src='./assets/jsCode/stringNumberConsoleResult1.png'></p>"
            },
            {
                "name": "Output - Equality Coercion",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/equalityProblem.png'></p><p><strong>Solution - </strong>Output in the following order due to equality coercion:<br><img src='./assets/jsCode/equalitySolution.png'></p>"
            },
            {
                "name": "Output - Hoisting a variable and random function",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/hoistingProblem.png'></p><p><strong>Solution - </strong>Output is <strong>NaN</strong><p>random() function has functional scope, since x is declared and hoisted in the functional scope.</p><p>Rewriting the random function will give a better idea about the output:<br><img src='./assets/jsCode/hoistingSolution.png'></p>"
            },
            {
                "name": "Output - What is the issue with the below code and how it can be fixed? (console sort)",
                "description": "<p><strong>Problem</strong><br><strong>const array=[1,2,15,4,30,7,45];<br>console.log(array.sort());</strong></p><p>The sort() method is used to sort the elements of an array. But the output of the above is not what expected out of sort() function.</p><p>This is because the default sort is according to tring Unicode points. The fix to it is by adding an anonymous function and tell to sort according to ascending or descending order. </p><p><img src='./assets/jsCode/sort.png'></p><p><strong>Sorting Programatically</strong><br><img src='./assets/jsCode/sortprogram.png'></p>"
            },
            {
                "name": "Output - Recursion example Flatten array",
                "description": "<p><strong>Algorithm steps:</strong></p><ul><li>First, we iterate through the given array.</li><li>Then check each element:<ul><li>if it is not an array then push the elements in an updated array.</li><li>if it is an array then again call the same function <code>flatten()</code> i.e. recursion. Then we will combine our updated array and return values of <code>flatten()</code> using the spread operator in ES6. This will keep flatting the updated array.</li></ul></li></ul><p><strong>Solution 1</strong><br><img src='./assets/jsCode/flattenforloop.png'></p><p><strong>Solution 2</strong><br><img src='./assets/jsCode/flatten.png'></p>"
            },
            {
                "name": "Output - Recursion example 'display countdown numbers'",
                "description": "<p><strong>Algorithm steps:</strong></p><ul><li>First, we iterate through the given number.</li><li>Then we decrease the number by 1 and store that value in a variable</li><li>Then we evaluate the new stored value against the condition greater than 0, if it is then we again trigger the countdown function.</li></ul><p><img src='./assets/jsCode/recursioncountdown.png'></p>"
            },
            {
                "name": "Output - Find Factorial",
                "description": "<p>The factorial function says to multiply all the whole numbers from the chosen number down to one. In more mathematical terms, the factorial of a number <strong>(n!) is equal to n(n-1)</strong>.</p><p><img src='./assets/jsCode/factorial.png'></p>"
            },
            {
                "name": "Output - Find out prime factors of the number",
                "description": "<p><strong>Solution 1</strong><br><img src='./assets/jsCode/factors1.png'></p><p><strong>Solution 2</strong><br><img src='./assets/jsCode/factors.png'></p>"
            },
            {
                "name": "Output - Perfect number using Javascript",
                "description": "<p>In number theory, a perfect number is a positive integer that is equal to the sum of its proper positive divisors, that is, the sum of its positive divisors excluding the number itself<br><i>Example</i> : The first perfect number is 6, because 1, 2, and 3 are its proper positive divisors, and 1 + 2 + 3 = 6. Equivalently, the number 6 is equal to half the sum of all its positive divisors: ( 1 + 2 + 3 + 6 ) / 2 = 6. The next perfect number is 28 = 1 + 2 + 4 + 7 + 14.</p><p><img src='./assets/jsCode/perfectnumber.png'></p>"
            },
            {
                "name": "Output - digits from a string with numbers",
                "description": "<p><strong>var strNum = \"only123!\"; </strong></p><p>To fetch the digits from the above string, the following RegExp is used: <img src='./assets/jsCode/regexp.png'></p><p><img src='./assets/jsCode/findnumber.png'></p>"
            },
            {
                "name": "Output - non-digit characters from a string",
                "description": "<p><strong>var strNum = \"DEMO989#@#@\";</strong></p><p>The following RegExp is used to get a non-digits:&nbsp;<img src='./assets/jsCode/regexp1.png'></p><p><img src='./assets/jsCode/findalphabets.png'></p>"
            },
            {
                "name": "Output - How to shuffle an array in JavaScript?",
                "description": " <ul> <li><img src='./assets/jsCode/shuffle.png'></li><li><strong>[3,5,1,95,8,23].sort( ()=>Math.random()-0.5)</strong></li><li><img src='./assets/jsCode/shuffle1.png'></li></ul>"
            },
            {
                "name": "Output - What should be the value of “i” so that we get the mentioned result?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/printi.png'></p><p><strong>Answer</strong></p><p>Everything is ok, but the last one produce NaN(Not a Number) because “<em>0 divide by 0 will produce infinity”</em></p><p>So, we need a number which is like zero but gives 1 if we divide it by itself. Fortunately there is such a number in JavaScript. The number is the minimum value that is allowed in JavaScript and is represented by <strong>Number.MIN_VALUE</strong></p><p><img src='./assets/jsCode/printians.png'></p>"
            },
            {
                "name": "Output - What are the different way to access “this” inside an inner function for below code?",
                "description": "<p><img src='./assets/jsCode/problem1.png'></p><p><strong>Solution 1</strong> - Use call method to use the outer “this” inside the innerFunc().</p><p><img src='./assets/jsCode/solution1.png'></p><p><strong>Solution 2</strong> - Use bind method to use the outer “this” inside the innerFunc().</p><p><img src='./assets/jsCode/solution2.png'></p><p><strong>Solution 3</strong> - Use a “that” variable in&nbsp;cleanRoom() for accessing “this” inside innerFunc(). Basically “that” is nothing but the outer “this”.</p><p><img src='./assets/jsCode/solution.png'></p><p><strong>Solution 4</strong> - Use arrow function in the innerFunc(). Arrow functions have special meaning for “this” and it is that, it takes the value of “this” from the enclosing scope and is very useful in this case.</p><p><img src='./assets/jsCode/solution3.png'></p>"
            },
            {
                "name": "Output - What is the output of the below code and why?(identity)",
                "description": "<p><img src='./assets/jsCode/problem2.png'></p><p><strong>Problem</strong>What is the issue with the code and how can it be fixed?</p><p>The output logged will be:</p><strong><code>undefined<br>Johnny Deep</code></strong><p>The first console.log prints <strong>undefined</strong> because heroIdentity()is been invoked in the global context (i.e., the window object) where the <strong>_name</strong> property doesn’t exists.</p><p>The other way to fix it is by binding, it to hero object by using bind.</p><strong><code>var heroIdentity = hero.getIdentity.bind(hero);</code></strong>"
            },
            {
                "name": "Output - What is the output of the below code and why? (method)",
                "description": "<p><img src='./assets/jsCode/method.png'></p><p>The output logged will be:</p><strong><code>10<br>2</code></strong><p>When inside the method, fn() is called the “this” of the function fn is at window level. So, “this.length” will produce <strong>10</strong>.<br>Now, when <code>arguments[0]()&nbsp;</code>is called, then <code>arguments[0]()&nbsp;</code> is equivalent to “fn” and function fn is called. But “this” now is the arguments array, which is of length 2 because it contains two arguments (fn, 1). So, “this.length” will produce <strong>2</strong>.</p>"
            },
            {
                "name": "Output - What is the output of the below code and why? (console proto)",
                "description": "<p><strong>Problem</strong></p><strong>console.log(('hello').__proto__.__proto__.__proto__);</strong></p><br><p><strong>Answer</strong> - The output logged will be: <code>null</code></p><p>The reason is for prototype chaining. The __proto__ of ‘hello’ is the global String.</p><strong>console.log(('hello').__proto__);</strong><p><img src='./assets/jsCode/proto1.png'></p><p>Then the __proto__ of it is the global Object.</p><strong>console.log(('hello').__proto__.__proto__);</strong><p><img src='./assets/jsCode/proto2.png'></p><p>Now, the Object is the final thing from which everything in JavaScript is created and it points to <strong>null</strong>.</p>"
            },
            {
                "name": "Output - Find the missing number in the array",
                "description": "<p><img src='./assets/jsCode/missingNumber.png'></p>"
            },
            {
                "name": "Output - Find the duplicate values in an array",
                "description": "<ul> <li><strong>By simply Traversing the Array</strong> <br><img src='./assets/jsCode/duplicateValue.png'></li><li><strong>Using filter + indexOf</strong> <br><img src='./assets/jsCode/duplicateValue1.png'></li><li><strong>Using includes</strong> <br><img src='./assets/jsCode/duplicateValue2.png'></li><li><strong>Using ES6 \"Set\"</strong> <br><img src='./assets/jsCode/duplicateValue3.png'></li></ul>"
            },
            {
                "name": "Output - Remove duplicates from an array",
                "description": "<ul> <li><strong>Using empty array / helper array</strong> <br><img src='./assets/jsCode/duplicate.png'></li><li><strong>Using Object</strong> <br><img src='./assets/jsCode/duplicate1.png'></li><li><strong>Using filter + indexOf</strong> <br><img src='./assets/jsCode/duplicate2.png'></li><li><strong>Using ES6 \"Set\"</strong> <br><strong><code>var temp=[...new Set(arr)]</code></strong></li><li><strong>Using ES6 \"Set\" with from()</strong> <br><strong><code>var temp.from(new Set(arr))</code></strong><br><strong>Here, the <code>from()</code> method returns an Array object from any object which has a capability of defining length property or any iterable object.</strong></p></li></ul>"
            },
            {
                "name": "Output - Reverse each word in the sentence",
                "description": "<p><img src='./assets/jsCode/reverse2.png'></p><p><img src='./assets/jsCode/reverse.png'></p><p><img src='./assets/jsCode/reverse1.png'></p><p>Reversing word greater than 5 letters <br><img src='./assets/jsCode/reverse3.png'></p><p><img src='./assets/jsCode/reverseString.png'></p><p>Here, <strong>The <code>split()</code> method splits a string into an array of substrings, and returns the new array. If an empty string (\"\") is used as the separator, the string is split between each character, where as the <code>reverse()</code> method reverses the order of the elements in an array, and the <code>join()</code> method returns an array as a string.</strong></p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop",
                "description": "<p><code>// setTimeout inside a For loop<br><br>for(var i = 0;i &lt; 5; i++){<br>&nbsp;&nbsp;&nbsp;setTimeout(function(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('count ', i);<br>&nbsp;&nbsp;&nbsp;}, 3000);<br>}</code></p><p>//Console<br><br><code>count  5<br>count  5<br>count  5<br>count  5<br>count  5</code></p><p>The <em>setTimeout</em> function callback isn’t triggered until the for loop execution has completed. When the for loop has finished executing the value of i is 5. Now when the <em>setTimeout</em> call begins to execute it uses the last set value of i which is 5. Hence 5 is printed in all the <em>setTimeout</em> callbacks.</p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using IIFE",
                "description": "<p>You can use IIFE to create a new scope for each setTimeout callback without polluting the global scope. Simply wrap up the setTimeout code inside a IIFE.</p><br><img src='./assets/jsCode/settimeoutforloop.png'>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using let Keyword",
                "description": "<p>The let keyword creates a separate scope for each iteration making it possible to print the consecutive variable value.</p><br><img src='./assets/jsCode/settimeoutforloop1.png'>"
            },
            {
                "name": "Output - indexOf",
                "description": "<p><img src='./assets/jsCode/problem3.png'></p><p><strong>Answer</strong>: The first answer is 1 because 2 is at position 1, second and third is -1 because the index does not use for object and arrays. If you want to find and element in array use map and then check the index. The last line answer is 4 because the string is consider as an array of char in javascript.</p>"
            },
            {
                "name": "Output - filter.call()",
                "description": "<p><img src='./assets/jsCode/problem4.png'></p><p>Answer: This will start reading after 5. The beauty of this question is how it is written. Sometimes look like a puzzle. It will return set of array <strong><em>[“W”, “o”, “r”, “l”, “d”]</em></strong></p>"
            },
            {
                "name": "Output - printMessage",
                "description": "<p><img src='./assets/jsCode/problem5.png'></p><p>Answer: Here, We are creating two objects printVal1 and printVal2. printVal1.printMessage() clearly logs In printVal1 …because message is initialize as “In printVal1 …”. In the next line assigning method printMessage to printVal2 Object. In printVal2 message is initialize as “In printVal2 …”. So code block will log: <strong>In printVal1 … and In printVal2 …</strong></p>"
            },
            {
                "name": "Output - return statement",
                "description": "<p><img src='./assets/jsCode/problem6.png'></p><p>Answer - when you see this example closely there is return and rest of the code is written after that. So JavaScript just return from second line of code. Code after line 2 will not be executed.</p>"
            },
            {
                "name": "Output - ===",
                "description": "<p><strong>Problem</strong><br><strong>console.log(0.1+0.2===0.3)</strong></p><p>Answer: when adding 0.1 and 0.2 in javascript it will not be 0.3. It will be more than a fraction value of 0.3.<br> Only this will work <strong>(0.1+0.2).toFixed(1)==0.3</strong></p><br><br><p><strong>Problem</strong><br><img src='./assets/jsCode/equalityProblem1.png'></p><p><strong>Answer</strong> The triple-equal operator <code>===</code> behaves like any traditional equality operator would: evaluates to true if the two expressions on either of its sides have the same type and the same value. The double-equal operator, however, tries to coerce the values before comparing them. It is therefore generally good practice to use the <code>===</code> rather than <code>==</code>.  The same holds true for <code>!==</code> vs <code>!=</code>.</p>"
            },
            {
                "name": "Output - Fibonacci series",
                "description": "<p>Fibonacci series is a series that generates subsequent series of numbers by the addition of the two previous numbers. ... The first two terms of the Fibonacci series are zero and one, respectively. And the next terms are the addition of the two previous terms.</p><p><img src='./assets/jsCode/fibonacci.png'></p>"
            },
            {
                "name": "Output - Swap number without temp",
                "description": "<p><img src='./assets/jsCode/swaping.png'></p>"
            },
            {
                "name": "Output - Sum of two / sumFinder",
                "description": "<p><strong>Problem</strong> - From a unsorted array, check whether there are any two numbers that will sum up to a given number?</p><p><strong>Answer</strong><br><img src='./assets/jsCode/sumoftwo.png'></p>"
            },
            {
                "name": "Output - Sum of two largest numbers in the array",
                "description": "<p><img src='./assets/jsCode/sumoftwo1.png'></p>"
            },
            {
                "name": "Output - delete operator with Emp Object prototype",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete1.png'></p><p><p><strong>Answer</strong> - Above code will output <strong>xyz</strong> as output. Here <strong>emp1</strong> object got company as prototype property. <strong>delete</strong> operator doesn't delete prototype property.</p><p><strong>emp1</strong> object doesn't have <strong>company</strong> as its own property. You can test it like:</p><p><img src='./assets/jsCode/delete2.png'></p><p>However, we can delete company property directly from <strong>Employee</strong> object using <strong>delete Employee.company</strong> or we can also delete from <strong>emp1</strong> object using <strong>__proto__</strong> property <strong> delete emp1.__proto__.company</strong>.</p>"
            },
            {
                "name": "How to merge two sorted Arrays into a Sorted Array?",
                "description": "<p><img src='./assets/jsCode/merge-two-sorted-array-algorithm.png'></p><p><img src='./assets/jsCode/merge-two-sorted-array-algorithm1.png'></p>"
            },
            {
                "name": "Output - let and var inside setTimeout",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/letvaroutput.png'></p><br><p><strong>Answer</strong> - Outputs 2 and 12. Since, even though let variables are not hoisted, due to the async nature of javascript, the complete function code runs before the setTimeout function. Therefore, it has access to both x and y.</p>"
            },
            {
                "name": "Output - In what order will the numbers 1-4 be logged to the console",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/order.png'></p><br><p><strong>Answer</strong> - 2<br>4<br>3<br>1 // After two seconds</p><p>Even though the second timeout function has a waiting time of zero seconds, the javascript engine always evaluates the setTimeout function using the Web API, and therefore, the complete function executes before the setTimeout function can execute.</p>"
            },
            {
                "name": "Output - hero / getPower / powerlevel",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/powerlevel.png'></p><br><p><strong>Answer</strong> - undefined<br>42</p><p>Reason - The first output is <strong>undefined </strong>since when the function is invoked, it is invoked referencing the global object:</p><p><code>window.getPower() = getPower();</code></p>"
            },
            {
                "name": "Write the code to find the vowels",
                "description": "<p><img src='./assets/jsCode/vowels.png'></p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using const variable",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/const.png'></p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/const1.png'></p>"
            },
            {
                "name": "Output - Given two strings, return true if they are anagrams of one another",
                "description": "<p><strong>Problem</strong> - For example: Mary is an anagram of Army</p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/anagram.png'></p>"
            },
            {
                "name": "Output - typeof F()",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/typeoff.png'></p><br><p><strong>Answer</strong> - The output would be 1undefined. The if condition statement evaluates using eval, so eval(function f(){}) returns function f(){} (which is true). Therefore, inside the if statement, executing typeof f returns undefined because the if statement code executes at run time, and the statement inside the if condition is evaluated during run time.</p>"
            },
            {
                "name": "Output - delete operator",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete3.png'></p><br><p><strong>Answer</strong> - The output would be 0. The delete operator is used to delete properties from an object. Here x is not an object but a local variable. delete operators don’t affect local variables.</p>"
            },
            {
                "name": "Output - delete operator with x object - foo bar",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete.png'></p><br><p><strong>Answer</strong> - The output would be undefined. The delete operator is used to delete the property of an object. Here, x is an object which has the property foo, and as it is a self-invoking function, we will delete the foo property from object x. After doing so, when we try to reference a deleted property foo, the result is undefined.</p>"
            },
            {
                "name": "Output - named function expression - foo bar typeof",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/namedexpression.png'></p><br><p><strong>Answer</strong> - The output would be Reference Error. A function definition can have only one reference variable as its function name.</p>"
            },
            {
                "name": "Write a function that would allow you to do this? addSix / createBase / closures",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/addsix.png'></p><br><p><strong>Answer</strong> - You can create a closure to keep the value passed to the function createBase even after the inner function is returned.<br><img src='./assets/jsCode/addsixfunc.png'></p>"
            },
            {
                "name": "FizzBuzz Challenge",
                "description": "<p><strong>Problem</strong>Create a for loop that iterates up to <code>100</code> while outputting <strong>\"fizz\"</strong> at multiples of <code>3</code>, <strong>\"buzz\"</strong> at multiples of <code>5</code> and <strong>\"fizzbuzz\"</strong> at multiples of <code>3</code> and <code>5</code>.</p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/fizzbuzz.png'></p>"
            },
            {
                "name": "How would you use a closure to create a private counter?",
                "description": "<p>You can create a function within an outer function (a closure) that allows you to update a private variable but the variable wouldn't be accessible from outside the function without the use of a helper function.<br><img src='./assets/jsCode/closureconter.png'></p>"
            },
            {
                "name": "Output - Value of b in expression var a=b=5",
                "description": "<p>The code above will output 5 even though it seems as if the variable was declared within a function and can't be accessed outside of it. This is because <br><strong><code>var a = b = 5</code></strong><br> is interpreted the following way: <br><strong><code>var a = b;<br>b = 5;</code></strong></p><p>But <code>b</code> is not declared anywhere in the function with var so it is set equal to <strong>5</strong> in the <strong>global scope</strong>.</p><br><br><p><strong>Another Case Problem</strong><br><img src='./assets/jsCode/aandb.png'></p><br><p><strong>Answer</strong> - <br><strong>a defined? false <br>b defined? true</strong> - since the statement <code>var a = b = 3;</code> is shorthand for the statements <code>b = 3;</code> and <code>var a = b;</code>, <code>b</code> ends up being a global variable (since it is not preceded by the <code>var</code> keyword) and is therefore still in scope even outside of the enclosing function.</p>"
            },
            {
                "name": "Output - 3>2>1 - returns false while 3>2>0 return true",
                "description": "<p>Let's pick this apart. First, it evaluates <strong>+(3 &gt; 2)</strong>. Yes, three is greater than two. Therefore, you now have expression like this <strong> +(true) &gt; 1</strong></p><p><strong>true</strong> is coerced into a number. That number happens to be <strong>1</strong>. <strong>1 &gt; 1</strong> is obviously false. Therefore, the result is: <strong>false</strong></p><br><br><p>Whereas in other case expression 1 > 0, and hence the result is true</p>"
            },
            {
                "name": "Output - 1<2<3 returns true",
                "description": "<p>Let's pick this apart. First, it evaluates <strong>+(1 &lt; 2)</strong>. Yes, one is less than two. Therefore, you now have expression like this <strong> +(true) &lt; 3</strong></p><p><strong>true</strong> is coerced into a number. That number happens to be <strong>1</strong>. <strong>1 &lt; 3</strong> is obviously true. Therefore, the result is: <strong>true</strong></p>"
            },
            {
                "name": "Output - 1<3>2 and 1>3<2",
                "description": "Result - false / true"
            },
            {
                "name": "Output - console 'this foo bar self'",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/outputfoobar.png'></p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/outputfoobar1.png'><br>In the outer function, both <code>this</code> and <code>self</code> refer to <code>myObject</code> and therefore both can properly reference and access <code>foo</code>.<br>In the inner function, though, <code>this</code> no longer refers to <code>myObject</code>.  As a result, <code>this.foo</code> is undefined in the inner function, whereas the reference to the local variable <code>self</code> remains in scope and is accessible there.</p>"
            },
            {
                "name": "Output - Palindrome",
                "description": "<p><strong>Answer</strong><br><img src='./assets/jsCode/palindrome.png'><br><br><strong>Example</strong><br><img src='./assets/jsCode/palindrome1.png'></p>"
            },
            {
                "name": "Output - object property",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/objref.png'></p><br><p><strong>Answer</strong> - When setting an object property, JavaScript will implicitly <strong>stringify</strong> the parameter value. In this case, since <code>b</code> and <code>c</code> are both objects, they will <em>both</em> be converted to <code>\"[object Object]\"</code>. As a result, <code>a[b]</code> and<code>a[c]</code> are both equivalent to <code>a[\"[object Object]\"]</code> and can be used interchangeably.  Therefore, setting or referencing <code>a[c]</code> is precisely the same as setting or referencing <code>a[b]</code>.</p>"
            },
            {
                "name": "Output - Testing knowledge on \"this\"",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/this.png'></p><br><p><strong>Answer</strong> - <strong><code><br>10<br>2</code></strong>  When setting an object property, JavaScript will implicitly <strong>stringify</strong></p><p>In the first place, as <code>fn</code> is passed as a parameter to the function <code>method</code>, the scope (<code>this</code>) of the function <code>fn</code> is <code>window</code>.  <code>var length = 10;</code> is declared at the <code>window</code> level. It also can be accessed as <code>window.length</code> or <code>length</code> or <code>this.length</code> (when <code>this === window</code>.)</p><p>Now, we know that we can access any number of arguments in a JavaScript function using the <code>arguments[]</code> array.</p><p>Hence <code>arguments[0]()</code> is nothing but calling <code>fn()</code>. Inside <code>fn</code> now, the scope of this function becomes the <code>arguments</code> array, and logging the length of <code>arguments[]</code> will return <code>2</code>.</p>"
            },
            {
                "name": "Output - try catch",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/varhoisting.png'></p><br><p><strong>Answer</strong> - <strong><code><br>1<br>undefined<br>2</code></strong><br><br><code>var</code> statements are hoisted (without their value initialization) to the top of the global or function scope it belongs to, even when it’s inside a <code>with</code> or <code>catch</code> block. However, the error’s identifier is only visible inside the <code>catch</code> block. It is equivalent to:<br><img src='./assets/jsCode/varhoisting1.png'></p>"
            },
            {
                "name": "Output - not hoisted / girl / 21 / 20",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/hoisting.png'></p><br><p><strong>Answer</strong> - Neither 21, nor 20, the result is <code>undefined</code>. It’s because JavaScript initialization is not hoisted.</p><p>(Why doesn’t it show the global value of 21? The reason is that when the function is executed, it checks that there’s a local <code>x</code> variable present but doesn’t yet declare it, so it won’t look for global one.)</p>"
            },
            {
                "name": "Output - closures / outer / inner",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/closure.png'></p><br><p><strong>Answer</strong> - Output to the console will be “3”.</p><p>There are three closures in the example, each with it’s own <code>var b</code> declaration. When a variable is invoked closures will be checked in order from local to global until an instance is found. Since the <code>inner</code> closure has a <code>b</code> variable of its own, that is what will be output.</p>"
            },
            {
                "name": "Output - Check if a given string is a isomorphic",
                "description": "<p>For two strings to be isomorphic, all occurrences of a character in string A can be replaced with another character to get string B. There must be one-to-one mapping for every char of string A to every char of string B.<br><img src='./assets/jsCode/isomorphic.png'></p><ul><li><strong>Step 1</strong> - Check if the same lenght. If not, they cannot be isomorphic</li><li><strong>Step 2</strong> - If the letter does not exist, create a map and map it to the value of the second letter</li><li><strong>Step 3</strong> - Eles if letterA already exists in the map, but it does not map to letterB, that means that A is mapping to more than one letter.</li><li><strong>Step 4</strong> - If after iterating through and conditions are satisfied, return true. They are isomorphic</li></ul>"
            },
            {
                "name": "Output - this in global/window object",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/closure1.png'></p><br><p><strong>Answer</strong> - <br><strong><code>global/window object<br>object \"b\"<br>global/window object</code></strong></p><p><br>Since we are using the arrow function inside <strong>func2, this </strong>keyword refers to the global object.<br><br><strong>Code 3 </strong>- Outputs in the following order:</p>"
            },
            {
                "name": "Output - thin in IIFE",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/this1.png'></p><br><p><strong>Answer</strong> - <br><strong><code>\"Vivek\"<br>blank_value/undefined<br>\"Vivek\"</code></strong> - Only in the IIFE inside the function <strong>f</strong>, <strong>this </strong>keyword refers to the global/window object.</p>"
            },
            {
                "name": "Write the code for dynamically inserting new components / append nodes to the list.",
                "description": "<p><strong>Answer</strong><br><img src='./assets/js/append.png'></p>"
            },
            {
                "name": "Output of the following code? bar boolean",
                "description": "<p><strong>Problem</strong><br><img src ='./assets/jsCode/bartrue.png'></p><p><strong>Answer<br>1<br>truexyz<br>2<br>1</strong></p>"
            }
        ]
    },
    {
        "folder": "React",
        "title": "React",
        "url": "/folder/React",
        "icon": "logo-react",
        "question": [
            {
                "name": "How does React work?",
                "description": "<p>The React framework is an open-source JavaScript framework and library developed by Facebook.</p><p>React's core purpose is to build UI components; it is often referred to as just the “V” (View) in an “MVC” architecture.</p><p>React creates a virtual DOM. When state changes in a component it firstly  identifies what has changed in the virtual DOM. The second step is reconciliation, where it updates the DOM with the results of diff.</p>"
            },
            {
                "name": "What is Context API in ReactJS?",
                "description": "<p>Context provides a way to pass data through the component tree without having to pass props down manually at every level. Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language. Using context, helps us avoid the problem of props drilling.<br><img src='./assets/react/context1.png'></p>"
            },
            {
                "name": "What is JSX?",
                "description": "<p>JavaScript XML, or JSX, <b>is a XML/HTML template syntax used by React</b>. It extends ECMAScript, which allows XML/HTML-like text to coincide with JavaScript and React code. It allows us to put HTML into JavaScript.</p><p>It's faster than normal JavaScript, which makes it easier to create templates, and uses components. It comes with the full power of JavaScript, and you can use it with React to describe what the user interface should look like.</p>"
            },
            {
                "name": "What are the advantages of ReactJS?",
                "description": "<ol><li>Increases the application's performance with Virtual DOM/li><li>JSX makes code is easy to read and write</li><li>It renders both on client and server side</li><li>Easy to integrate with other frameworks (Angular, BackboneJS) since it is only a view library</li><li>Easy to write UI Test cases and integration with tools such as JEST.</li></ol>"
            },
            {
                "name": "What are the major features of ReactJS?",
                "description": "<ul><li>It uses <strong>VirtualDOM</strong> instead RealDOM considering that RealDOM manipulations are expensive.</li><li>Supports <strong>server-side rendering</strong></li><li>Follows <strong>Unidirectional</strong> data flow or data binding</li><li>Uses <strong>reusable/composable</strong>UI components to develop the viewn></li></ul>"
            },
            {
                "name": "What is state?",
                "description": "<p><strong>State</strong> of a component is an object that holds some information that may change over the lifetime of the component. As state stores a component’s dynamic data and determines the component’s behaviour, it enables a component to keep track of changing information in between renders and for it to be dynamic and interactive.</p>"
            },
            {
                "name": "List all Hooks (state, effect, context, reducer, callback, memo, refs)",
                "description": "<p>The main advantage of react hooks is the re-usability of stateful logic that is common across multiple components without the burden of higher order components or render props</p><p>Hooks allow to easily manipulate the state of our functional component without needing to convert them into class components.</p><p>Hooks don’t work inside classes (because they let you use React without classes). By using them, we can totally avoid using lifecycle methods, such as <code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>. Instead, we will use built-in hooks like <code>useEffect</code> .</p><ul> <li><strong>useState</strong> - The <code>useState</code> function is a built in hook that can be imported from the react package. It allows you to add state to your functional components. Using the <code>useState</code> hook inside a function component, you can create a piece of state without switching to class components. Here you pass the initial state to this function and it returns a variable with the current state value (not necessarily the initial state) and another function to update this value. <p><strong><code>setState()</code></strong> enqueues changes to the component state and tells React that this component and its children need to be re-rendered with the updated state. This is the primary method you use to update the user interface in response to event handlers and server responses.</p></li><li><strong>useEffect</strong> - It's the alternative for the class component lifecycle methods <code>componentDidMount, componentWillUnmount, componentDidUpdate,</code> etc. You can also use it to create a side effect when dependencies change, i.e. 'If some variable changes, do this'</li><li><strong>useContext</strong> - This hook is used to create common data that can be accessed throughout the component hierarchy without passing the props down manually to each level. Context defined will be available to all the child components without involving “props”.</li><li><strong>useLayoutEffect</strong> - useLayoutEffect. The signature is identical to useEffect , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously, before the browser has a chance to paint.</li><li><strong>useReducer</strong> - useReducer may be used as an alternative to useState. It's ideal for complex state logic where there's a dependency on previous state values or a lot of state sub-values. <p>As opposed to calling <code>useState</code>, call <code>useReducer</code> with a <code>reducer</code> and <code>initialState</code>, as shown below. The <code>useReducer</code> call returns the state property and a <code>dispatch</code> function.</p></li><li><strong>useCallback</strong> - The useCallback hook is used when you have a component in which the child is rerendering again and again without need. Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed</li><li><strong>useMemo</strong> - useMemo will call the function and return its return value. Then, every time you call useMemo again, it will first check if any dependencies have changed. If not, it will return the cached return value, not calling the function. If they have changed, useMemo will call the provided function again and repeat the process.<p><img src='./assets/react/reactmemo.png'></p></li><li><strong>useRef</strong> - Refs allow you to get direct access to a DOM Node of an element in a component. In order to access them you need to add a ref attribute to your element in the component whose value is a callback function which will receive the underlying DOM Node of the component as its first argument. Here returned reference in the DOM Node can be only accessed with a special property name called current.<p>There are 2 rules to remember about references:</p><ol><li>The value of the reference is <em>persisted</em> (stays the same) between component re-renderings;</li><li>Updating a reference <em>doesn’t trigger a component re-rendering</em>. Hence it is always suggested that a useRef should be used only when you have to access the values and not updating it rerendering it.</li></ol><p><img src='./assets/react/useref.png'></p></li></ul>"
            },
            {
                "name": "What are the rules needs to follow for hooks?",
                "description": "<p>You need to follow two rules in order to use hooks,</p><ol><li>Call Hooks only at the top level of your react functions. i.e, You shouldn’t call Hooks inside loops, conditions, or nested functions. This will ensure that Hooks are called in the same order each time a component renders and it preserves the state of Hooks between multiple useState and useEffect calls.</li><li>Call Hooks from React Functions only. i.e, You shouldn’t call Hooks from regular JavaScript functions.</li></ol>"
            },
            {
                "name": "How to access DOM elements in React?",
                "description": "<p>useRef() hook is to access DOM elements. This is performed in 3 steps:</p><ol><li>Define the reference to access the element const elementRef = useRef();</li><li>Assign the reference to ref attribute of the element: <code><div ref={elementRef}></div></code></li><li>After mounting, elementRef.current points to the DOM element.</li></ol><p><img src='./assets/react/useref1.png'></p>"
            },
            {
                "name": "What is the use of react-dom package?",
                "description": "<p>The <code>react-dom</code> package provides <em>DOM-specific methods</em> that can be used at the top level of your app. Most of the components are not required to use this module. Some of the methods of this package are:</p><ol><li><code>render()</code></li><li><code>hydrate()</code></li><li><code>unmountComponentAtNode()</code></li><li><code>findDOMNode()</code></li><li><code>createPortal()</code></li></ol>"
            },
            {
                "name": "Prevent or stop a component from rendering in React?",
                "description": "<p>Returning <code><strong>null</strong></code> from a component's render method does not affect the firing of the component's lifecycle methods.</p>"
            },
            {
                "name": "Difference between state and props?",
                "description": "<p>Both <strong>props</strong> and <strong>state</strong> are plain JavaScript objects. While both of them hold information that influences the output of render, they are different in their functionality with respect to component. i.e,</p><ul><li><strong>Props</strong> get passed to the component similar to function parameters, They are set by the parent and they are fixed throughout the lifetime of a component.</li><li><strong>State</strong> is managed within the component similar to variables declared within a function.</li></ul>"
            },
            {
                "name": "Difference between DOM vs Shadow DOM vs Virtual DOM?",
                "description": "<p>The main difference between DOM and Shadow DOM is how it's created and how it behaves. Normally DOM nodes which we create are placed inside other elements where as In the case of Shadow DOM, we create a scoped tree, which is connected to the element but separated from the children elements. It's called shadow tree and the element it's attached to is called shadow host</p><p>The main difference between Virtual DOM and Shadow DOM is that - Virtual DOM is create a copy of the whole DOM object and when any change is detected only that dom re-renders and get update, and Shadow DOM creates small pieces of the DOM object which has their own, isolated scope for the element they represent.</p>"
            },
            {
                "name": "2 types of components (class vs function)?",
                "description": "<p>Components are like functions that return HTML elements.<br>They serve the same purpose as JavaScript functions, but work in isolation and return HTML via a render() function.<br>Components come in two types, Class components and Function components</p><table><tr><th>Functional Components</th><th>Class Components</th></tr><tr><td><ul><li>Functional Components mainly focuses on the UI of the application, not on the behavior, hence also known as statless components or presenttional components</li><li>Functional Components are simple functions which recieves props and return declarations</li><li>We Should use function componets as much as possible over the class components becuase of the absence of the <code>this</code> keywork.</li><li>To be more precise these are basically render function in the class component.</li><li>Functional Components can have state and mimic lifecycle events using Reach Hooks</li></ul></td><td><ul><li>Class Components are more feature rich</li><li>They Can maintain their own private data also called as <code>state</code></li><li>They contain mostly the complicated logic and mst importantly they provide lifecycle hooks</li><li>Because of what they are capale of and how they are used they are also called as Stateful or Container Components</li><li>Class-based Components uses ES6 class syntax</li><li>Class components extend from React.Component.</li><li>In here you have to use this keyword to access the props and functions that you declare inside the class components.</li></ul></td></tr></table><br><br><strong>Functional or Stateless Component</strong><br><img src='./assets/react/reactFunctionalComponent.png'><br><br><strong>Class or Statefull Component</strong><br><img src='./assets/react/reactClassComponent.png'><br><br><img src='./assets/react/reactClassComponent1.png'>"
            },
            {
                "name": "Differences between a Class component and Functional component?",
                "description": "<p><strong>Class Components</strong></p><ul><li>Class-based Components uses ES6 class syntax. It can make use of the lifecycle methods.</li><li>Class components extend from React.Component.</li><li>In here you have to use this keyword to access the props and functions that you declare inside the class components.</li></ul><p><strong>Functional Components</strong></p><ul><li>Functional Components are simpler comparing to class-based functions.</li><li>Functional Components mainly focuses on the UI of the application, not on the behavior.</li><li>To be more precise these are basically render function in the class component.</li><li>Functional Components can have state and mimic lifecycle events using Reach Hooks</li></ul>"
            },
            {
                "name": "Do two components using the same Hook share state?",
                "description": "<p>No. Custom Hooks are a mechanism to reuse <strong>stateful logic</strong> (such as setting up a subscription and remembering the current value), but every time you use a custom Hook, all state and effects inside of it are <strong>fully</strong> isolated.</p>"
            },
            {
                "name": "Increase, Optimizing Performance on a React App",
                "description": "<ul> <li><strong>Use React.Fragment to Avoid Adding Extra Nodes to the DOM</strong> - React Fragment, which will not add any additional node to the DOM.<br><img src='./assets/react/fragment.png'><br><br><strong>Short Fragment</strong><br><img src='./assets/react/fragment2.png'></li><li><strong>Use Production Build</strong> - Another way of optimizing a React app is by making sure you bundle your app for production before deploying. By default, your app is in development mode, which means React will include helpful warnings. You can fix this by running npm run build before deploying, which will create a production-ready build of your app in a build/ folder that you can then deploy.</li><li><strong>Use React.Suspense and React.Lazy for Lazy Loading Components</strong> - </li><li><strong>Use React.memo for Component Memoization</strong> - React.memo is a great way of optimizing performance as it helps cache functional components. Here's how it works: When a function is rendered using this technique, it saves the result in memory, and the next time the function with the same arguments is called it returns the saved result without executing the function again, saving you bandwidth. In the context of React, functions are the functional components, and arguments are props</li><li><strong>Virtualize a Large List Using react-window library</strong> - When you want to render an enormous table or list of data, it can significantly slow down your app's performance. react-window helps solve this problem by rendering only the items in the list that are currently visible, which allows for efficiently rendering lists of any size.</li><li><strong>Avoid Inline Function Definition in the Render Function.</strong> - Because such functions aren’t assigned an identifier (via const/let/var), they aren’t persistent whenever a component inevitably gets rendered again. This causes JavaScript to allocate new memory each time this component is re-rendered, instead of allocating a single piece of memory only once</li><li><strong>Dependency optimization</strong> - Let's say you are only using 20 of the 100+ methods, then having all the extra methods in your final bundle is not optimal. So for this, you can remove unused functions.</li><li><strong>Throttling and Debouncing Event Action in JavaScript</strong> - Throttling - means delaying function execution. So instead of executing the event handler/function immediately, you’ll be adding a few milliseconds of delay when an event is triggered. This can be used when implementing infinite scrolling or Another good example of this is Ajax-based instant search. You might not want to hit the server for every key press, so it's better to throttle until the input field is dormant for a few milliseconds <br>Debouncing - is a technique to prevent the event trigger from being fired too often by adding a delay</li><li><strong>Avoid using Index as Key for map</strong> - Because using the key as the index can show your app incorrect data as it is being used to identify DOM elements. When you push or remove an item from the list, if the key is the same as before, React assumes that the DOM element represents the same component. In certain cases, it's completely okay to use the index as the key, but only if below condition holds:<br>1. The list and items are static <br>2. The items in the list don't have IDs and the list is never going to be reordered or filtered <br>3. List is immutable <br></li><li><strong>CSS Animations Instead of JS Animations</strong> - </li><li><strong>Using conditionals or tenaries to make a component disappear</strong> (i.e. to unmount it) is not advisable, because the component made to disappear will cause the browser to repaint and reflow. Instead, we can use CSS’ opacity and visibility properties to hide the component. This way, the component will still be in the DOM but invisible, without any performance cost.</li><li><strong>Immutable Data Structures</strong> - Any data that cannot be changed is immutable. An immutable value or object cannot be changed. So, when there is an update, a new value is created in memory, leaving the old one untouched. We can use immutable data structures and React.PureComponent to automatically check for a complex state change. For example, if the state in your application is immutable, you can actually save all state objects in a single store with a state-management library like Redux, enabling you to easily implement undo and redo functionality.</li></ul>"
            },
            {
                "name": "When to use a Class Component over a Function Component?",
                "description": "<p>If you are writing a presentational component which doesn’t have its own state or needs to access a lifecycle hook, then use functional component as much as possible. For state management, or handling complex Ui logics you can use class component.</p>"
            },
            {
                "name": "How to call loading function with React useEffect only once?",
                "description": "<p>If you only want to run the function given to <code><strong>useEffect</strong></code> after the initial render, you can give it an empty array <code><strong>[]</strong></code> as the second argument. <br><img src='./assets/react/loadOnce.png'></p>"
            },
            {
                "name": "What is a Pure Functionional Component?",
                "description": "<p>A function is said to be pure if:</p><ul><li>Its return value is only determined by its input values </li><li>Its return value is always the same for the same input values</li></ul> <p>A React component is considered pure if it renders the same output for the same state and props.</p><p>With <code>React.memo()</code>, you can create memoized functional components that bail out of rendering on unnecessary updates using shallow comparison of props.</p>"
            },
            {
                "name": "What are Props?",
                "description": "<p>“Props” is a special keyword in React, which stands for properties and is being used for passing data from one component to another. But the important part here is that data with props are being passed in a uni-directional flow. ( one way from parent to child)<br><img src='./assets/react/props.png'></p>"
            },
            {
                "name": "What are Portals",
                "description": "<p>React Portal is a kind of way to render child components into a DOM node which is outside of the parent DOM hierarchy defined by the component tree hierarchy. The Portal's most common use cases are when the child components need to visually break out of the parent container as shown below.</p><ul><li>Modal dialog boxes</li><li>Tooltips</li><li>Hovercards</li><li>Loaders</li></ul><br><img src='./assets/react/reactportal.png'><br><br><img src='./assets/react/reactportal1.png'>"
            },
            {
                "name": "Explain “refs” in React?",
                "description": "<p>Refs are generally avoided in React and should be used with precautions. It is because they directly interact with the Real DOM and in React that is not desirable behaviour.</p><p>We can, however, use refs in the following situations.</p><ul><li>Interaction with third party libraries like jQuery.</li><li>Doing animations</li><li>Managing focus when we move to a text box</li></ul><p><img src='./assets/react/useref1.png'><br><img src='./assets/react/useref.png'></p>"
            },
            {
                "name": "What are forward refs?",
                "description": "<p>Ref forwarding is a technique for automatically passing a ref through a component to one of its children.</p><p>Managing focus, text selection, or media playback, Incrementing values, Triggering any kind of imperative animations<br><img src='./assets/react/forwardref.png'></p>"
            },
            {
                "name": "What happens when you call setState?",
                "description": "<p>When you call <code>SetState</code> in React, the object you passed into it will be merged into the current state of the component. This triggers something called <em>reconciliation</em>. Reconciliation aims to update the user interface in the most efficient way possible.</p><p>React does this by constructing a tree of React elements and compare it to the previous element tree. This shows React the exact changes that occurred so React can make updates in the necessary places.</p>"
            },
            {
                "name": "When to use useCallback, useMemo and useEffect?",
                "description": "<ul><li><strong>useEffect</strong> - It's the alternative for the class component lifecycle methods <code>componentDidMount, componentWillUnmount, componentDidUpdate</code>, etc. You can also use it to <strong>create a side effect when dependencies change</strong>, i.e. \"If some variable changes, do this\".</li><li><strong>useCallback</strong> - On every render, everything that's inside a functional component will run again. If a child component has a dependency on a function from the parent component, the child will re-render every time the parent re-renders even if that function \"doesn't change\" (the reference changes, but what the function does won't).<br>It's used for optimization by avoiding unnecessary renders from the child, making the function change the reference only when dependencies change. You should use it when a function is a dependency of a side effect e.g. useEffect.</li><li><strong>useMemo</strong> - It will run on every render, but with cached values. It will only use new values when certain dependencies change. It's used for optimization <strong>when you have expensive computations</strong>.</li></ul>"
            },
            {
                "name": "Difference between useCallback and useMemo in practice",
                "description": "<p>With <code>useCallback</code> you memoize <strong>functions</strong>, <code>useMemo</code> memoizes <strong>any computed value</strong>:<br><img src='./assets/react/memo1.png'></p><p><code>(1)</code> will return a memoized version of <code>fn</code> - same reference across multiple renders, as long as <code>dep</code> is the same. But <em>every time</em> you <em>invoke</em> <code>memoFn</code>, <em>that complex computation starts again</em>.</p><p><code>(2)</code> will invoke <code>fn</code> every time <code>dep</code> changes and remember its <em>returned value</em> (<code>42</code> here), which is then stored in <code>memoFnReturn</code>.</p>"
            },
            {
                "name": "Why do we use array destructuring (square brackets notation) in useState?",
                "description": "<p>When we declare a state variable with useState, it returns a pair — an array with two items. The first item is the current value, and the second is a function that updates the value. Using [0] and [1] to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.<br><img src='./assets/react/array_destructure.png'></p>"
            },
            {
                "name": "Why should we not update the state directly?",
                "description": "<p>If you try to update the state directly then it won't re-render the component.<br><img src='./assets/react/wrongState.png'></p><p>Instead use setState() method. It schedules an update to a component's state object. When state changes, the component responds by re-rendering.<br><img src='./assets/react/correctState.png'></p>"
            },
            {
                "name": "What is Lifting State Up or Pass data from child to parent component?",
                "description": "<p>When several components need to share the same changing data then it is recommended to lifting the shared state up to their closest common ancestor. For example, if two child components sharing the same data from its parent then move the state to parent instead of maintaining the local state inn both child components.<br><img src='./assets/react/lifting.png'></p>"
            },
            {
                "name": "What will happen if you use setState() in constructor?",
                "description": "<p>When you use <code>setState()</code>, then apart from assigning to the object state React also re-renders the component and all its children. You would get error like this: <em>Can only update a mounted or mounting component.</em> So we need to use <code>this.state</code> to initialize variables inside constructor.</p>"
            },
            {
                "name": "Is it good to use setState() in componentWillMount() method?",
                "description": "<p>Yes, it is safe to use <code>setState()</code> inside <code>componentWillMount()</code> method. But at the same it is recommended to avoid async initialization in <code>componentWillMount()</code> lifecycle method. <code>componentWillMount()</code> is invoked immediately before mounting occurs. It is called before <code>render()</code>, therefore setting state in this method will not trigger a re-render. Avoid introducing any side-effects or subscriptions in this method. We need to make sure async calls for component initialization happened in <code>componentDidMount()</code> instead of <code>componentWillMount()</code>.<br><img src='./assets/react/stateinmount.png'></p>"
            },
            {
                "name": "How to use componentWillMount() in React Hooks?",
                "description": "<p>You cannot use any of the existing lifecycle methods (<code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code> etc.) in a hook. They can only be used in class components. And with Hooks you can only use in functional components.</p>"
            },
            {
                "name": "What will happen if you use props in initial state?",
                "description": "<p>If the props on the component are changed without the component being refreshed, the new prop value will never be displayed because the constructor function will never update the current state of the component. The initialization of state from props only runs when the component is first created.<br><img src='./assets/react/propsinitialstate.png'><br><img src='./assets/react/propsinitialstate1.png'></p>"
            },
            {
                "name": "What happens when you call setstate() inside render() method",
                "description": "<p>You can not set state inside render function because it will cause side effect. </p><p>What exactly happens is that each time you update state react calls render function, so if you will update state inside render function then it will stuck inside infinite loop.</p><p>In general, this should never happen; you should not be doing anything remotely related to modifying any component's state within a render function.</p>"
            },
            {
                "name": "What is the purpose of the callback function as an argument of setState()?",
                "description": "<p>The callback function is invoked when setState finished and the component gets rendered. Since setState is asynchronous the callback function is used for any post action. It is recommended to use the lifecycle method rather than this callback function.</p><p>The setState callback is used to carry out operations in a React component after calling setState, like creating an AJAX request or throwing an error.</p><p>As a result, you can encounter situations where parts of your code execute before the state has had an opportunity to update.</p><p>This concludes the purpose of using callBack With setState in React</p>"
            },
            {
                "name": "Does React useState Hook update immediately?  ",
                "description": "<p>React <code>useState</code> and <code>setState</code> don’t make changes directly to the state object; they create queues to optimize performance, which is why the changes don't update immediately. The process to update React state is asynchronous for performance reasons.</p><p>To perform side effects after state has change, you must use the <code>useEffect</code></p>"
            },
            {
                "name": "How do I update state on a nested object with useState()?",
                "description": " <p><strong>Problem</strong> I have a component that receives a prop that looks like this:<br><img src='./assets/react/nestedusestate1.png'></p><p>How to update only the <code>align</code> property?</p><strong>Answer</strong><p>You need to use spread syntax. Also while trying to update current state based on previous, use the <code>callback</code> pattern os <code>setState</code>:<br><img src='./assets/react/nestedusestate.png'></p>"
            },
            {
                "name": "Write an inline style in React?",
                "description": "<p>To style an element with the inline style attribute, the value must be a JavaScript object: Note: In JSX, JavaScript expressions are written inside curly braces, and since JavaScript objects also use curly braces, the styling is written inside two sets of curly braces {{}}<br><br><strong>camelCased Property Names</strong> - properties with two names, like background-color, must be written with camel case syntax such as backgroundColor <br><br><img src='./assets/react/inlineCSS.png'></p>"
            },
            {
                "name": "Combine multiple inline style objects?",
                "description": "<p>You can use spread operator in regular React: <br><img src='./assets/react/inlinecombinestylereact.png'><br><br>If you're using React Native then you can use the array notation:<br><img src='./assets/react/inlinecombinestylereactnative.png'> </p>"
            },
            {
                "name": "Apply vendor prefixes to inline styles in React?",
                "description": "<p>React does not apply vendor prefixes automatically. You need to add vendor prefixes manually.<br><img src='./assets/react/reactinlinestylevendorprefix.png'></p>"
            },
            {
                "name": "What is wrong with that code? setState",
                "description": "<p><strong>Problem</strong><br><img src='./assets/react/problem.png'></p><p><strong>Answer</strong> - Because <code>this.props</code> and <code>this.state</code> may be updated asynchronously, you should not rely on their values for calculating the next state. To fix it, use a second form of <code>setState()</code> that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:<br><img src='./assets/react/answer.png'></p>"
            },
            {
                "name": "What is prop drilling/digging and how can you avoid it?",
                "description": "<p>Prop drilling is the act of <strong>passing props through multiple layers of components</strong></p><p>When building a React application, there is often the need for a deeply nested component to use data provided by another component that is much higher in the hierarchy. The simplest approach is to simply pass a prop from each component to the next in the hierarchy from the source component to the deeply nested component. This is called <strong>prop drilling</strong>.</p><p>The primary disadvantage of prop drilling is that components that should not otherwise be aware of the data become unnecessarily complicated and are harder to maintain.</p><p>To avoid prop drilling, a common approach is to use React context. This allows a <code>Provider</code> component that supplies data to be defined, and allows nested components to consume context data via either a <code>Consumer</code> component or a <code>useContext</code> hook.</p>"
            },
            {
                "name": "What is StrictMode",
                "description": "<p>React's <code>StrictMode</code> help you write better react components, you can wrap a set of components within <code>&lt;StrictMode /&gt;</code> and it'll basically:</p><ul><li>Verify that the components inside are following some of the recommended practices and warn you if not in the console.</li><li>Verify the deprecated methods are not being used, and if they're used strict mode will warn you in the console.</li><li>Help you prevent some side effects by identifying potential risks.</li></ul><br><p>I've found it especially useful to implement strict mode when I'm working on new code bases and I want to see what kind of code/components I'm facing. Also if you're on bug hunting mode, sometimes it's a good idea to wrap with <StrictMode /> the components/blocks of code you think might be the source of the problem.</p>"
            },
            {
                "name": "When would you use StrictMode component in React?",
                "description": "<ul><li>Its especially useful to implement strict mode when you are working on new code bases</li><li>Its also when you are into debugging mode when you think the components/blocks of code you think might be the source of the problem.</li></ul>"
            },
            {
                "name": "Why do class methods need to be bound to a class instance?",
                "description": "<p>In JavaScript, the value of <code>this</code> changes depending on the current context. Within React class component methods, developers normally expect this to refer to the current instance of a component, so it is necessary to <em>bind</em> these methods to the instance. Normally this is done in the constructor—for example:</p><p><img src='./assets/react/classmethod.png'></p>"
            },
            {
                "name": "How to apply validation on PropTypes in ReactJS?",
                "description": "<p>JavaScript is a loosely-bound language, which causes many errors in code. So, we should implement type-check, for different props been passed from Parent to Child component. Earlier it used to be a part of React library but since React v15.5, it has moved as a separate library. So, we need to npm install it and then import it by-</p><p> <strong>import PropTypes from ‘prop-types’;</strong> </p><p>The set of predefined prop types are below</p><ol> <li>String - <code>React.PropTypes.string</code></li><li>Number - <code>React.PropTypes.number</code></li><li>Function - <code>React.PropTypes.func</code></li><li>ArrayOf - <code>React.PropTypes.arrayOf(PropTypes.number)</code></li><li>ArrayOfObject - <code>React.PropTypes.arrayOf(PropTypes.shape({Object1: PropTypes.string, Object2: PropTypes.number}))</code></li><li>Boolean<code>React.PropTypes.bool</code></li><li>Custom(strOrNumber)<code>PropTypes.oneOfType([PropTypes.string, PropTypes.number]),</code></li></ol> <p>For example, we define propTypes for user component as below,</p><p><img src='./assets/react/proptypes.png'></p><p><img src='./assets/react/proptypes1.png'></p>"
            },
            {
                "name": "How would you go about checking/investigating slow React application rendering?",
                "description": "<p>One of the most common issues in React applications is when components <em>re-render unnecessarily</em>. There are two tools provided by React that are helpful in these situations:</p><ul><li><code>React.memo()</code>: This prevents unnecessary re-rendering of function components</li><li><code>PureComponent</code>: This prevents unnecessary re-rendering of class components</li></ul><p>Both of these tools rely on a shallow comparison of the props passed into the component—if the props have not changed, then the component will not re-render. While both tools are very useful, the shallow comparison brings with it an additional performance penalty, so both can have a negative performance impact if used incorrectly. By using the React Profiler, performance can be measured before and after using these tools to ensure that performance is actually improved by making a given change.</p>"
            },
            {
                "name": "Explain why and when would you use useMemo()?",
                "description": "<p><strong>Why:</strong></p><p>In the lifecycle of a component, React re-renders the component when an update is made. When React checks for any changes in a component, it may detect an unintended or unexpected change due to how JavaScript handles equality and shallow comparisons. This change in the React application will cause it to re-render unnecessarily.</p><p>Additionally, if that re-rendering is an expensive operation, like a long <code>for loop</code>, it can hurt performance. Expensive operations can be costly in either time, memory, or processing.</p><p><strong>When:</strong></p><p>Optimal if the wrapped function is large and expensive.</p><p><strong>How: </strong></p><p><em>Memoization</em> is an optimization technique which passes a complex function to be memoized. In memoization, the result is “remembered” when the same parameters are passed-in subsequently. </p><p><img src='./assets/react/memo.png'></p><p><code>useMemo</code> takes in a function and an array of dependencies. The dependency's list are the elements <code>useMemo</code> watches: if there are no changes, the function result will stay the same. Otherwise, it will re-run the function. If they don’t change, it doesn’t matter if our entire component re-renders, the function won’t re-run but instead return the stored result.</p>"
            },
            {
                "name": "When is it important to pass props to super(), and why?",
                "description": "<p>The only one reason when one needs to pass props to <code>super()</code> is when you want to access <code>this.props</code> in constructor:</p><p><img src='./assets/react/propspassing.png'></p><p>Not Passing</p><p><img src='./assets/react/propsnotpassing.png'></p><p>Note that passing or not passing props to super has no effect on later uses of this.props outside constructor.</p>"
            },
            {
                "name": "How does React renderer work exactly when we call setState?",
                "description": "<p>There are two steps of what we may call <code>render</code>:</p><ol><li><p>Virtual DOM render: when <code>render</code> method is called it returns a new <em>virtual dom</em> structure of the component. This <code>render</code> method is called always when you call <code>setState()</code>, because <code>shouldComponentUpdate</code> always returns true by default. So, by default, there is no optimisation here in React.</p></li><li><p>Native DOM render: React changes real DOM nodes in your browser only if they were changed in the Virtual DOM and as little as needed - this is that great React's feature which optimizes real DOM mutation and makes React fast.</p></li></ol>"
            },
            {
                "name": "Does React re-render all components and sub components every time setState is called?",
                "description": "<p>By default - <strong>yes</strong>.</p><p>There is a method boolean <code>shouldComponentUpdate(object nextProps, object nextState)</code>, each component has this method and it's responsible to determine \"should component update (run render function)?\" every time you change state or pass new props from parent component.</p><p>You can write your own implementation of <code>shouldComponentUpdate</code> method for your component, but default implementation always returns true - meaning always re-run render function.</p>"
            },
            {
                "name": "What is DOM?",
                "description": "<p>DOM stands for Document Object Model.</p><p>When the browser tries to render a HTML document, it creates an object based on the HTML document called DOM. Using this DOM, we can manipulate or change various elements inside the HTML document.<br><br><img src='./assets/js/dom1.png'></p>"
            },
            {
                "name": "What is Shadow DOM",
                "description": "<p>Shadow DOM is a tool used to build component-based apps and websites. Shadow DOM comes in small pieces, and it doesn't represent the whole Document Object Model. We can see it as a subtree or as a separate DOM for an element. Shadow DOM can be imaged like bricks from which the DOM is created.</p>"
            },
            {
                "name": "What is Virtual DOM",
                "description": "<p>Virtual DOM is a concept of DOM used by React.js. In Virtual DOM concept copy of DOM is saved in the memory and while any change is done in the DOM, it's compared to find differences. Then browser knows which elements were changed and can update only those part of the application to avoid re-rendering all the DOM. It's done to improve the performance of the UI libraries.</p>"
            },
            {
                "name": "Explain the Virtual DOM concept in React?",
                "description": "<ul><li>Virtual DOM is actually an in-memory representation of Real DOM. It is a lightweight JavaScript Object which is a copy of Real DOM.</li><li>Whenever setState() method is called in your code, ReactJS creates the whole Virtual DOM from scratch.</li><li>At a given time, ReactJS maintains two virtual DOM, one with the updated state Virtual DOM and the other with the previous state Virtual DOM.</li><li>ReactJS uses a differential algorithm to compare both of the Virtual DOM to find the minimum number of steps to update the Real DOM.</li></ul><p>After that, it updates the Real DOM, whenever it's best to update it.</p>"
            },
            {
                "name": "What is reselect and how it works?",
                "description": "<p><strong>Reselect</strong> is a selector library (for Redux) which works on memoization concept. Reselect keeps a copy of the last inputs/outputs of the last call, and recomputes the result only if one of the inputs changes. If the the same inputs are provided twice in a row, Reselect return the cached saved output. It's memoization and cache are fully customizable.</p>"
            },
            {
                "name": "What would be the common mistake of function being called every time the component renders?",
                "description": "<p>You need to make sure that function is not being called while passing the function as a parameter.</p><p><img src='./assets/react/componentmistake.png'></p><p>Instead, pass the function itself without parenthesis:</p><p><img src='./assets/react/componentmistake1.png'></p>"
            },
            {
                "name": "What does \"shouldComponentUpdate\" do and why is it important?",
                "description": "<p>It's used for performance reasons, for example if the implementor of a component knows for sure that a particular property change does not necessitate a re-render, they could return false from this method and skip the re-render.</p><p>What <code>shouldComponentUpdate</code> does is it's a lifecycle method that allows us to opt out of <em>setState</em> reconciliation process for certain components (and their child components). If we know that a certain section of our UI isn’t going to change, there's no reason to have React go through the trouble of trying to figure out if it should. By returning false from <code>shouldComponentUpdate</code>, React will assume that the current component, and all its child components, will stay the same as they currently are.</p>"
            },
            {
                "name": "What is children prop?",
                "description": "<p>Children is a prop (this.prop.children) that allow you to pass components as data to other components, just like any other prop you use.</p><p>You can use props.children on components that represent ‘generic boxes’ and that don’t know their children ahead of time. It is used to display whatever you include between the opening and closing tags when invoking a component.</p>"
            },
            {
                "name": "What is {this.props.children} and when you should use it?",
                "description": "<p>It is used to display whatever you include between the opening and closing tags when invoking a component</p>"
            },
            {
                "name": "What are Fragments?",
                "description": "<ul><li>How to return multiple components without wrapping using div, HOC or Fragment</li><li>Fragments help you return a list of items without adding extra nodes to the DOM.</li><li>Return as an Array. This is introduced since React 16</li></ul><p><img src='./assets/react/fragmentarray.png'></p><p><img src='./assets/react/fragment1.png'></p><p>There is also a shorter syntax:</p><p><img src='./assets/react/fragment2.png'></p>"
            },
            {
                "name": "Why fragments are better than container divs?",
                "description": "<p>Below are the reasons why fragments recommended:</p><ol><li>Fragments bit faster and has less memory usage by without creating an extra DOM node. This only has a real benefit on very large and deep trees.</li><li>Some CSS mechanisms like Flexbox and CSS Grid have a special parent-child relationship, and adding divs in the middle makes it hard to keep the desired layout.</li><li>The DOM inspector is less cluttered</li></ol>"
            },
            {
                "name": "What is Reconciliation / Why is a component constructor called only once?",
                "description": "<p>When a component's props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called <strong>reconciliation</strong>.</p>"
            },
            {
                "name": "Where in a React component should you make an AJAX request?",
                "description": "<p><code>componentDidMount</code> is where an AJAX request should be made in a React component. </p><p>This method will be executed when the component “mounts” (is added to the DOM) for the first time. This method is only executed once during the component's life. Importantly, you can’t guarantee the AJAX request will have resolved before the component mounts. If it doesn't, that would mean that you’d be trying to setState on an unmounted component, which would not work. Making your AJAX request in <code>componentDidMount</code> will guarantee that there's a component to update.</p>"
            },
            {
                "name": "Axios vs Fetch",
                "description": "<ol> <li><strong>Request URL</strong> <ul> <li><strong>Axios</strong> — has url in request object<p><img src='./assets/react/axiosurl.png'></p></li><li><strong>Fetch</strong> — has no url in request object<p><img src='./assets/react/fetchurl.png'></p></li></ul> </li><li><strong>Package</strong> <ul> <li><strong>Axios</strong> — third-party package that you need to install manually.</li><li><strong>Fetch</strong> — is in-build into most of the browser, no more need of installation.</li></ul> </li><li><strong>CSRF Protection</strong> <ul> <li><strong>Axios</strong> — having in-build support of CSRF (Cross site request forgery) to prevent cross-site request.</li><li><strong>Fetch</strong> — doesn’t support CSRF</li></ul> </li><li><strong>Request Data</strong> <ul> <li><strong>Axios</strong> — For Requesting data axios uses the data property which contain object, you can directly sent JSON Object in request data<p><img src='./assets/react/axiosobject.png'></p></li><li><strong>Fetch</strong> — For requesting data fetch uses the body property, which should be in string and not any object<p><img src='./assets/react/fetchobject.png'></p></li></ul> </li><li><strong>Response Parsing</strong> <ul> <li><strong>Axios</strong> — in-built transform response to JSON for developers<p><img src='./assets/react/axiosres.png'></p></li><li><strong>Fetch</strong> — has two step process, first response convert to json and then in second process developer will get json response<p><img src='./assets/react/fetchres.png'></p></li></ul> </li><li><strong>Response status</strong> <ul> <li><strong>Axios</strong> — request is ok when status is 200 and statusText is ‘OK’.</li><li><strong>Fetch</strong> — request is ok when response object contains the ok property.</li></ul> </li><li><strong>Cancel Request</strong> <ul> <li><strong>Axios</strong> — In case user left the screen/component, axios allow developers to Cancel request<p><img src='./assets/react/axioscancle.png'></p></li><li><strong>Fetch</strong> — doesn’t support Cancel API request</li></ul> </li><li><strong>Request Interceptor</strong> <ul> <li><strong>Axios</strong> — having in-build feature of intercept HTTP Request</li><li><strong>Fetch</strong> — Doesn’t provide a way to intercept http requests.</li></ul> </li><li><strong>Upload/Download Request Progress</strong> <ul> <li><strong>Axios</strong> — Support developers to provide data transmission progress so developers can show loading indicator while user communicating with server</li><li><strong>Fetch</strong> — Doesn’t support Upload/Download progress</li></ul> </li><li><strong>Browser Support</strong> <ul> <li><strong>Axios</strong> — have wide browser capability support</li><li><strong>Fetch</strong> — only support limited browsers & version , like Chrome 42+, Firefox 39+, Edge 14+, Safari 10.1.</li></ul> </li></ol>"
            },
            {
                "name": "Write a small piece of code to render a button.",
                "description": "<p><img src='./assets/react/render.png'></p>"
            },
            {
                "name": "What is the output of the following code",
                "description": "<p><img src='./assets/react/output.png'></p><p>This will render 0 to the browser.</p><ul><li>When using conditional rendering using logical &amp;&amp; operator 0 is evaluated as number and will be rendered by the browser</li><li>How we can avoid rendering 0 in the above case.</li></ul><p>We need to make the 0 a Boolean by adding !. Code is given below</p><p><img src='./assets/react/output1.png'></p>"
            },
            {
                "name": "How react router works",
                "description": "<p>React router is a commonly used module for routing in React applications.</p><p>React router component listens to history changes in React applications. It has a URL mapping to components in it. It renders the corresponding component when a match is found.</p><p>Link component is used to navigate around in your application.</p><p><strong>Code sample below</strong></p><p><img src='./assets/react/reactrouter.png'></p>"
            },
            {
                "name": "How React Router is different from history library?",
                "description": "<p>React Router is a wrapper around the <code>history</code> library which handles interaction with the browser's <code>window.history</code> with its browser and hash histories. It also provides memory history which is useful for environments that don't have global history, such as mobile app development (React Native) and unit testing with Node.</p>"
            },
            {
                "name": "What are the &lt;Router&gt; components of React Router v4",
                "description": "<p>React Router v4 provides below 3 <code>&lt;Router&gt;</code> components:</p><ol><li><code>&lt;BrowserRouter&gt;</code></li><li><code>&lt;HashRouter&gt;</code></li><li><code>&lt;MemoryRouter&gt;</code></li></ol><p>The above components will create <em>browser</em>, <em>hash</em>, and <em>memory</em> history instances. React Router v4 makes the properties and methods of the <code>history</code> instance associated with your router available through the context in the <code>router</code> object.</p>"
            },
            {
                "name": "How do you programmatically navigate using React Router v4",
                "description": "<p><strong>#1. Using the <code>withRouter()</code> higher-order function:</strong> - The <code>withRouter()</code> higher-order function will inject the history object as a prop of the component. This object provides <code>push()</code> and <code>replace()</code> methods to avoid the usage of context.</br><img src='./assets/react/withRoute.png'></p><p><strong>#2. Using <code>&lt;Route&gt;</code> component and render props pattern:</strong> - The <code>&lt;Route&gt;</code> component passes the same props as <code>withRouter()</code>, so you will be able to access the history methods through the history prop.<br><img src='./assets/react/route.png'></p><p><strong>#3. Using context:</strong> - This option is not recommended and treated as unstable API.<br><img src='./assets/react/routeContext.png'></p>"
            },
            {
                "name": "Why you get \"Router may have only one child element\" warning?",
                "description": "<p>You have to wrap your Route's in a <code>&lt;Switch&gt;</code> block because <code>&lt;Switch&gt;</code> is unique in that it renders a route exclusively.</p><p>At first you need to add <code>Switch</code> to your imports:<br><img src='./assets/react/importSwitch.png'></p><p>Then define the routes within <code>&lt;Switch&gt;</code> block:<br><img src='./assets/react/route1.png'></p>"
            },
            {
                "name": "How to pass params to history.push method in React Router v4?",
                "description": "<p>While navigating you can pass props to the <code>history</code> object:<br><img src='./assets/react/historypush.png'></p><p>The <code>search</code> property is used to pass query params in <code>push()</code> method.</p>"
            },
            {
                "name": "How to implement default or NotFound page?",
                "description": "<p>A <code>&lt;Switch&gt;</code> renders the first child <code>&lt;Route&gt;</code> that matches. A <code>&lt;Route&gt;</code> with no path always matches. So you just need to simply drop path attribute as below<br><img src='./assets/react/notfound.png'></p>"
            },
            {
                "name": "How to perform automatic redirect after login?",
                "description": "<p>The <code>react-router</code> package provides <code>&lt;Redirect&gt;</code> component in React Router. Rendering a <code>&lt;Redirect&gt;</code> will navigate to a new location. Like server-side redirects, the new location will override the current location in the history stack.<br><img src='./assets/react/autoredirect.png'></p>"
            },
            {
                "name": "What all ways data can be passed between react components",
                "description": "<ul><li>Parent to child – props, context</li><li>Child to parent – states, callbacks</li><li>Siblings – callback, props, context</li></ul>"
            },
            {
                "name": "Write a program to pass values to child using context.",
                "description": "<p><img src='./assets/react/context.png'></p><p><img src='./assets/react/contextexplain.png'></p><p><img src='./assets/react/contextexplain1.png'></p><p><img src='./assets/react/contextexplain2.png'></p>"
            },
            {
                "name": "Are you familiar with Flux in the context of React?",
                "description": "<p><strong>Flux</strong> is an architectural pattern that enforces unidirectional data flow —&nbsp;its core purpose is to control derived data so that multiple components can interact with that data without risking pollution.</p><p>The Flux pattern is generic; it’s not specific to React applications, nor is it required to build a React app. However, Flux is commonly used by React developers because React components are declarative —&nbsp;the rendered UI (View) is simply a function of state (Store data).<br><img src='./assets/react/flux.png'></p><p>In the Flux pattern, the <em>Store</em> is the central authority for all data; any mutations to the data must occur within the store. Changes to the Store data are subsequently broadcast to subscribing Views via events. Views then update themselves based on the new state of received data.</p><p>To request changes to any Store data, <em>Actions</em> may be fired. These Actions are controlled by a central <em>Dispatcher</em>; Actions may not occur simultaneously, ensuring that a Store only mutates data once per Action.</p><p>The strict unidirectional flow of this Flux pattern enforces data stability, reducing data-related runtime errors throughout an application.</p>"
            },
            {
                "name": "What are keys and its significance in Listing",
                "description": "<p>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity</p><p>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings</p><ul><li><strong>Item Id as key</strong> - So using the item id as the key will mean that the component for that item will not be destroyed and re-created. If you add a new item to the list it will create a new component, and if you remove an item it will destroy the old one, but if you update an item without change its ID, the component will just update.</li><li><strong>Item Index as key</strong> - There can be issues with using index as key but not always. If we are not adding /removing items from list then it is fine to use index as keys else it will be good to use some id which uniquely identifies the item. Reason is if you add or remove some items from the list, indexes change for older items and react can get confused which items are changed.</li></ul>"
            },
            {
                "name": "What are the different phases of ReactJS component lifecycle?",
                "description": "<p>There are four different phases of React component's lifecycle:</p><ol><li><strong>Initialization:</strong> In this phase react component prepares setting up the initial state and default props.</li><li><strong>Mounting:</strong> The react component is ready to mount in the browser DOM. This phase covers <strong>componentWillMount</strong> and <strong>componentDidMount</strong> lifecycle methods.</li><li><strong>Updating:</strong> In this phase, the component get updated in two ways, sending the new props and updating the state. This phase covers <strong>shouldComponentUpdate, componentWillUpdate and componentDidUpdate</strong> lifecycle methods.</li><li><strong>Unmounting:</strong> In this last phase, the component is not needed and get unmounted from the browser DOM. This phase include <strong>componentWillUnmount</strong> lifecycle method.</li></ol><p><img src='./assets/react/reactphases.png'></p><ul><li><strong><code>componentWillMount</code></strong>- this is most commonly used for App configuration in your root component. </li><li><strong><code>componentDidMount</code></strong> - here you want to do all the setup you couldn’t do without a DOM, and start getting all the data you need. Also if you want to set up eventListeners etc. this lifecycle hook is a good place to do that.</li><li><strong><code>componentWillReceiveProps</code></strong> - this lifecyclye acts on particular prop changes to trigger state transitions.</li><li><strong><code>shouldComponentUpdate</code></strong> - if you’re worried about wasted renders <code>shouldComponentUpdate</code> is a great place to improve performance as it allows you to prevent a rerender if component receives new <code>prop</code>. <code>shouldComponentUpdate</code> should always return a boolean and based on what this is will determine if the component is rerendered or not.</li><li><strong><code>componentWillUpdate</code></strong> - rarely used. It can be used instead of <code>componentWillReceiveProps</code> on a component that also has <code>shouldComponentUpdate</code> (but no access to previous props).</li><li><strong><code>componentDidUpdate</code></strong> - also commonly used to update the DOM in response to prop or state changes.</li><li><strong><code>componentWillUnmount</code></strong> - here you can cancel any outgoing network requests, or remove all event listeners associated with the component.</li></ul>"
            },
            {
                "name": "Name the different lifecycle methods for a class components",
                "description": "<ul><li><strong><code>componentWillMount</code></strong>- this is most commonly used for App configuration in your root component. </li><li><strong><code>componentDidMount</code></strong> - here you want to do all the setup you couldn’t do without a DOM, and start getting all the data you need. Also if you want to set up eventListeners etc. this lifecycle hook is a good place to do that.</li><li><strong><code>componentWillReceiveProps</code></strong> - this lifecyclye acts on particular prop changes to trigger state transitions.</li><li><strong><code>shouldComponentUpdate</code></strong> - if you’re worried about wasted renders <code>shouldComponentUpdate</code> is a great place to improve performance as it allows you to prevent a rerender if component receives new <code>prop</code>. <code>shouldComponentUpdate</code> should always return a boolean and based on what this is will determine if the component is rerendered or not.</li><li><strong><code>componentWillUpdate</code></strong> - rarely used. It can be used instead of <code>componentWillReceiveProps</code> on a component that also has <code>shouldComponentUpdate</code> (but no access to previous props).</li><li><strong><code>componentDidUpdate</code></strong> - also commonly used to update the DOM in response to prop or state changes.</li><li><strong><code>componentWillUnmount</code></strong> - here you can cancel any outgoing network requests, or remove all event listeners associated with the component.</li></ul><p><img src='./assets/react/classLifeCycle.png'></p>"
            },
            {
                "name": "How to pass a parameter to an event handler or callback?",
                "description": "<p>If you want to pass a parameter to the click event handler you need to make use of the arrow function or bind the function. If you pass the argument directly the onClick function would be called automatically even before pressing the button. <br><img src='./assets/react/parameter.png'></p><p>we will use <strong>Bind Method</strong> that is also used to pass the parameters in functions of class-based components. <br><img src='./assets/react/parameterBind.png'></p>"
            },
            {
                "name": "What are Pure components in React",
                "description": "<p>React.PureComponent is one of the most significant ways to optimize React applications that is easy and fast to implement. The usage of React.PureComponent gives a considerable increase in performance because it reduces the number of render operation in the application.</p><p>By default, a plain React.Component has shouldComponentUpdate set to always return true.<br>One way to deal with these extra re-renders is to change the shouldComponentUpdate function to check when your component needs to update</p><p>A common pitfall when converting from Component to PureComponent is to forget that the children need to re-render too. As with all React - if the parent doesn’t re-render the children won’t either. So if you have a PureComponent with children, those children can only update if the parent's state or props are shallowly different (causing the parent to re-render).<br>You can only have a PureComponent parent if you know none of the children should re-render if the parent doesn’t re-render.<br>If your React component's render function renders the same result given the same props and state, you can use React.PureComponent for a performance boost in some cases.</p><p>Code sample below</p><p>When we extend XYZ component from React.Component the render function will be called each time you if you click the button.</p><p>Instead if you extend the XYZ component from React.PureComponent the render function will be called only once. That means it calls render when the prop Is shallowly different</p>"
            },
            {
                "name": "Why API calls are to be made from componentDidMount and not in constructor/componentWillMount",
                "description": "<p>This is recommended to avoid side effects. Render method will get called immediately after the componentWillMount and no way we can make the render method wait until the API has returned.</p><p>Constructor is a place where we define the variables and not make any API calls. API calls can have side effects and should not be used inside constructor</p><p>React expects state to be available as render function will be called next after componentWillMount &nbsp;and code can break if any mentioned state variable is missing which may occur in case of ajax API calls</p><p>One more reason is If we are doing server-side rendering of React components&nbsp;componentWillMount&nbsp;will get called on the server-side and again on the client, resulting in calling fetch two times. Hence, this is not definitely the place where we should integrate our APIs.</p><p>NOTE: A side effect is any application state change that is observable outside the called function other than its return value. Eg: modifying a global variable</p>"
            },
            {
                "name": "Explain the initial cycle in React which happens during the first render?",
                "description": "<p>When a React App loads for the first time, the code is run in the mentioned order. All the below-mentioned methods run only one time except “render()”, which can be run many times depending on setState and Parent component bee called.<br><br>1) The “constructor()” is the first thing to be called. You can set the initial state here like below.</p><p><br>2) Then the “componentWillMount()” will be called. It is very similar to the constructor and called only once before the initial mounting of DOM. That is the reason, it doesn’t have access to the DOM. &nbsp;ReactJS documentation recommends us to use constructor instead of this lifecycle method and it will be soon deprecated.</p><p>3) Then the initial “render()” will be called. It will also render all the child components(if any) of this component. Also, note that render is generally called many times. Whenever we use setState, the component render is called.</p><p>4) Then the function “componentDidMount()” will be called. This function will also be called once during the whole life-cycle. It is a great place to do AJAX call to the server to fetch some data. You can also initialize something that requires interaction with the DOM, like a jQuery library.</p><p><img src='./assets/react/lifecyclereact.png'></p>"
            },
            {
                "name": "Explain lifecycle of component re-rendering due to re-rendering of parent component?",
                "description": "<p>The “shouldComponentUpdate()” lifecycle method is an method, by which we can decide whether to render a component or not. It is mainly used to increase the performance of poor performing components.</p><p>If we return false, it means React will not execute the lifecycle methods - componentWillUpdate() and componentDidUpdate() and also the render()</p><p>If it is not used in the project, then React internally gives the default value of true to it.</p><ul><li>The next to execute is the lifecycle method “componentWillUpdate()”. This method is called before the render(), but not during the initial first render.</li><li>Next, the render() of the component is called and with it, all child components(if any) will be called.</li><li>Lastly the “componentDidUpdate()” lifecycle method will be called. This method is called after the render(). It is a good place to work with any third party library requiring access to the DOM, like a jQuery plugin.</li></ul><p><img src='./assets/react/shouldcomponentupdate.jpg'></p>"
            },
            {
                "name": "Explain the new lifecycle methods in React 16.3?",
                "description": "<p>There are two new lifecycle methods introduced in <em>React 16.3</em>. Their main task is replacing the old error-prone lifecycle methods like componentWillUpdate and componentWillReceiveProps. You can still use these old lifecycle methods in your project but only till React 17 is released. These old lifecycle methods are now called - UNSAFE_componentWillUpdate and UNSAFE_componentWillReceiveProps.</p><p><strong>static getDerivedStateFromProps(nextProps, prevState)</strong><br>This lifecycle method is invoked before calling render(), both on the initial mount and subsequent mounts. It's main job is replacing <em>componentWillReceiveProps which is now called&nbsp;</em>UNSAFE_componentWillReceiveProps<em>.</em></p><p><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong><br>This lifecycle method is called right before the changes from VDOM are to be committed to the Real DOM. It enables your component to capture some information from the DOM like mouse position before it is changed. The returned value by this lifecycle will be passed as a parameter to <em>componentDidUpdate().</em></p><p>So, the new order of mounting is -</p><ul><li>constructor()</li><li>static getDerivedStateFromProps()</li><li>render()</li><li>componentDidMount()</li></ul><p>The order of update caused by changes in any props or state is -</p><ul><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate()</li><li>render()</li><li>getSnapshotBeforeUpdate()</li><li>componentDidUpdate()</li></ul>"
            },
            {
                "name": "What are Higher-Order components - HOC?",
                "description": "<p>A higher-order component (HOC) is a function that takes a component and returns a new component. Basically, it's a pattern that is derived from React's compositional nature We call them as “pure’ components” because they can accept any dynamically provided child component but they won’t modify or copy any behavior from their input components.</p><p>HOC can be used for many use cases as below,</p><ol><li>Code reuse, logic and bootstrap abstraction</li><li>Render High jacking</li><li>State abstraction and manipulation</li><li>Props manipulation</li></ol><p>Best Example is <code>React.memo</code></p>"
            },
            {
                "name": "How to pass data between sibling components using React router?",
                "description": "<p>We can pass data between React sibling components using React Router using <code>history.push</code> and <code>match.params</code> / <code>useParams</code> hook</p><p>We have a Parent component App.js. We have two Child Components HomePage and AboutPage. Everything is inside a Router from React-router Route. We also have a route for /about/{params}. This is where we will pass the data.</p><p><img src='./assets/react/reactrouter1.png'></p><p>The HomePage is a simple functional component, which have a button. On clicking the button we are using <code>props.history.push(‘/about/’ + data)</code> , which is used to programatically navigate to /about/data</p><p><img src='./assets/react/reactrouter2.png'></p><p>The AboutPage is also a simple functional component, which gets the passed data by <code>props.match.params.aboutId</code></p><p><img src='./assets/react/reactrouter3.png'></p><p>The Page after clicking on the button in the HomePage will now have url in the browser <code>localhost:3000/about/Nabendu</code></p>"
            },
            {
                "name": "Explain the new feature of Lazy loading and code splitting in React",
                "description": "<p>Lazy loading is the new feature introduced in React v16.6, which allows for some Components to load later than other components. This way we can load the components which are fast like text earlier and components which loads images a bit later.</p><ul><li>Consider the below code for App.js. In it, there are two Components ContentComponent and myComp. </li><li>One has some paragraph containing <em>lorem ipsum</em> and others have an image to load from <em>unsplash</em>.</li></ul> <p>Now, we are lazy loading myComp as it has an image to load. Note the special way to import it and also we need to wrap the component in Suspense. Now, Suspense will contain the fallback Component which will be shown while myComp gets loaded.</p><p>The other component ContentComponent will load instantly.</p><p><img src='./assets/react/lazyload.png'></p><p><img src='./assets/react/lazyload1.png'></p><p><img src='./assets/react/lazyload2.png'></p><p>React is very fast and in localhost, condition to see it, we have to emulate Slow speed. To do so open the console, and go to Network tab. Then click on Online and select Slow 3G.</p><p>Now, when you refresh the local running app, you can see <code>Loading…</code>.coming.</p>"
            },
            {
                "name": "When would you use useRef",
                "description": "<p>A very common use case for using useRef is for when, suppose you click on a button, and then on its click you want an input to come into focus. To do this, we would need to access the DOM element of input and then call its function focus() to focus the input.</p>"
            },
            {
                "name": "Why does React use SyntheticEvents",
                "description": "<p>React implements a <strong>synthetic events</strong> system that brings consistency and high performance to React apps and interfaces. It achieves consistency by normalizing events so that they have the same properties across different browsers and platforms.</p><p>A synthetic event is a cross-browser wrapper around the browser’s native event. It has the same interface as the browser’s native event, including <code>stopPropagation()</code> and <code>preventDefault()</code>, except the events work identically across all browsers.</p><p>It achieves high performance by automatically using event delegation. In actuality, React doesn’t attach event handlers to the nodes themselves. Instead, a single event listener is attached to the root of the document. When an event is fired, React maps it to the appropriate component element.</p>"
            },
            {
                "name": "How to use a library like jQuery in React, which interacts directly with DOM?",
                "description": "<p>Using jQuery in React is not recommended as it directly interacts with the DOM and is generally a bad practice. We should always try first to find a React equivalent of the jQuery plugin or write the plugin ourselves. But many times there are plugins, which are only available in jQuery and no other alternative in ReactJS and also very time consuming to write ourselves. In such cases, we can use the method described below.</p><p>We attach a “ref” element to the root DOM element. Inside&nbsp;componentDidMount, we will get a reference to it, so that we can pass it to the jQuery plugin.</p><p>To prevent React from interacting with the DOM after mounting, we will return an empty <strong>&lt;div /&gt;</strong> from our <strong>render()</strong> method. The <strong>&lt;div /&gt;</strong> element has nothing, so React will not update it, leaving the jQuery plugin to manage only that part of the DOM. Also, we will use componetWillUnmount() to unmount the jQuery plugin, after its work with DOM is done.</p><p><img src='./assets/react/reactjquery.png'></p>"
            },
            {
                "name": "Difference between createElement and cloneElement?",
                "description": "<ul><li><strong>createElement</strong> is what JSX gets transpiled to and is what React uses to create React Elements (object representations of some UI). </li><li><strong>cloneElement</strong> is used in order to clone an element and pass it new props. They nailed the naming on these two.</li></ul>"
            },
            {
                "name": "Difference between React.memo and useMemo?",
                "description": "<p>memoization is a process that allows us to cache the values of previous/upcoming function calls so that the next time the function is called with the same argument(s), the cached value is returned rather than having to re-compute the function.</p><p><code>React.memo()</code>is a higher-order component (HOC), that takes a component as a prop and returns a component that prevents a component from re-rendering if the props (or values within it) have not changed.</p><p>While <code>React.memo()</code> is a HOC, <code>useMemo()</code> is a React Hook.<code>useMemo</code> takes in a function and an array of dependencies. The dependency's list are the elements <code>useMemo</code> watches: if there are no changes, the function result will stay the same. Otherwise, it will re-run the function. If they don’t change, it doesn’t matter if our entire component re-renders, the function won’t re-run but instead return the stored result.</p>"
            },
            {
                "name": "Difference between useRef and createRef?",
                "description": "<ul><li><code>createRef</code> will always create a new ref. In a class-based component, you would typically put the ref in an instance property during construction (e.g. <code>this.input = createRef()</code>). You don't have this option in a function component. </li><li><code>useRef</code> takes care of returning the same ref each time as on the initial rendering.</li></ul>"
            },
            {
                "name": "Difference between HTML and React event handling?",
                "description": "<ol> <li>In HTML, the event name should be in lowercase. Whereas in ReactJS it follows camelCase convention,</li><li>In HTML, you can return false to prevent default behavior. Whereas in ReactJS you must call preventDefault explicitly,</li></ol>"
            },
            {
                "name": "Difference between Incremental DOM and Virtual DOM?",
                "description": "<p><strong>Incremental DOM</strong> is a library for building up DOM trees and updating them in-place when data changes. It differs from the established virtual DOM approach in that no intermediate tree is created instead  - the existing tree is mutated in the same place. This approach significantly reduces memory allocation and GC thrashing for incremental updates to the DOM tree therefore increasing performance significantly in some cases.</p><p><strong>Virtual DOM</strong> compares the difference between a new entire virtual DOM with the previous virtual DOM for changes then applies those changes to the actual DOM. - This approach creates a new virtual DOM to determine the changes (memory heavy). Has a big memory footprint because it needs headroom for changes that \"might\" happen to the virtual DOM.</p>"
            },
            {
                "name": "Difference between useEffect and useLayoutEffect?",
                "description": "<p>useLayoutEffect is identical to useEffect, but it's major key difference is that it gets triggered synchronously after all DOM mutation. ... This hook is optimized, to allow the engineer to make changes to a DOM node directly before the browser has a chance to paint.</p><p> The order in which multiple useEffect hooks are executed is de++termined by React and may not be predictable. However, the order in which multiple useLayoutEffect hooks are executed is determined by the order in which they were called.</p><p>useEffect has a built-in mechanism for handling errors that occur during the execution of the effect, so that it does not crash the entire application. useLayoutEffect does not have this mechanism, and errors that occur during the execution of the effect will crash the entire application.</p><p>In general, it's recommended to use useEffect as much as possible, because it is more performant and less prone to errors. useLayoutEffect should only be used when you need to measure or update layout, and you can't achieve the same result using useEffect.</p>"
            },
            {
                "name": "Difference between controlled and uncontrolled components?",
                "description": "<p><strong>They both render form elements</strong></p><p>Uncontrolled components and Controlled components differ in the way they access the data from the form elements</p><ul> <li>A <strong>Controlled Component</strong> is a component that renders form elements and controls them by keeping the form data in the component's state. In a controlled component, the form element's data is handled by the React component (not DOM) and kept in the component's state. A controlled component basically overrides the default behavior of the HTML form elements.<br><img src='./assets/react/uncontrolled.png'></li><li>A <strong>Uncontrolled Component</strong> is a component that renders form elements, where the form element's data is handled by the DOM (default DOM behavior). To access the input's DOM node and extract its value you can use a ref.<br><img src='./assets/react/controlled.png'></li></ul>"
            },
            {
                "name": "Difference between Statefull and Stateless components?",
                "description": "<p>They are also known as: <br>- Container vs Presentational components <br>- Smart vs Dumb components</p><p>That means the stateful components are keeping track of changing data, while stateless components print out what is given to them via props, or they always render the same thing.</p><p>-- A stateless component can render props, whereas a stateful component can render both props and state.<br>-- In stateless components, the props are displayed like {props.name} but in stateful components, the props and state are rendered like {this.props.name} and {this.state.name} respectively.<br>-- A stateless component renders output which depends upon props value, but a stateful component render depends upon the value of the state.<br>-- A functional component is always a stateless component, but the class component can be stateless or stateful.</p><br><img src='./assets/react/state_ful_less.png'>"
            },
            {
                "name": "Difference between a Presentational and Container component?",
                "description": "<ul><li><strong>Presentational components</strong> are concerned with <em>how things look</em>. They generally receive data and callbacks exclusively via props. These components rarely have their own state, but when they do it generally concerns UI state, as opposed to data state.<br><br></li><li><strong>Container components</strong> are more concerned with <em>how things work</em>. These components provide the data and behavior to presentational or other container components. They call Flux actions and provide these as callbacks to the presentational components. They are also often stateful as they serve as data sources.</li></ul>"
            },
            {
                "name": "Difference between functional component and pure component",
                "description": "<p>the Pure Component doesn't re-render because of the props and state in it (actually we don't have any) don't change but the Component and the Functional Component re-renders whenever the parent component re-renders.</p>"
            },
            {
                "name": "Difference between Reference and state",
                "description": "<p>So, the 2 main differences between references and state:</p><ol><li>Updating a reference doesn’t trigger re-rendering, while updating the state makes the component re-render;</li><li>The reference update is synchronous (the updated reference value is available right away), while the state update is asynchronous (the state variable is updated after re-rendering).</li></ol><p>From a higher point of view, references store infrastructure data of side-effects, while the state stores information that is directly rendered on the screen.</p>"
            },
            {
                "name": "Difference between Component and Container in Redux",
                "description": "<ul><li><strong>Component</strong> is part of the React API. A Component is a class or function that describes part of a React UI.</li><li><strong>Container</strong> is an informal term for a React component that is connected to a redux store. Containers receive Redux state updates and dispatch actions, and they usually don't render DOM elements; they delegate rendering to presentational child components.</li></ul>"
            },
            {
                "name": "Difference between Elements and Components in ReactJS?",
                "description": "<p>An <strong>element</strong> is a plain object describing what you want to appear on the screen in terms of the DOM nodes or other components. Elements can contain other elements in their props. Creating a React element is cheap. Once an element is created, it is never mutated. <br><img src='./assets/react/reactElement.png'><br>The above <code>createElement</code> returns as object as below<br><img src='./assets/react/reactElement1.png'><br>And finally it renders to the DOM using <code>ReactDOM.render</code></p><br><p>Whereas a <strong>component</strong> can be declared in several different ways. It can be a class with a <code>render()</code> method. Alternatively, in simple cases, it can be defined as a function. In either case, it takes props as an input, and returns an <code>element</code> tree as the output. JSX transpiled as <code>createElement</code> at the end<br><img src='./assets/react/reactElement3.png'></p>"
            },
            {
                "name": "Difference between constructor and getInitialState?",
                "description": "<p>You should initialize state in the constructor when using ES6 classes, and <code>getInitialState()</code> method when using <code>React.createClass()</code>.<br><img src='./assets/react/constructorinitialstate.png'></p>"
            },
            {
                "name": "What are the limitations of React?",
                "description": "<ol><li>React is just a view library, not a full-blown framework </li><li>There is a learning curve for beginners who are new to web development.</li><li>Integrating React.js into a traditional MVC framework requires some additional configuration</li><li>The code complexity increases with inline templating and JSX.</li><li>Too many smaller components leading to over-engineering or boilerplate</li></ol>"
            },
            {
                "name": "How to bind methods or event handlers in JSX callbacks?",
                "description": "<p>#1. <strong>Binding in Constructor:</strong> In JavaScript classes, the methods are not bound by default. The same thing applies for ReactJS event handlers defined as class methods.<br><img src='./assets/react/eventBind.png'></p><p>#2. <strong>Public class fields syntax:</strong> If you don’t like to use bind approach then public class fields syntax can be used to correctly bind callbacks<br><img src='./assets/react/eventBind1.png'></p><p>#3. <strong>Arrow functions in callbacks:</strong> You can use arrow functions directly in the callbacks<br><img src='./assets/react/eventBind2.png'></p>"
            },
            {
                "name": "What are Error Boundaries in ReactJS?",
                "description": "<p><strong>Error Boundaries:</strong> Error Boundaries basically provide some sort of boundaries or checks on errors, They are React components that are used to handle JavaScript errors in their child component tree.</p><p>React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI. It catches errors during rendering, in lifecycle methods, etc.</p><p><strong>Reason to Use:</strong> Suppose there is an error in JavaScript inside component then it used to corrupt React’s internal state and cause it to emit cryptic errors. Error boundaries help in removing these errors and display a Fallback UI instead(Which means a display of an error that something broke in the code).</p><p>A class component becomes an error boundary if it defines a new lifecycle method called <code>componentDidCatch(error, info)</code><br><img src='./assets/react/errorBoundary.png'><br>After that use it as a regular component<br><img src='./assets/react/errorBoundary1.png'></p>"
            },
            {
                "name": "In which scenarios error boundaries do not catch errors?",
                "description": "<ol><li>Inside Event handlers</li><li>Asynchronous code using <strong>setTimeout or requestAnimationFrame</strong> callbacks</li><li>During Server side rendering</li><li>When errors thrown in the error boundary code itself</li></ol>"
            },
            {
                "name": "Difference between try catch block and error boundaries?",
                "description": "<p>Try catch block works with imperative code whereas error boundaries are meant for declarative code to render on the screen.<br><img src='./assets/react/trycatch.png'></p><p>Whereas error boundaries wrap declarative code as below,<br><img src='./assets/react/errorBoundary2.png'></p><p>So if an error occurs in a <strong>componentDidUpdate</strong> method caused by a <strong>setState</strong> somewhere deep in the tree, it will still correctly propagate to the closest error boundary.</p>"
            },
            {
                "name": "What do these three dots (...) in React do?",
                "description": "<p><strong>Problem</strong> - What does the ... do in this React (using JSX) code and what is it called?<br><img src='./assets/react/3dots.png'></p><p><strong>Answer</strong> - It is known as spread notation. It was added in ES2018 (spread for arrays/iterables was earlier, ES2015). <br>For instance, if this.props contained <code>a: 1</code> and <code>b: 2</code>, then would be same as <br><img src='./assets/react/3dots1.png'></p><p>Spread notation is handy not only for that use case, but for creating a new object with most (or all) of the properties of an existing object — which comes up a lot when you're updating state, since you can't modify state directly:<br><img src='./assets/react/3dots2.png'></p>"
            },
            {
                "name": "What is Components Composition?",
                "description": "<p>Component composition is the name for <strong>passing components as props to other components</strong>, thus creating new components with other components.<br><img src='./assets/react/composition.png'></p>"
            },
            {
                "name": "What does Batching mean?",
                "description": "<p><strong>Batching</strong> is nothing but <strong>grouping React multiple state updates together into a single render state</strong> to achieve better computational performance. Until React 18, we only <em>batched</em> updates during the <em>React event handlers</em>. Updates inside of <code>promises</code>, <code>setTimeout</code>, <em>native event handlers</em>, or any other event were not <em>batched</em> in React by default.<br><img src='./assets/react/batching.png'></p><p>Advantages of Batching</p><ul><li><strong>Batching</strong> is great for <em>performance</em> because it avoids unnecessary re-renders.</li><li><strong>Batching</strong> also <em>prevents</em> your component from <em>rendering</em> half-finished states where only one state variable was updated, which may cause bugs.</li><li>Another reason to use <strong>batching</strong> is when the web application grows, the number of nested components will increase. Therefore, if a parent component executes an <em>unbatched state updated</em>, the <em>entire component tree will be re-rendered per state update</em> that is expensive.</li></ul>"
            },
            {
                "name": "Which lifecycle methods of class component is replaced by useEffect in functional component?",
                "description": "<p>The lifecyce methods replaced by <code>useEffect</code> Hooks of functional component are <em><code>componentDidMount()</code>, <code>componentDidUpdate()</code>, and <code>componentWillUnmount()</code></em></p><p>#1. componentDidMount: is equivalent for running an effect once. <br><img src='./assets/react/useEffect.png'><br><strong>Note</strong> - empty array = useEffect hook runs once on mount</p><p>#2. componentDidUpdate: is equivalent for running effects when things change <br><img src='./assets/react/useEffect1.png'></p><p>#3. componentWillUnmount: To run a hook as the component is about to unmount, we just have to return a function from the useEffect Hook <br><img src='./assets/react/useEffect2.png'></p>"
            },
            {
                "name": "Compare useState and useReducer implementations",
                "description": "<ul><li><code>useState</code> updates state with <code>setState</code>, while <code>useReducer</code> with <em>dispatch function</em>.</li><li><code>useState</code> passes down all the <code>setState</code> custom helper functions, while <code>useReducer</code> passes down just the <em>dispatch function</em>.</li><li><code>useState</code> needs to wrap functions in <code>useCallback</code>(if we want to memorize them), while <em>dispatch function</em> is already <strong>memorized</strong>.</li><li><code>useState</code> easier to write, <code>useReducer</code> is harder to implement and needs more logic to be coded.</li></ul>"
            },
            {
                "name": "Describe Flux vs MVC?",
                "description": "<p>Traditional MVC patterns have worked well for separating the concerns of data (Model), UI (View) and logic (Controller) — but MVC architectures frequently encounter two main problems:</p><ul><li><strong>Poorly defined data flow:</strong> The cascading updates which occur across views often lead to a tangled web of events which is difficult to debug.</li><li><strong>Lack of data integrity:</strong> Model data can be mutated from anywhere, yielding unpredictable results across the UI.</li></ul><p>With the Flux pattern complex UIs no longer suffer from cascading updates; any given React component will be able to reconstruct its state based on the data provided by the store. The Flux pattern also enforces data integrity by restricting direct access to the shared data.</p>"
            },
            {
                "name": "Can you force a React component to rerender without calling setState?",
                "description": "<p>In your component, you can call <code>this.forceUpdate()</code> to force a rerender. Another way is this.setState(this.state);</p><p>Note that <code>forceUpdate</code> should be avoided because it deviates from a React mindset. The React docs cite an example of when <code>forceUpdate</code> might be used:</p><p>By default, when your component's state or props change, your component will re-render. However, if these change implicitly (eg: data deep within an object changes without changing the object itself) or if your render() method depends on some other data, you can tell React that it needs to re-run render() by calling forceUpdate().</p>"
            },
            {
                "name": "Does React re-render all components and sub components every time setState is called?",
                "description": "<p>By default - <strong>yes</strong>.</p><p>There is a method boolean <code>shouldComponentUpdate(object nextProps, object nextState)</code>, each component has this method and it's responsible to determine \"should component update (run render function)?\" every time you change state or pass new props from parent component.</p><p>You can write your own implementation of <code>shouldComponentUpdate</code> method for your component, but default implementation always returns true - meaning always re-run render function.</p>"
            },
            {
                "name": "What is the second argument that can optionally be passed to setState and what is its purpose?",
                "description": "<p>A callback function which will be invoked when <code>setState</code> has finished and the component is re-rendered.</p><p>Something that’s not spoken of a lot is that <code>setState</code> is asynchronous, which is why it takes in a second callback function. Typically it’s best to use another lifecycle method rather than relying on this callback function, but it’s good to know it exists.</p><p><img src='./assets/react/setState.png'></p>"
            },
            {
                "name": "When would you use flushSync in ReactJS?",
                "description": "<p>React 18 adds out-of-the-box performance improvements by doing more <strong>batching</strong> (automated) by default. Batching is when React groups multiple state updates into a single re-render for better performance.</p><ul><li>To <em>opt-out</em> of automatic batching, you can use <code>flushSync</code> so your component will be re-rendered after each state update. You might need it when for example some code may depend on <em>reading</em> something from the <em>DOM immediately</em> after a state change.</li></ul><p>Consider with automated batching:<br><img src='./assets/react/batching.png'></p><p>Consider with <code>flushSync</code>:<br><img src='./assets/react/flushSync.png'></p>"
            },
            {
                "name": "When to use useState vs useReducer?",
                "description": "<p>use <code>useState</code> if you have: </p><ul><li>JavaScript <em>primitives</em> as state</li><li><em>Simple</em> state transitions</li><li>Business logic within your component</li><li>Different properties that <em>don't change</em> in any correlated way and can be managed by multiple <code>useState</code> hooks</li></ul><p>use <code>useReducer</code> if you have:</p><ul><li>JavaScript <em>objects</em> or <em>arrays</em> as state</li><li><em>Complex</em> state transitions</li><li><em>Complicated</em> business logic more suitable for a reducer function (to separate concern of it)</li><li>Different properties tied together that should be managed in one state object (when state depends on state)</li></ul>"
            },
            {
                "name": "When shall we use useReducer hook in ReactJS?",
                "description": "<p><code>useReducer</code> is an alternative to <code>useState</code>. <code>useReducer</code> is usually preferable to <code>useState</code> when you have complex state logic that involves <strong>multiple</strong> sub-values or when the next state <em>depends</em> on the previous one. </p><p>An example will be a list of items, where you need to add, update and remove items in the state, Here you might have noticed that the state management logic takes a good part of the component body. <code>useReducer</code> helps to separate the concerns of rendering vs a concern of state management.<br><img src='./assets/react/usereducer.png'></p>"
            },
            {
                "name": "What is React Fiber?",
                "description": "<p>React Fiber is an ongoing reimplementation of React's core algorithm. The main difference between react and react fiber are these new features :-</p><ol><li><strong>Incremental Rendering :-</strong> React v16.0 includes a completely rewritten server renderer. It’s really fast. It supports streaming, so you can start sending bytes to the client faster</li><li><strong>Handle errors in the render API :</strong> To make class component an error boundary we define a new lifecycle method called componentDidCatch(error, info).</li><li><strong>Return multiple elements from render</strong> : With this new feature in React v16.0 now we can also return an array of elements, and string from component’s render method.</li><li><strong>Portals</strong> : Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.</li><li><strong>Fragments</strong> : A common pattern in React is for a component to return multiple elements. Fragments let you group a list of children without adding extra nodes to the DOM.</li></ol>"
            },
            {
                "name": "How to avoid the need for binding in React?",
                "description": "<p>#1. Define Your Event Handler as an Inline Arrow Function <br><img src='./assets/react/eventBind3.png'></p><p>#2. Define Your Event Handler as an Arrow Function Assigned to a Class Field<br><img src='./assets/react/eventBind4.png'></p><p>#3. Use a Function Component with Hooks<br><img src='./assets/react/eventBind5.png'></p>"
            },
            {
                "name": "Difference between React vs Angular",
                "description": "<p>React is better than Angular due to it's virtual DOM implementation and rendering optimizations. Migrating between React's versions is quite easy, too; you don't need to install updates one by one, as in the case of Angular.</p><p>Angular is a TypeScript-based web application framework, whereas React JS is a JavaScript-based library.</p><p>Angular is used to build single-page applications using HTML and TypeScript. React JS is commonly used to create user interfaces for single-page applications from isolated components.</p><p>Using a library such as React can give a project a greater ability to evolve parts of the system—again for example, state management—over time, when new solutions are created by the open source community.</p>"
            },
            {
                "name": "What is the order of useInsertionEffect, useEffect and useLayoutEffect hooks at component generation",
                "description": "<p><code>useInsertionEffect</code> - It fires synchronously <strong>before</strong> all DOM mutations. Use this to inject styles into the DOM <strong>before</strong> reading layout in <code>useLayoutEffect</code>. So it runs before <code>useLayoutEffect</code>.</p><p><code>useLayoutEffect</code> - It fires synchronously <strong>after</strong> all DOM mutations. Use this to read layout from the DOM and synchronously re-render.</p><p><code>useEffect</code> - It will run after the render is committed to the screen. So it runs after <code>useLayoutEffect</code>.</p><p>Therefore the order of running is:</p><ol><li>useInsertionEffect</li><li>useLayoutEffect</li><li>useEffect</li></ol>"
            },
            {
                "name": "Example of any simple Custom React Hook",
                "description": "<p>A <strong>Custom</strong> Hook is a <strong>stateful function</strong> that uses other react built-in hooks (e.g. <code>useState</code>, <code>useCallback</code> etc.) that can wrap around the <em>stateful</em> logic that you wanted to gather in one place and <em>avoid copying and pasting the same logic</em> in multiple components.</p><p>Consider the increment/decriment custom hook:<br><img src='./assets/react/customHook.png'><br>and then in your component you can use it as follows:<br><img src='./assets/react/customHook1.png'></p>"
            },
            {
                "name": "Can a custom React hook return JSX?",
                "description": "<p>While there is no hardcore restriction on how you should define custom hooks and what logic should contain, it's an anti-pattern to write hooks that return JSX.</p><p>There are a few downsides to using hooks to return JSX</p><ul><li>When you write a hook that returns JSX component, you are essentially defining the component within the functional component, so on each and every re-render you will be creating a new instance of the component. This will lead to the component being unmounted and mounted again. This is bad for performance and also buggy if you have stateful login within the component as the state will get reset with every re-render of the parent</li><li>By defining a JSX component within the hook, you are taking away the option of lazy loading your component if the need be.</li><li>Any performance optimization to the component will require you to make use of <code>useMemo</code> which doesn't give you the flexibility of a custom comparator function like <code>React.memo()</code></li></ul><p>The benefit on the other hand is that you have control over the state of the component in the parent. However, you can still implement the same logic by using a controlled component approach</p>"
            },
            {
                "name": "How to mitigate multiple component re-renders when using multiple useState calls?",
                "description": "<p><strong>Problem</strong> - When I get data and update two different state variables (data and loading flag), my component (a data table) is rendered twice, even though both calls to the state updater are happening in the same function. Any ideas on how to mitigate this? <br><img src='./assets/react/problem2.png'></p><br><p><strong>Answer</strong> - </p><p>#1. You could combine the loading state and data state into one state object and then you could do one setState call and there will only be one render. <br><img src='./assets/react/solution1.png'></p><p>#2. Before React 18, React will batch state updates if they're triggered from within a React-based event, like a button click or input change. It will not batch updates if they're triggered outside of a React event handler, like an async call.</p><p>#3. Starting in React 18 (opt-in feature) all updates will be automatically batched, no matter where they originate from.</p>"
            },
            {
                "name": "How would you optimise this code using one of the React Hooks?",
                "description": "<p><strong>Problem</strong> - Consider this code. Imagine there are 100000 of users. Do you see any optimization we can make? <br><img src='./assets/react/optimize.png'><br><img src='./assets/react/optimize1.png'><br><img src='./assets/react/optimize2.png'></p><br><p><strong>Answer</strong> - </p><p>Even though the <code>filteredUsers</code> don't change when someone types into the input field, because they change only when clicking the button via the <code>search</code> state, the filter's callback function runs again and again for every keystroke in the input field.<br><img src='./assets/react/optimize3.png'></p><p>This doesn't slow down this small React application. However, if we would deal with a large set of data in this array and run the filter's callback function for every keystroke, we would maybe slow down the application.</p><p>you can use React's useMemo Hook to <strong>memoize a functions return value(s)</strong> and to run a function only if its dependencies (here <code>search</code>) have changed:<br><img src='./assets/react/optimize4.png'></p>"
            },
            {
                "name": "What is ReactDOMServer?",
                "description": "<p>The <code>ReactDOMServer</code> object enables you to render components to static markup (typically used on node server). This object is mainly used for <em>server-side rendering</em> (SSR). The following methods can be used in both the server and browser environments:</p><ol><li><code>renderToString()</code></li><li><code>renderToStaticMarkup()</code></li></ol><p>For example, you generally run a Node-based web server like Express, Hapi, or Koa, and you call <code>renderToString</code> to render your root component to a string, which you then send as response.<br><img src='./assets/react/renderToString.png'></p>"
            },
            {
                "name": "How you implement Server Side Rendering or SSR?",
                "description": "<p>React is already equipped to handle rendering on Node servers. A special version of the DOM renderer is available, which follows the same pattern as on the client side.<br><img src='./assets/react/renderToString1.png'></p><p>This method will output the regular HTML as a string, which can be then placed inside a page body as part of the server response. On the client side, React detects the pre-rendered content and seamlessly picks up where it left off.</p>"
            },
            {
                "name": "How to enable production/build mode in React?",
                "description": "<p>Run the following command to serve the build version in a static server. <br>npm install -g serve <br>serve -s build</p><br><p><strong>Using Webpack</strong> - Webpack is one of the most popular choices when it comes to creating production build. If you are configuring webpack directly, make use of the TenserPlugin. <br><img src='./assets/react/webpack.png'></p><br><p><strong>Reactjs build directory</strong> - build command <strong>npm run build</strong><br><img src='./assets/react/build.png'></p><p>Firstly, inside the build directory we have the <strong>static </strong>folder. This <strong>build/static</strong> folder contains your CSS, JS and media files.</p><p>Files within the <strong>build/static </strong>folder, has a unique hash is appended to the file name. This hash code is generated based on the contents of the file itself, i.e., if the contents of the file change in the next build, the hash code (hence, the filename) will also change.</p><p>Therefore, the hash will be useful for enabling long term caching techniques. For example, on page reloading, the hashing will prevent re-downloading of all the assets if the contents of your file haven’t changed.</p><p>Many .js files are generated and placed inside the <strong>build/static/js </strong>directory. These are called <strong>chunks</strong>. <br><img src='./assets/react/chunk.png'></p><p>Your application code within <strong>App.js</strong> will be placed inside the following file.<br><img src='./assets/react/main.png'></p>"
            },
            {
                "name": "What is the recommended ordering of methods in component class?",
                "description": "<p><em>Recommended</em> ordering of methods from <em>mounting</em> to <em>render stage</em>:</p><ol><li><code>static</code> methods</li><li><code>constructor()</code></li><li><code>getChildContext()</code></li><li><code>componentWillMount()</code></li><li><code>componentDidMount()</code></li><li><code>componentWillReceiveProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><code>componentWillUpdate()</code></li><li><code>componentDidUpdate()</code></li><li><code>componentWillUnmount()</code></li><li>click handlers or event handlers like <code>onClickSubmit()</code> or <code>onChangeDescription()</code></li><li>getter methods for render like <code>getSelectReason()</code> or <code>getFooterContent()</code></li><li>optional render methods like <code>renderNavigation()</code> or <code>renderProfilePicture()</code></li><li><code>render()</code></li></ol>"
            },
            {
                "name": "What is a switching component?",
                "description": "<p>A <em>switching component</em> is a component that renders one of many components. We need to use object to map prop values to components.<br><img src='./assets/react/switchingComponent.png'></p>"
            },
            {
                "name": "Difference between super() and super(props) in React using ES6 classes?",
                "description": "<p>When you want to access <code>this.props</code> in <code>constructor()</code> then you should pass props to <code>super()</code> method.</p><p><strong>Using <code>super(props)</code>:</strong><br><img src='./assets/react/propspassing.png'></p><p><strong>Using <code>super()</code>:</strong><br><img src='./assets/react/propsnotpassing.png'></p><p>Outside <code>constructor()</code> both will display same value for <code>this.props</code>.</p>"
            },
            {
                "name": "Difference between React and ReactDOM?",
                "description": "<p>The <code>react</code> package contains <code>React.createElement()</code>, <code>React.Component</code>, <code>React.Children</code>, and other helpers related to elements and component classes. You can think of these as the isomorphic or universal helpers that you need to build components. The <code>react-dom</code> package contains <code>ReactDOM.render()</code>, and in <code>react-dom/server</code> we have <em>server-side rendering</em> support with <code>ReactDOMServer.renderToString()</code> and <code>ReactDOMServer.renderToStaticMarkup()</code>.</p>"
            },
            {
                "name": "Difference between setState() and replaceState() methods?",
                "description": "<p>When you use <code>setState()</code> the current and previous states are merged. <code>replaceState()</code> throws out the current state, and replaces it with only what you provide. Usually <code>setState()</code> is used unless you really need to remove all previous keys for some reason. You can also set state to <code>false</code>/<code>null</code> in <code>setState()</code> instead of using <code>replaceState()</code>.</p>"
            },
            {
                "name": "How to listen to state changes?",
                "description": "<p>The <code>componentDidUpdate</code> lifecycle method will be called when state changes. You can compare provided state and props values with current state and props to determine if something meaningful changed.</p><p><code>componentDidUpdate(object prevProps, object prevState)</code></p><p><strong>Note:</strong> The previous releases of ReactJS also uses <code>componentWillUpdate(object nextProps, object nextState)</code> for state changes. It has been deprecated in latest releases.</p>"
            },
            {
                "name": "How to focus an input element on page load?",
                "description": "<p>You can do it by creating <em>ref</em> for <code>input</code> element and using it in <code>componentDidMount()</code>:<br><img src='./assets/react/focus.png'></p>"
            },
            {
                "name": "How to avoid using relative path imports in create-react-app?",
                "description": "<p>Create a file called <code>.env</code> in the project root and write the import path:</p><p><code>NODE_PATH=src/app</code></p><p>After that restart the development server. Now you should be able to import anything inside <code>src/app</code> without relative paths.</p>"
            },
            {
                "name": "How to add Google Analytics for React Router?",
                "description": "<p>Add a listener on the <code>history</code> object to record each page view:</p><p><img src='./assets/react/ga.png'></p>"
            },
            {
                "name": "What is React Intl?",
                "description": "<p>The <em>React Intl</em> library makes internationalization in React straightforward, with off-the-shelf components and an API that can handle everything from formatting strings, dates, and numbers, to pluralization. React Intl is part of <em>FormatJS</em> which provides bindings to React via its components and API.</p>"
            },
            {
                "name": "What are the two ways of formatting in React Intl?",
                "description": "<p>The library provides two ways to format strings, numbers, and dates:</p><ol><li><strong>Using react components:</strong><br><img src='./assets/react/format.png'></li><li><strong>Using an API:</strong><br><img src='./assets/react/format1.png'></li></ol>"
            },
            {
                "name": "How to use <code>&lt;FormattedMessage&gt;</code> as placeholder using React Intl?",
                "description": "<p>The <code>&lt;Formatted... /&gt;</code> components from <code>react-intl</code> return elements, not plain text, so they can't be used for placeholders, alt text, etc. In that case, you should use lower level API <code>formatMessage()</code>. You can inject the <code>intl</code> object into your component using <code>injectIntl()</code> higher-order component and then format the message using <code>formatMessage()</code> available on that object.<br><img src='./assets/react/formatmessage.png'></p>"
            },
            {
                "name": "How to access current locale with React Intl?",
                "description": "<p><strong>using injectIntl()</strong><br><img src='./assets/react/currentlocale.png'></p>"
            },
            {
                "name": "What are the core principles of Redux?",
                "description": "<ol><li><strong>Single source of truth:</strong> The state of your whole application is stored in an object tree within a single store. The single state tree makes it easier to keep track of changes over time and debug or inspect the application.</li><li><strong>State is read-only:</strong> The only way to change the state is to emit an action, an object describing what happened. This ensures that neither the views nor the network callbacks will ever write directly to the state.</li><li><strong>Changes are made with pure functions:</strong> To specify how the state tree is transformed by actions, you write reducers. Reducers are just pure functions that take the previous state and an action as parameters, and return the next state.</li></ol>"
            },
            {
                "name": "What's the typical flow of data like in a React + Redux app?",
                "description": "<p>Callback from UI component dispatches an action with a payload, which then is intercepted in a reducer, possibly producing a new application state, which is then propagated down through the tree of components in the application from the Redux store.</p>"
            },
            {
                "name": "What are the downsides of Redux compared to Flux?",
                "description": "<p>Instead of saying downsides we can say that there are few compromises of using Redux over Flux. Those are as follows:</p><ol><li><strong>You will need to learn to avoid mutations:</strong> Flux is un-opinionated about mutating data, but Redux doesn't like mutations and many packages complementary to Redux assume you never mutate the state. You can enforce this with dev-only packages like <code>redux-immutable-state-invariant</code>, Immutable.js, or instructing your team to write non-mutating code.</li><li><strong>You're going to have to carefully pick your packages:</strong> While Flux explicitly doesn't try to solve problems such as undo/redo, persistence, or forms, Redux has extension points such as middleware and store enhancers, and it has spawned a rich ecosystem.</li><li><strong>There is no nice Flow integration yet:</strong> Flux currently lets you do very impressive static type checks which Redux doesn't support yet.</li></ol>"
            },
            {
                "name": "Difference between mapStateToProps() and mapDispatchToProps()",
                "description": "<p><code>mapStateToProps()</code> is a utility which helps your component get updated state (which is updated by some other components):<br><img src='./assets/react/mapStateToProps.png'></p><p><code>mapDispatchToProps()</code> is a utility which will help your component to fire an action event (dispatching action which may cause change of application state):<br><img src='./assets/react/mapDispatchToProps.png'></p><p>It is recommended to always use the “object shorthand” form for the <code>mapDispatchToProps</code>.</p><p>Redux wraps it in another function that looks like (…args) =&gt; dispatch(onTodoClick(…args)), and pass that wrapper function as a prop to your component.<br><img src='./assets/react/mapDispatchToProps1.png'></p>"
            },
            {
                "name": "What are the drawbacks of MVW pattern?",
                "description": "<ol><li>DOM manipulation is very expensive which causes applications to behave slow and inefficient.</li><li>Due to circular dependencies, a complicated model was created around models and views.</li><li>Lot of data changes happens for collaborative applications(like Google Docs).</li><li>No way to do undo (travel back in time) easily without adding so much extra code.</li></ol>"
            },
            {
                "name": "Are there any similarities between Redux and RxJS?",
                "description": "<p>These libraries are very different for very different purposes, but there are some vague similarities.</p><p>Redux is a tool for managing state throughout the application. It is usually used as an architecture for UIs. Think of it as an alternative to (half of) Angular. RxJS is a reactive programming library. It is usually used as a tool to accomplish asynchronous tasks in JavaScript. Think of it as an alternative to Promises. Redux uses the Reactive paradigm because the Store is reactive. The Store observes actions from a distance, and changes itself. RxJS also uses the Reactive paradigm, but instead of being an architecture, it gives you basic building blocks, Observables, to accomplish this pattern.</p>"
            },
            {
                "name": "How to use connect() from React Redux?",
                "description": "<p>You need to follow two steps to use your store in your container:</p><ol><li><strong>Use <code>mapStateToProps()</code>:</strong> It maps the state variables from your store to the props that you specify.</li><li><strong>Connect the above props to your container:</strong> The object returned by the <code>mapStateToProps</code> function is connected to the container. You can import <code>connect()</code> from <code>react-redux</code>.<br><img src='./assets/react/connect.png'></li></ol>"
            },
            {
                "name": "How to reset state in Redux?",
                "description": "<p>You need to write a <em>root reducer</em> in your application which will handle the action to the reducer generated by <code>combineReducers()</code>.</p><p>For example, let us take <code>rootReducer()</code> to return the initial state after <code>USER_LOGOUT</code> action. As we know, reducers are supposed to return the initial state when they are called with <code>undefined</code> as the first argument, no matter the action. <br><img src='./assets/react/rootreducer.png'></p><p>In case of using <code>redux-persist</code>, you may also need to clean your storage. <code>redux-persist</code> keeps a copy of your state in a storage engine. First, you need to import the appropriate storage engine and then, to parse the state before setting it to undefined and clean each storage state key.<br><img src='./assets/react/rootreducer1.png'></p>"
            },
            {
                "name": "Difference Between Context API and Redux",
                "description": "<p>You can use <strong>Context</strong> in your application directly and is going to be great for passing down data to deeply nested components which what it was designed for. Using context, we can avoid passing props through intermediate elements.</p><p>Whereas <strong>Redux</strong> is much more powerful and provides a large number of features that the Context API doesn't provide. Also, React Redux uses context internally but it doesn't expose this fact in the public API.</p>"
            },
            {
                "name": "Difference between component and container in React Redux?",
                "description": "<p><strong>Component</strong> is a class or function component that describes the presentational part of your application.</p><p><strong>Container</strong> is an informal term for a component that is connected to a Redux store. Containers <em>subscribe</em> to Redux state updates and <em>dispatch</em> actions, and they usually don't render DOM elements; they delegate rendering to presentational child components.</p>"
            },
            {
                "name": "How to structure Redux top level directories?",
                "description": "<ol><li><strong>Components</strong>: Used for <em>dumb</em> components unaware of Redux.</li><li><strong>Containers</strong>: Used for <em>smart</em> components connected to Redux.</li><li><strong>Actions</strong>: Used for all action creators, where file names correspond to part of the app.</li><li><strong>Reducers</strong>: Used for all reducers, where files name correspond to state key.</li><li><strong>Store</strong>: Used for store initialization.</li></ol>"
            },
            {
                "name": "What is redux-saga ?",
                "description": "<p><code>redux-saga</code> is a library that aims to make side effects (asynchronous things like data fetching and impure things like accessing the browser cache) in React/Redux applications easier and better.<br><code>npm install --save redux-saga</code></p>"
            },
            {
                "name": "What is the mental model of redux-saga?",
                "description": "<p><em>Saga</em> is like a separate thread in your application, that's solely responsible for side effects. <code>redux-saga</code> is a redux <em>middleware</em>, which means this thread can be started, paused and cancelled from the main application with normal Redux actions, it has access to the full Redux application state and it can dispatch Redux actions as well.</p>"
            },
            {
                "name": "Differences between call() and put() in redux-saga?",
                "description": "<p>Both <code>call()</code> and <code>put()</code> are effect creator functions. <code>call()</code> function is used to create effect description, which instructs middleware to call the promise. <code>put()</code> function creates an effect, which instructs middleware to dispatch an action to the store.</p><img src='./assets/react/saga.png'>"
            },
            {
                "name": "What is Redux Thunk?",
                "description": "<p><em>Redux Thunk</em> middleware allows you to write action creators that return a function instead of an action. The thunk can be used to delay the dispatch of an action, or to dispatch only if a certain condition is met. The inner function receives the store methods <code>dispatch()</code> and <code>getState()</code> as parameters.</p>"
            },
            {
                "name": "Differences between redux-saga and redux-thunk?",
                "description": "<p>Both <em>Redux Thunk</em> and <em>Redux Saga</em> take care of dealing with side effects. In most of the scenarios, Thunk uses <em>Promises</em> to deal with them, whereas Saga uses <em>Generators</em>. Thunk is simple to use and Promises are familiar to many developers, Sagas/Generators are more powerful but you will need to learn them. But both middleware can coexist, so you can start with Thunks and introduce Sagas when/if you need them.</p>"
            },
            {
                "name": "What are Redux selectors and why to use them?",
                "description": "<p><em>Selectors</em> are functions that take Redux state as an argument and return some data to pass to the component.<br><img src='./assets/react/userstate.png'></p><p>These selectors have two main benefits,</p><ol><li>The selector can compute derived data, allowing Redux to store the minimal possible state</li><li>The selector is not recomputed unless one of its arguments changes</li></ol>"
            },
            {
                "name": "What is Redux Form?",
                "description": "<p><em>Redux Form</em> works with React and Redux to enable a form in React to use Redux to store all of its state. Redux Form can be used with raw HTML5 inputs, but it also works very well with common UI frameworks like Material UI, React Widgets and React Bootstrap.</p><p>Some of the main features of Redux Form are:</p><ol><li>Field values persistence via Redux store.</li><li>Validation (sync/async) and submission.</li><li>Formatting, parsing and normalization of field values.</li></ol>"
            },
            {
                "name": "How to add multiple middlewares to Redux?",
                "description": "<p>You can use <code>applyMiddleware</code> where you can pass each piece of middleware as a new argument. So you just need to pass each piece of middleware you'd like. For example, you can add Redux Thunk and logger middlewares as an argument as below,<br><img src='./assets/react/applyMiddleware.png'></p>"
            },
            {
                "name": "How to set initial state in Redux?",
                "description": "<p>You need to pass initial state as second argument to createStore:<br><img src='./assets/react/createStore.png'></p>"
            },
            {
                "name": "How Relay is different from Redux?",
                "description": "<p>Relay is similar to Redux in that they both use a single store. The main difference is that relay only manages state originated from the server, and all access to the state is used via <em>GraphQL</em> queries (for reading data) and mutations (for changing data). Relay caches the data for you and optimizes data fetching for you, by fetching only changed data and nothing more.</p>"
            },
            {
                "name": "What is an action in Redux?",
                "description": "<p><em>Actions</em> are plain JavaScript objects or payloads of information that send data from your application to your store. They are the only source of information for the store. Actions must have a type property that indicates the type of action being performed.<br>{&nbsp;&nbsp;type: ADD_TODO,&nbsp;&nbsp;text: 'Add todo &nbsp;&nbsp;item'&nbsp;&nbsp;}</p>"
            },
            {
                "name": "What is render hijacking in react?",
                "description": "<p>The concept of render hijacking is the ability to control what a component will output from another component. It means that you decorate your component by wrapping it into a Higher-Order component. By wrapping, you can inject additional props or make other changes, which can cause changing logic of rendering. It does not actually enable hijacking, but by using HOC you make your component behave differently.</p>"
            },
            {
                "name": "What are HOC factory implementations?",
                "description": "<p>There are two main ways of implementing HOCs in React.</p><ol><li>Props Proxy (PP) and</li><li>Inheritance Inversion (II).</li></ol><p>But they follow different approaches for manipulating the <em>WrappedComponent</em>.</p><p><strong>Props Proxy</strong> - In this approach, the render method of the HOC returns a React Element of the type of the WrappedComponent. We also pass through the props that the HOC receives, hence the name Props Proxy.<br><img src='./assets/react/pphoc.png'></p><p><strong>Inheritance Inversion</strong> - In this approach, the returned HOC class (Enhancer) extends the WrappedComponent. It is called Inheritance Inversion because instead of the WrappedComponent extending some Enhancer class, it is passively extended by the Enhancer. In this way the relationship between them seems inverse.<br><img src='./assets/react/iihoc.png'></p>"
            },
            {
                "name": "Do I need to keep all my state into Redux? Should I ever use react internal state?",
                "description": "<p>It is up to the developer's decision, i.e., it is developer's job to determine what kinds of state make up your application, and where each piece of state should live. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as “is this dropdown currently open”, inside a component's internal state.</p><p>Below are the thumb rules to determine what kind of data should be put into Redux</p><ol><li>Do other parts of the application care about this data?</li><li>Do you need to be able to create further derived data based on this original data?</li><li>Is the same data being used to drive multiple components?</li><li>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</li><li>Do you want to cache the data (i.e, use what's in state if it's already there instead of re-requesting it)?</li></ol>"
            },
            {
                "name": "What is the purpose of registerServiceWorker in React?",
                "description": "<p>React creates a service worker for you without any configuration by default. The service worker is a web API that helps you cache your assets and other files so that when the user is offline or on a slow network, he/she can still see results on the screen, as such, it helps you build a better user experience, that's what you should know about service worker for now. It's all about adding offline capabilities to your site.</p>"
            },
            {
                "name": "What are the possible return types of render method?",
                "description": "<ol><li><strong>React elements:</strong> Elements that instruct React to render a DOM node. It includes html elements such as <code>&lt;div/&gt;</code> and user defined elements.</li><li><strong>Arrays and fragments:</strong> Return multiple elements to render as Arrays and Fragments to wrap multiple elements</li><li><strong>Portals:</strong> Render children into a different DOM subtree.</li><li><strong>String and numbers:</strong> Render both Strings and Numbers as text nodes in the DOM</li><li><strong>Booleans or null:</strong> Doesn't render anything but these types are used to conditionally render content.</li></ol>"
            },
            {
                "name": "Prevent or stop a function from being called multiple times?",
                "description": "<ol><li><strong>Throttling:</strong> Changes based on a time based frequency. For example, it can be used using _.throttle lodash function</li><li><strong>Debouncing:</strong> Publish changes after a period of inactivity. For example, it can be used using _.debounce lodash function</li><li><strong>RequestAnimationFrame throttling:</strong> Changes based on requestAnimationFrame. For example, it can be used using raf-schd lodash function</li></ol>"
            },
            {
                "name": "How JSX prevents Injection Attacks?",
                "description": "<p>React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered.<br><img src='./assets/react/injectionattack.png'></p>"
            },
            {
                "name": "What are loadable components?",
                "description": "<p>If you want to do code-splitting in a server rendered app, it is recommend to use Loadable Components because React.lazy and Suspense is not yet available for server-side rendering. Loadable lets you render a dynamic import as a regular component.</p><img src='./assets/react/loadable.png'><p>Now OtherComponent will be loaded in a separated bundle</p>"
            },
            {
                "name": "What is suspense component?",
                "description": "<p>If the module containing the dynamic import is not yet loaded by the time parent component renders, you must show some fallback content while you’re waiting for it to load using a loading indicator. This can be done using <strong>Suspense</strong> component.<br><img src='./assets/react/suspense.png'></p>"
            },
            {
                "name": "What is route based code splitting?",
                "description": "<p>One of the best place to do code splitting is with routes. The entire page is going to re-render at once so users are unlikely to interact with other elements in the page at the same time. Due to this, the user experience won't be disturbed.<br><img src='./assets/react/splitting.png'></p>"
            },
            {
                "name": "What are the problems of using render props with pure components?",
                "description": "<p>If you create a function inside a render method, it negates the purpose of pure component. Because the shallow prop comparison will always return false for new props, and each render in this case will generate a new value for the render prop. You can solve this issue by defining the render function as instance method.</p>"
            },
            {
                "name": "How do you create HOC using render props?",
                "description": "<p>You can implement most higher-order components (HOC) using a regular component with a render prop. For example, if you would prefer to have a withMouse HOC instead of a  component, you could easily create one using a regular  with a render prop.<br><img src='./assets/react/renderhoc.png'></p>"
            },
            {
                "name": "What is windowing technique?",
                "description": "<p>Windowing is a technique that only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created. If your application renders long lists of data then this technique is recommended. Both react-window and react-virtualized are popular windowing libraries which provides several reusable components for displaying lists, grids, and tabular data.</p>"
            },
            {
                "name": "What is formik?",
                "description": "<p>Formik is a small react form library that helps you with the three major problems,</p><ol><li>Getting values in and out of form state</li><li>Validation and error messages</li><li>Handling form submission</li></ol>"
            },
            {
                "name": "What is Concurrent Rendering?",
                "description": "<p>The Concurrent rendering makes React apps to be more responsive by rendering component trees without blocking the main UI thread. It allows React to interrupt a long-running render to handle a high-priority event. i.e, When you enabled concurrent Mode, React will keep an eye on other tasks that need to be done, and if there's something with a higher priority it will pause what it is currently rendering and let the other task finish first. You can enable this in two ways,<br><img src='./assets/react/concurrent.png'></p>"
            },
            {
                "name": "Difference between Imperative and Declarative in React?",
                "description": "<p>The imperative way of doing this would be:<br><img src='./assets/react/imperative.png'></p><p>The declarative approach would be:<br><img src='./assets/react/declartive.png'></p>"
            },
            {
                "name": "What are the benefits of using typescript with reactjs?",
                "description": "<ol><li>It is possible to use latest JavaScript features</li><li>Use of interfaces for complex type definitions</li><li>IDEs such as VS Code was made for TypeScript</li><li>Avoid bugs with the ease of readability and Validation</li></ol>"
            },
            {
                "name": "How do you make sure that user remains authenticated on page refresh while using Context API State Management?",
                "description": "<p>When a user logs in and reload, to persist the state generally we add the load user action in the useEffect hooks in the main App.js. While using Redux, loadUser action can be easily accessed.</p><p><strong>App.js</strong><br><img src='./assets/react/loaduser.png'></p><p>But while using <strong>Context API</strong>, to access context in App.js, wrap the AuthState in index.js so that App.js can access the auth context. Now whenever the page reloads, no matter what route you are on, the user will be authenticated as <strong>loadUser</strong> action will be triggered on each re-render.</p><p><strong>index.js</strong><br><img src='./assets/react/authstate.png'></p><p><strong>App.js</strong><br><img src='./assets/react/loaduser1.png'></p><p><strong>loadUser</strong><br><img src='./assets/react/loaduser2.png'></p>"
            },
            {
                "name": "What is state mutation and how to prevent it?",
                "description": "<p><code>State mutation</code> happens when you try to update the state of a component without actually using <code>setState</code> function. This can happen when you are trying to do some computations using a state variable and unknowingly save the result in the same state variable. This is the main reason why it is advised to return new instances of state variables from the reducers by using Object.assign({}, ...) or spread syntax.</p><p>This can cause unknown issues in the UI as the value of the state variable got updated without telling React to check what all components were being affected from this update and it can cause UI bugs.<br><img src='./assets/react/statemutation.png'></p><p><strong>How to prevent it:</strong> Make sure your state variables are immutable by either enforcing immutability by using plugins like Immutable.js, always using <code>setState</code> to make updates, and returning new instances in reducers when sending updated state values.</p>"
            },
            {
                "name": "What is wrong with using Context in React",
                "description": "<ul><li>Context is primarily used when some data needs to be accessible by <em>many</em> components at different nesting levels. Apply it sparingly because <strong>it makes component reuse more difficult</strong>.</li><li>If you only want to avoid passing some props through many levels, component composition is often a simpler solution than context.</li></ul><p>For example, consider a <code>Page</code> component that passes a <code>user</code> and <code>avatarSize</code> prop several levels down so that deeply nested <code>Link</code> and <code>Avatar</code> components can read it:<br><img src='./assets/react/context2.png'></p><p>It might feel redundant to pass down the <code>user</code> and <code>avatarSize</code> props through many levels if in the end only the <code>Avatar</code> component really needs it. It’s also annoying that whenever the <code>Avatar</code> component needs more props from the top, you have to add them at all the intermediate levels too.</p>"
            },
            {
                "name": "Why would you need to bind event handlers to this?",
                "description": "<p>Binding is not something that is specifc to React, but rather how <code>this</code> works in Javascript. When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. In JavaScript, class methods are not bound by default. If you forget to <code>bind this.someEventHandler</code> and pass it to <code>onChange</code>, this will be undefined when the function is actually called.</p><p>Generally, if you refer to a method without <code>()</code> after it, such as <code>onChange={this.someEventHandler}</code>, you should bind that method.</p>"
            },
            {
                "name": "How to create Props Proxy for HOC component?",
                "description": "<p>It’s nothing more than a function, propsProxyHOC, that receives a Component as an argument (in this case we’ve called the argument WrappedComponent) and returns a new component with the WrappedComponent within.<br><img src='./assets/react/propsproxy.png'></p><p>Props Proxy HOCs are useful to the following situations:</p><ol><li>Manipulating props</li><li>Accessing the instance via Refs (be careful, avoid using refs)</li><li>Abstracting State</li><li>Wrapping/Composing the WrappedComponent with other elements</li></ol>"
            },
            {
                "name": "Can you do Components Inheritance in React?",
                "description": "<p>Component inheritance lets the react app make a parent-child component connection and reuse properties like state values and function in its child components.</p><p>Except for the initial component class, which extends from the react package, react does not employ inheritance.</p><p>In react The keyword ‘extends’ is used in inheritance to allow any component connected to the parent to use the attributes and methods of another component./p><p>We can give the current component access to all of the component's properties, including the function, and activate it from the child component by using the ‘extends’ keyword.</p>"
            },
            {
                "name": "How would you store non-state/instance variables in functional React components?",
                "description": "<p>You can use <code>useRef hook</code><code>useRef</code> returns an object whose reference would not change across re-renders, the actual value for foo is then kept in the current property of that object. </p><ul><li>Declaring variable: <code>const a = useRef(5) // 5 is initial value</code></li><li>getting the value: <code>a.current</code></li><li>setting the value: <code>a.current = my_value</code></li></ul>"
            },
            {
                "name": "Explain some difference between Flux and AngularJS (1.x) approach",
                "description": "<p>UI components in AngularJS typically rely on some internal <code>$scope</code> to store their data. This data can be directly mutated from within the UI component or anything given access to <code>$scope</code> — a risky situation for any part of the component or greater application which relies on that data.</p><p>However, the Flux pattern encourages the use of immutable data. Because the store is the central authority on all data, any mutations to that data must occur within the store. The risk of data pollution is greatly reduced.</p>"
            },
            {
                "name": "Architectural difference between React and Angular?  ",
                "description": "<p>As a structural framework, Angular helps develop dynamic web applications, whereas React permits you to develop UI components because it’s a JavaScript library. Similarly, Angular is based on Model-View-Controller (MVC) with TypeScript, while React is entirely based on Virtual DOM with JavaScript.</p><p>Angular uses two-way data binding. It means that whenever any interface element changes, the model state also changes automatically. React uses one-way data binding, which renders the modifications in the interface model only once the model state is updated first. And whenever the UI components get changed, the model state remains the same without any changes.</p>"
            },
            {
                "name": "What is equivalent of this code using React Hooks?",
                "description": "<p><strong>Problem</strong> - Let's say in our project we have <code>componentWillUnmount</code> that is used for cleanup (like removing event listeners, cancel the timer etc). How to refactor this code using React Hooks? <br><img src='./assets/react/solution.png'></p><p><strong>Answer</strong> - React Hooks equivalent of above code will be as follows <br><img src='./assets/react/solution.png'></p>"
            },
            {
                "name": "What is equivalent of the following using React.createElement?  ",
                "description": "<p><strong>Problem</strong><br><img src='./assets/react/reactelement4.png'></p><br><p><strong>Answer</strong><br><img src='./assets/react/reactelement5.png'></p>"
            }
        ]
    },
    {
        "folder": "React Native",
        "title": "React Native",
        "url": "/folder/React Native",
        "icon": "logo-react",
        "question": [
            {
                "name": "What are native apps?",
                "description": "<ul><li>Native mobile apps are the most common type of app. </li><li>They are built for specific platforms and are written in languages that the platform accepts. For example, <code>Swift</code> and <em>Objective-C</em> for native <strong>iOS</strong> apps and <code>Java</code> or <code>Kotlin</code> for native <strong>Android</strong> apps. </li><li>Native apps are also built using the specific <em>Integrated Development Environment</em> (IDE) for the selected operating systems</li></ul>"
            },
            {
                "name": "List some benefits of using React Native for building mobile apps?",
                "description": "<ul> <li>Known for Optimal Performance</li><li>Large Community of Developers which helps a lot in troubleshooting and resolving bugs</li><li>Offers Simple User Interface</li><li>Can Reuse the Codes and Pre-Developed Components from rect with less modifications as required, and thus result in a Cost Effective Solution</li><li>Providing Handy Solutions and Libraries</li><li>Support for Third-Party Plugins</li></ul>"
            },
            {
                "name": "What is the difference between React Native and React?",
                "description": "<ul><li><p><strong>ReactJS</strong> is a JavaScript library, supporting both front end web and being run on the server, for building user interfaces and web applications.</p></li><li><p><strong>React Native</strong> is a mobile framework that compiles to native app components, allowing you to build native mobile applications (iOS, Android, and Windows) in JavaScript that allows you to use ReactJS to build your components, and implements ReactJS under the hood.</p></li></ul>"
            },
            {
                "name": "What is the storage system in React Native?",
                "description": "<p>React Native <strong>AsyncStorage</strong> is a simple, unencrypted, asynchronous, persistent, storage system which stores the data globally in the app. It store data in the form of a key-value pair.</p><p>React Native recommended to use abstraction on top of <strong>AsyncStorage</strong> instead of AsyncStorage directly as it operates globally.</p><p>On iOS, <strong>AsyncStorage</strong> is approved by the native code. The iOS native code stores the small values in a serialized dictionary and the larger values in separate files.</p><p>On Android, AsyncStorage will use either <strong>SQLite</strong> or <strong>RocksDB</strong> based on the availability.</p><p>To use the AsyncStorage, import <strong>AsyncStorage</strong> library as:</p><strong>import {AsyncStorage} from 'react-native';</strong><p>To persist data</p><strong>AsyncStorage.setItem('key', 'value');</strong><p>To fetch data</p><strong>await AsyncStorage.getItem('key');</strong>"
            },
            {
                "name": "What are the advantages of native apps over hybrid apps?",
                "description": "<ul><li>They work efficiently as they are built for that specific platforms</li><li>Native apps are responsive on all the platform-specific devices</li><li>They are very fast and the best in the app performance</li><li>Native apps better integrate with mobile hardware</li><li>They have interactive and intuitive User Interface (UI) and User Experience (UX) as per the user expectations based on specific platforms</li><li>Some of the Native mobile apps work even without the Internet connection</li><li>Native apps are secured and reliable</li><li>They can easily access or utilize the other device-specific capabilities like GPS, Camera, Contacts, etc.</li></ul>"
            },
            {
                "name": "How do you dismiss the keyboard in react native?",
                "description": "<p>Using <code>Keyboard.dismiss()</code><br><img src='./assets/reactNative/keyboard.png'></p>"
            },
            {
                "name": "When would you use ScrollView over FlatList or vice-versa?",
                "description": "<ul><li>Do you need to render a list of similar items from an array or the data is very big? Use  <code>FlatList</code></li><li>Do you need to render generic content in a scrollable container and the data is small? Use  <code>ScrollView</code></li></ul>"
            },
            {
                "name": "What is flex dimension and how is it different from fixed dimension?",
                "description": "<ul><li>The  <strong>flex</strong>  property styles the component to expand and shrink it dynamically according to available space unlike fixed dimension where a specific height, width is specified. </li><li>Setting <code>flex: 1</code> will fill all the available space to the component, and shared evenly among the other components of same as the parent. </li><li>Higher the flex value, occupy component higher ratio of space compared to its siblings.</li></ul>"
            },
            {
                "name": "How is flexbox different in React Native and browser?",
                "description": "<p>Flexbox works the same way in React Native as it does in CSS on the web, with a few exceptions. The defaults are different, with <code>flexDirection</code> defaulting to column instead of row, and the <code>flex</code> parameter only supporting a single number.</p>"
            },
            {
                "name": "How are Hot Reloading and Live Reloading in React Native different?",
                "description": "<ul><li><strong>Live reloading</strong>  reloads or refreshes the entire app when a file changes. For example, if you were four links deep into your navigation and saved a change, live reloading would restart the app and load the app back to the initial route.</li><li><strong>Hot reloading</strong>  only refreshes the files that were changed without losing the state of the app. For example, if you were four links deep into your navigation and saved a change to some styling, the state would not change, but the new styles would appear on the page without having to navigate back to the page you are on because you would still be on the same page.</li></ul>"
            },
            {
                "name": "What is AppRegistry? Why is it required early in \"require\" sequence?",
                "description": "<ul><li><code>AppRegistry</code> is the JS entry point to running <strong>all</strong> React Native apps. </li><li>App root components should register themselves with <code>AppRegistry.registerComponent</code>, then the native system can load the bundle for the app and then actually run the app when it's ready by invoking <code>AppRegistry.runApplication</code>.</li></ul><p><code>AppRegistry</code> should be required early in the <code>require</code> sequence to make sure the JS execution environment is setup before other modules are required.</p>."
            },
            {
                "name": "How do you re-render a FlatList?",
                "description": "<p>By using <code>extraData</code> property on the <code>FlatList</code> component.</p><p><img src='./assets/reactNative/flatlistrerender.png'></p><p>By passing <code>extraData={this.state}</code> to <code>FlatList</code> we make sure <code>FlatList</code> will re-render itself when the <code>state.selected</code> changes. Without setting this prop, <code>FlatList</code> would not know it needs to re-render any items because it is also a <code>PureComponent</code> and the prop comparison will not show any changes.</p>"
            },
            {
                "name": "What is the use of ScrollView component?",
                "description": "<ul><li>The <code>ScrollView</code> is a generic scrolling container that can contain multiple components and views. The <strong>scrollable</strong> items need not be homogeneous, and you can scroll both vertically and horizontally (by setting the <code>horizontal</code> property).</li><li><code>ScrollView</code>  renders all its react child components at once, but this has a performance downside.</li></ul>"
            },
            {
                "name": "What are some features of Fast Refresh?",
                "description": "<ul><li>Fast Refresh <strong>preserves</strong> React <em>local state</em> in function components (and Hooks) by default.</li><li>Fast Refresh <strong>always</strong> remounts class components without preserving state. This ensures it works reliably.</li><li>Fast Refresh automatically retries rendering after a file is saved.</li><li><code>// @refresh reset</code> comment can be used to reset the React state on every edit.</li></ul>"
            },
            {
                "name": "In Fast Refresh, what will happen if you edit files imported by modules outside of the React Tree?",
                "description": "<p><strong>Definition</strong> - It is a React Native feature that allows you to get near-instant feedback for changes in your React components. Most edits should be visible within a second or two.</p><ul><li>Fast Refresh will <strong>re-run</strong> both that module, and the other modules importing it. </li><li>So if both Button.js and Modal.js import Theme.js, editing Theme.js will update both components.</li><li>For a file which renders a React component but also exports a value that is imported by a non-React component, consider <strong>migrating</strong> the query to a separate file and importing it into both files. This will <strong>re-enable</strong> Fast Refresh to work.</li></ul>"
            },
            {
                "name": "What is the use of FlatList?",
                "description": "<ul><li><code>FlatList</code> renders items lazily, when they are about to appear, and removes items that scroll way off screen to save memory and processing time.</li><li>The  <code>FlatList</code>  component displays a scrolling list of changing, but similarly structured, data.</li><li><code>FlatList</code>  works well for long lists of data, where the number of items might change over time. Unlike the more generic  <code>ScrollView</code>, the  <code>FlatList</code>  only renders elements that are currently showing on the screen, not all the elements at once.</li></ul>"
            },
            {
                "name": "Touchable Interactions in React Native?",
                "description": "<ul><li>The most fundamental user interaction on a mobile app is the touch. </li><li>React Native provides <strong>4</strong> separate components for handling touch interactions such as <ol><li><strong>TouchableHighlight</strong> anywhere you would use a button or link on web. The view's background will be darkened when the user presses down on the button.</li><li><strong>TouchableNativeFeedback</strong> on Android to display ink surface reaction ripples that respond to the user's touch.</li><li><strong>TouchableOpacity</strong> can be used to provide feedback by reducing the opacity of the button, allowing the background to be seen through while the user is pressing down.</li><li>If you need to handle a tap gesture but you don't want any feedback to be displayed, use <strong>TouchableWithoutFeedback</strong>.</li></ol></li></ul>"
            },
            {
                "name": "What are some best practices to consider for an action?",
                "description": "<p>To improve UX, every action should have the following attributes:</p><ul><li><strong>Feedback/highlighting</strong>- show the user what is handling their touch, and what will happen when they release the gesture</li><li><strong>Cancel-ability</strong> - when making an action, the user should be able to abort it mid-touch by dragging their finger away</li></ul><p>These features make users more comfortable while using an app, because it allows people to experiment and interact without fear of making mistakes.</p>"
            },
            {
                "name": "How do you style a component in react native?",
                "description": "<ul><li>With React Native, you style your application using JavaScript. </li><li>All of the core components accept a prop named  <code>style</code>. The style names and  values usually match how CSS works on the web, except names are written using camel casing, e.g.  <code>backgroundColor</code>  rather than  <code>background-color</code>.</li><li>The  <code>style</code>  prop can be a plain old <code>JavaScript</code> object. That's the simplest and what we usually use for example code. </li><li>You can also pass an array of styles - the last style in the array has precedence, so you can use this to inherit styles.</li></ul><p>As a component grows in complexity, it is often cleaner to use  <code>StyleSheet.create</code>  to define several styles in one place. Here's an example:</p><p><img src='./assets/reactNative/reactstyle.png'></p>"
            },
            {
                "name": "What does StyleSheet.create do and why is it useful?",
                "description": "<p>A <code>StyleSheet</code> is an abstraction similar to CSS StyleSheets. <code>StyleSheet.create</code> creates a StyleSheet style reference from the given object.<br><img src='./assets/reactNative/styleSheet.png'><br>Use a StyleSheet:<br><img src='./assets/reactNative/styleSheet1.png'></p><p><code>StyleSheet</code> are useful because:</p><ul><li>By moving styles away from the render function, you're making the code easier to understand.</li><li>Naming the styles is a good way to add meaning to the low level components in the render function.</li></ul>"
            },
            {
                "name": "What does React Native Packager do in the React Native?",
                "description": "<ul><li>Transpile and bundle all the JavaScript code into a single file.</li><li>Convert the assets (e.g., PNG file) used in the project into objects, which can be displayed by an <code>Image</code> component.</li></ul>"
            },
            {
                "name": "What is AsyncStorage and how do you use it?",
                "description": "<ul><li><code>AsyncStorage</code> is a simple, asynchronous <strong>key-value</strong> pair used in React Native applications.</li><li>It is a local only storage.</li><li>It comes in two parts: <strong>core</strong> and <strong>storage</strong> backend.</li><li><em>Core</em> is a consumer of the storage, provides you a unified API to save and read data.</li><li><em>Storage</em> backend implements an interface that <em>core</em> API understands and uses. Its functionality depends on storage itself.</li></ul><p><img src='./assets/reactNative/asyncStorage.png'></p>"
            },
            {
                "name": "What is View and how important is it?",
                "description": "<ul><li><code>View</code> is the most fundamental component for building a UI in react native.</li><li>View is a container that supports layout with flexbox, style, some touch handling, and accessibility controls.</li><li><code>View</code> maps directly to the native view equivalent on whatever platform React Native is running on, whether that is a <code>UIView</code>, <code>&lt;div&gt;</code>, <code>android.view</code>, etc.</li><li><code>View</code>  is designed to be nested inside other views and can have 0 to many children of any type.</li></ul>"
            },
            {
                "name": "What is Component Driven Development (CDD)?",
                "description": "<ul><li>A <strong>component</strong> is a well-defined and independent piece of our app's UI. A chat window, a button, a slider are all components.</li><li>Components can also be composed out of smaller components and fragments. Each is a building block.</li><li>Modern frameworks such as  <strong>React</strong>, <strong>Vue</strong>, <strong>React Native</strong>, etc.  let us build our applications through <strong>modular</strong> components, providing the patterns and tools needed to develop each component in separation and compose them together.</li><li><strong>Component-driven development</strong> means designing your software applications by building loosely-coupled <strong>independent</strong> components. </li><li>Each component has an interface to communicate with the rest of the system, and multiple components are composed together into a modular application.</li></ul>"
            },
            {
                "name": "What are some advantages of Component Driven Development - CDD?",
                "description": "<ul><li><strong>Faster development</strong>: Separating development into components lets you build modular parts with narrowly-focused APIs.</li><li><strong>Simpler maintenance</strong>: When you need to modify or update a part of your application, you can extend or update the component instead of having to refactor larger parts of your application.</li><li><strong>Better reusability</strong>: Through the separation of concerns components can be reused and extended to build multiple application instead of having to rewrite them over and over again</li><li><strong>Better TDD</strong>: Larger systems can be more easily tested as it's easier to understand and separate the responsibilities of every part of the system.</li><li><strong>Shorter learning curves</strong>: It's much easier to learn and understand the structure of a defined component than dive into an entire application.</li><li><strong>Better modeling of the system</strong>: When a system is composed out of modular components, it's easier to grasp, understand and operate on.</li></ul>"
            },
            {
                "name": "What JavaScript engine does React native use?",
                "description": "<p>React Native uses two engines.</p><ul><li><code>JavaScriptCore</code> engine is used primarily, which Safari browser runs on. </li><li><code>V8</code> engine is used when using Chrome debugging. All JavaScript code runs within Chrome itself, communicating with native code via WebSockets.</li></ul>"
            },
            {
                "name": "Are libraries such as TypeScript that compile to JavaScript compatible with React Naive?",
                "description": "<ul><li>Languages that compile to JavaScript are generally compatible with React Native. </li><li>React Native uses <strong>Babel</strong> to transform JavaScript into a form that is consumable by the native OS’s JavaScript runtime, using the <code>react-native</code> Babel plugin. </li><li>As long as Babel can compile your JavaScript, and your code does not rely on web- or Node.js-specific dependencies, it will run in React Native.</li></ul>"
            },
            {
                "name": "Does React Native compile JavaScript into Java for Android?",
                "description": "<p>Basically, Javascript communicates with native components (Java on Android, Objective C on iOS, C# on Windows).</p><p>The communication occurs through the so-called \"<strong>bridge</strong>\". If at any time you feel that this communication slows things down too much, you can choose to implement the Javascript functionality in Java, Objective C or C# respectively in order to run purely native. In this case, you are writing directly in native code, so there's no Javascript to native compilation.</p>"
            },
            {
                "name": "What is metro bundler in react-native?",
                "description": "<p>Metro is a JavaScript bundler which takes in options, an entry file, and gives you a JavaScript file including all JavaScript files back. Every time you run a react native project, a compilation of many javascript files are done into a single file. This compilation is done by a bundler which is called Metro.</p><p>Answers to your questions: </p><p>1&gt; Bundled file is located on the device itself on  which you are building your app and is stored in different formats like in case of Android Plain bundling in which .bundle is created. Another format is of Indexed RAM bundle in which file is stored as binary file. </p><p>2&gt; Webpack is also a similar type of module bundler which does bundling to ReactJS web platform and its modules are accessible through browser. Bundling process is while similar to metro.</p><p>3&gt; These bundled files are indexed and stored in a particular numerical format and thus its easy at the run time to arrange JS files in order. </p><p>Metro has three separate stages in its bundling process:</p><p><strong>Resolution</strong> - Metro needs to build a directed graph of all the modules that are required from the entry point to start the building process. To find which file is required from another file Metro uses a resolver. For eg to understand better if we have an app with multiple screens then Navigation libraries make a directed map of screens according to their order, in similar way Resolution maps javascript files in an order. This stage happens in parallel with the transformation stage.</p><p><strong>Transformation</strong> - All modules go through a transformer. A transformer is responsible for converting a module to a format that is understandable by the target platform (eg. React Native). Transformation of modules happens in parallel based on the amount of cores that you have.</p><p><strong>Serialization</strong> - After going through transformation process and converting modules into accessible format they will be serialized. A serializer combines the modules to generate one or multiple bundles. A bundle is literally a bundle of modules combined into a single JavaScript file.</p>"
            },
            {
                "name": "Difference between ScrollView and FlatList?",
                "description": "<ul><li><code>ScrollView</code>  renders all its react child components at once, but this has a performance downside while <code>FlatList</code> renders items lazily, when they are about to appear, and removes items that scroll way off screen to save memory and processing time.</li><li><code>FlatList</code>  is built to render a large list of items. <code>ScrollView</code>  is built to render a generic content in a way that it scrolls when the content is bigger than the  <code>ScrollView</code>  itself.  </li><li><code>FlatList</code> is optimized to have very good performances with very large arrays because it actually only renders the items that need to be displayed at the moment while <code>ScrollView</code> does not provide the same optimization of the flat list for very long content.</li><li>Component state is <strong>not</strong> maintained with the <code>FlatList</code> component but component state is maintained with <code>ScrollView</code> This is due to the fact that <code>ScrollView</code> renders all the children in one go and maintains them. Meanwhile, <code>FlatList</code> unmounts components once they are way off the screen and recreates them from scratch once the item comes back from screen (thus state is lost).</li></ul>"
            },
            {
                "name": "How many threads run in a React Native app?",
                "description": "<ul><li><strong>React Native UI Thread (Main Thread):</strong>  Used for the layout of the mobile app.</li><li><strong>React Native JavaScript Thread:</strong>  Thread where business logic will run. It is where the JavaScript code is executed.</li><li><strong>React Native Modules Thread:</strong>  Sometimes, the app may need to access  the platform API, which happens as a part of native module thread.</li><li><strong>React Native Render Thread:</strong>  This thread is used to generate actual OpenGL commands used to draw the app UI.</li></ul>"
            },
            {
                "name": "State the lifecycle of Gesture Responder System?",
                "description": "<p>A touch event has three phases: start, move and release.</p><p><img src='./assets/reactNative/gesture.jpg'></p><ol><li><p><strong>Request</strong>A view can request to become the touch responder in the: - start phase by returning <code>true</code> from <code>onStartShouldSetResponder</code> - move phase by returning <code>true</code> from <code>onMoveShouldSetResponder</code></p></li><li><p><strong>Bubbling</strong> Similar to the web, these negotiation functions are called in a bubbling pattern. Therefore, the deepest component will become the responder.</p></li><li><p><strong>Override</strong> However, a parent can choose to override and claim responsibility. This is done by returning true from either <code>onStartShouldSetResponderCapture</code> or <code>onMoveShouldSetResponderCapture</code>.</p></li><li><p><strong>Granted or Rejected</strong> If a view's request is granted or rejected <code>onResponderGrant</code> or <code>onResponderReject</code> is invoked appropriately.</p></li><li><p><strong>Respond</strong> Finally the view can then respond using one of the following handlers:</p></li></ol><ul><li><code>onResponderMove</code></li><li><code>onResponderRelease</code></li><li><code>onResponderTerminationRequest</code></li><li><p><code>onResponderTerminate</code></p></li></ul><p>After a view has successfully claimed touch responder status, its relevant event handlers may be called.</p>"
            },
            {
                "name": "What are some limitations of using react-native-cli for instantiating a project?",
                "description": "<ul><li>Needs <em>Android Studio</em> and/or <em>XCode</em> to run the projects</li><li>You can't develop for iOS without having a mac.</li><li>Device has to be connected via USB to use it for testing.</li><li>Fonts need to be imported manually in XCode.</li><li>If you want to share the app you need to send the whole .apk / .ipa file</li><li>Does not provide JS APIs out of the box, e.g. Push-Notifications, Asset Manager, they need to be manually installed and linked with npm for example</li><li>Setting up a working project properly (inlcuding device configuration) is rather complicated and can take time.</li></ul>"
            },
            {
                "name": "What is Fabric in React Native?",
                "description": "<ul><li><strong>Fabric</strong> is the new React Native architecture proposed by the community to make the mobile application user experience close or even better than the native apps.</li><li>Fabric is based on dividing the tasks into <strong>sync</strong> and <strong>async</strong> tasks which would be handled by the immutable shadow thread followed by the memory refinements.</li></ul><p>There are basically three main principles of Fabric :</p><ul><li><strong>Prioritizing the Tasks</strong> : - JavaScript treats all async events as the same and all of the events/processes are treated equally in terms of resource allocation - With <strong>Fabric</strong>, the user interactions such as scrolling, touch, hold, gestures etc will be prioritized and will be executed <strong>synchronously</strong> in the main thread or native thread. - Other tasks such as API requests will be executed asynchronously.</li><li><strong>Immutable Shadow Tree</strong> - This is a very important concept which would ensure that there would not be any deadlock condition independent of a synchronous or asynchronous request. - With this, it won’t matter where the changes are coming from as long as our tree is consistent with all other thread that it is being shared with.</li><li><strong>Reducing Memory Consumption</strong> - A new concept is introduced to keep a single copy of DOM nodes, instead of 2, in the memory while the other threads such as JavaScript would only have a reference of it to perform any operations.</li></ul>"
            },
            {
                "name": "How does the Fabric architecture work?",
                "description": "<p>In the new <strong>Fabric</strong> architecture, there are still three threads but designed in a way to make them as performant and efficient as possible. </p><p>The first main concept that is used is, now the tasks are divided into <strong>sync</strong> and <strong>async</strong> instead of only async. It enables us to perform the important UI operations first and in sync with the frame rate of the mobile screen. In this way, absolute no frame is dropped as the tasks are executed in sync with the user interactions (high priority). Also as any thread can bring out the changes in the Shadow thread (synced with the main thread for priority tasks), it would have to be made immutable to have the consistency and avoid deadlocks.</p><p>The other important concept which would greatly reduce the memory consumption is using references instead of a whole new copy of the DOM nodes. This is very helpful in having consistent and efficient DOM nodes. Also with the reference, we can perform any operation that we would have done with its copy but in a much quicker way.</p>"
            },
            {
                "name": "What is InteractionManager and how is it used?",
                "description": "<ul><li>The  <code>InteractionManager</code>  is a native module that allows long-running work to be scheduled after any interactions/animations have completed. In particular, this allows JavaScript animations to run smoothly.</li><li>To schedule the tasks <br><img src='./assets/reactNative/interactionManager.png'></li><li><code>InteractionManager</code> also allows applications to register animations by creating an interaction 'handle' on animation start, and clearing it upon completion</li></ul>"
            },
            {
                "name": "How is InteractionManager important?",
                "description": "<p><code>InteractionManager</code>  is very important because React Native has two threads. There is a JavaScript UI thread which handles drawing updates to the screen, and another thread used for all tasks not on the UI thread. </p><p>Since there is only one thread for making UI updates, it can get overloaded and drop frames, especially during things like navigation screen animations. </p><p>We use the  <code>InteractionManager</code>  to ensure that our function is executed  <em>after</em>  these animations occur so that we do not drop frames on the UI thread. Trying to draw a new screen while it is being animated is often too much for the thread to handle.</p>"
            },
            {
                "name": "How is React Native different from ReactJS?",
                "description": "<p>Both React Native and ReactJs is a JavaScript framework that was developed by Facebook</p><p>While React Native was designed to build native mobile apps with reusable components based on the concepts of ReactJs, where as ReactJs was build for developing responsive user interfaces for mobile and web applications.</p><p>But still there are some of key differences: such as</p><ul> <li> <strong>Syntax</strong>: React Native and ReactJS both use JSX, but ReactJS uses HTML tags, and React Native doesn’t. </li><li> <strong>Navigation</strong>: React Native uses its own built-in navigation library, while ReactJS uses a react-router. </li><li> <strong>Animation</strong>: ReactJS uses CSS animations. React Native uses its animated API. </li><li> <strong>DOM</strong>: ReactJS uses a virtual DOM with a partial refresh. React Native needs to use its native API when rendering UI components. </li><li> <strong>Usage</strong>: ReactJS is mainly used for web app development, while React Native focuses on mobile applications. </li></ul>"
            },
            {
                "name": "What are the core React Components and what do they do?",
                "description": "<p>The core React components include:</p><ul> <li> <strong>Props</strong>: You can use props to pass data to different React components. Props are immutable, which means props can’t change their values. </li><li> <strong>ScrollView</strong>: ScrollView is a scrolling container that's used to host multiple views. You can use it to render large lists or content. </li><li> <strong>States</strong>: You use states to control components. The state is mutable in React, meaning that it can change the value at any time. </li><li> <strong>Style</strong>: React Native doesn’t require any special syntax for styling. It uses the JavaScript object. </li><li> <strong>Text</strong>: The text components display text in your application. It uses <code>textInput</code> to take input from the user. </li><li> <strong>View</strong>: View is used to build the UI for mobile applications. It's a place where you can display your content. </li></ul>"
            },
            {
                "name": "How do you install and create a React Native application?",
                "description": "<p>Before you begin, make sure you have Node.js and NPM installed on your system.</p><p>To install a React Native application, you can use the following command:</p><strong><code>$ npm install -g create-react-native-app</code></strong><p>To create a React Native project, you can use the following command:</p><strong><code>$ create-react-native-app AppName</code></strong><p>To navigate in your project, use the following command:</p><strong><code>$ cd AppName</code></strong><p>And to start your project, run this command:</p><strong><code>$ npm start</code></strong>"
            },
            {
                "name": "How do you debug React apps and what tools can you use?",
                "description": "<p>There are many different ways to do your debugging in React Native applications. Since React Native has both IOS and Android environments, there's a wide range of different problems you can encounter and a wide range of different tools needed.</p><ol> <li><strong>Developer menu</strong> - The developer menu includes some different ways to debug and access debugging tools.<ul> <li><strong>Reload</strong>: reloads the app</li><li><strong>Debug JS Remotely</strong>: opens to a JavaScript debugger</li><li><strong>Enable Live Reload</strong>: causes the app to reload automatically after selecting “Save”</li><li><strong>Enable Hot Reloading</strong>: watches for changes</li><li><strong>Toggle Inspector</strong>: toggles the inspector interface so we can inspect UI elements and their properties</li><li><strong>Show Perf Monitor</strong>: monitors performance</li></ul></li><li><strong>Chrome DevTools</strong> - You can use these DevTools to debug React Native apps. You need to make sure that it's connected to the same WiFi. If you’re using Windows or Linux, press <em><strong>Ctrl + M+</strong></em>, and if you’re using macOS, press <em><strong>Command + R</strong></em>. In the developer menu, you select “Debug JS Remotely” and it will open the default debugger.</li><li><strong>React Developer Tools</strong> - To use React's Developer Tools, you have to use the desktop app. These tools allow you to debug React components and styles.</li><li><strong>React Native Debugger</strong> - If you’re using Redux in your React app, this is a good debugger for you. It's a desktop app that integrates Redux's and React's developer tools in one app.</li><li><strong>React Native CLI</strong> - You can use the React Native command-line interface to do debugging as well.</li></ol>"
            },
            {
                "name": "Describe Flexbox along with its most used properties.",
                "description": "<p><strong>Flexbox</strong> is a layout mode that enables elements to coordinate and distribute space within containers. It provides a consistent layout on different screen sizes.</p><p>The main properties in Flexbox are <code>flexDirection</code>, <code>justifyContent</code>, and <code>alignItems</code>. Let's discuss what each of these properties does:</p><ul> <li> <strong><code>flexDirection</code></strong>: used to specify the alignment of elements (vertical or horizontal) </li><li> <strong><code>justifyContent</code></strong>: used to decide how elements should be distributed inside a given container </li><li> <strong><code>alignItems</code></strong>: used to specify the distribution of elements inside a given container along the secondary axis </li></ul>"
            },
            {
                "name": "How do you create a stackNavigator in React Native?",
                "description": "<p><img src='./assets/reactNative/stacknavigator.png'></p>"
            },
            {
                "name": "How to create stack of screens in react native?",
                "description": "<p>React Navigation provides a straightforward navigation solution, with the ability to present common stack navigation and tabbed navigation patterns on both Android and iOS.</p><p><strong>Installation and Setup</strong></p><strong><code>npm install @react-navigation/native @react-navigation/native-stack</code></strong><p>After installation, <p>Now, you need to wrap the whole app in <code>NavigationContainer</code>. Usually you'd do this in your entry file, such as <code>index.js</code> or <code>App.js</code>:</p></p><p><img src='./assets/reactNative/navigationwrapper.png'></p><p>Now you can create an app with a home screen and a about screen:</p><p><img src='./assets/reactNative/navigationexample.png'></p><p>In this example, there are 2 screens (<code>Home</code> and <code>About</code>) defined using the <code>Stack.Screen</code> component. Similarly, you can define as many screens as you like.</p><p>You can set options such as the screen title for each screen in the <code>options</code> prop of <code>Stack.Screen</code>.</p><p>Each screen takes a <code>component</code> prop that is a React component. Those components receive a prop called <code>navigation</code> which has various methods to link to other screens. For example, you can use <code>navigation.navigate</code> to go to the <code>About</code> screen:</p><p><img src='./assets/reactNative/navigationexample1.png'></p><p>This <code>native-stack</code> navigator uses the native APIs: <code>UINavigationController</code> on iOS and <code>Fragment</code> on Android so that navigation built with <code>createNativeStackNavigator</code> will behave the same and have the same performance characteristics as apps built natively on top of those APIs.</p>"
            },
            {
                "name": "What is Axios and why it is used?",
                "description": "<p>Axios is a Promise-based HTTP client for JavaScript which can be used in your front-end application and in your Node.js backend.</p><p>Axios is a Promise-based HTTP client for JavaScript which can be used in your front-end application and in your Node.js backend.</p><ul><li>Make XMLHttpRequests from the browser</li><li>Make http requests from node.js</li><li>Supports the Promise API</li><li>Intercept request and response</li><li>Transform request and response data</li><li>Cancel requests</li><li>Automatic transforms for JSON data</li><li>Client side support for protecting against XSRF</li></ul>"
            },
            {
                "name": "How does React Native handle different screen sizes?",
                "description": "<p>There are different ways to handle different screen sizes but some of them are really difficult to implement and for some there is not much help in the official documentation. Let me list down the ways to handle layout for different devices and their cons and pros :</p><ol> <li><strong>Flex</strong> - Using flex for alignments or to design a single component is really an easy task and it handles different screens automatically without any extra effort but for designing a whole page using flex is a whole different story and it takes a lot of time to do it.</li><li><strong>Pixel Ratio</strong> - PixelRatio class gives access to the device pixel density. You should get a higher resolution image if you are on a high pixel density device. A good rule of thumb is to multiply the size of the image you display by the pixel ratio.”</li><li>Dimensions - Using Dimensions to handle different screen size is really easy and we can style our page precisely using this. Let me tell you how to implement this and to obtain dimensions of current device : <br><strong><code>import Dimensions from ‘Dimensions’; <br>const { width, height } = Dimensions.get(‘window’); <br>&lt;View&gt;&lt;Text style=❴❴fontSize: width * .3 ❵❵&gt;Some text&lt;/Text&gt;&lt;/View&gt;</code></strong></li></ol><p>A combination of tools and concepts, will give you the best results: such as</p><ul><li><strong>Density Independent Pixels:</strong> - With density independent pixels (dp), React Native defines a coordinate space separate from the resolution of the device. This makes it much more simpler to place items. An item of 300(dp) in width, will generally cover the same amount of space no matter the screen size, even if the resolution of the devices varies. It is predictable, and easy to guess roughly where elements are placed and sized.</li><li><strong>Flexbox:</strong> -  Flexbox also gives you some very useful alignment features for child components, where you may space these items evenly no matter the screen width.</li><li><strong>Dimensions:</strong> Calculate sizes/position based on device dimensions, you can try placing items on screen depending on the screen width or height. To do this you will use the Dimensions object from React Native</li><li><strong>Percentages:</strong> Dimensions Relative to its container, You may use percentages to size items, which are helpful in some situations as well.</li><li><strong>PixelRatio:</strong> Handle sizing depending on pixel depth, like Images which haven’t been properly sized for your screen won’t look great, so make sure to use PixelRatio for that too.</li></ul><p><img src='./assets/reactNative/imagepixelratio.png'></p>"
            },
            {
                "name": "How is the entire React Native code processed to show the final output on a mobile screen",
                "description": "<ul><li>At the first start of the app, the main thread starts execution and starts loading JS bundles.</li><li>When JavaScript code has been loaded successfully, the main thread sends it to another JS thread because when JS does some heavy calculations stuff the thread for a while, the UI thread will not suffer at all times.</li><li>When React starts rendering, Reconciler starts “diffing”, and when it generates a new virtual DOM(layout) it sends changes to another thread(Shadow thread).</li><li>Shadow thread calculates layout and then sends layout parameters/objects to the main(UI) thread. ( Here you may wonder why we call it “shadow”? It's because it generates shadow nodes )</li><li>Since only the main thread is able to render something on the screen, the shadow thread should send the generated layout to the main thread, and only then UI renders.</li></ul>"
            },
            {
                "name": "What is a bridge and why is it used in React Native ? Explain for both android and IOS ?",
                "description": "<p>Bridge in ReactNative is a layer or simply a connection that is responsible for gluing together Native and JavaScript environments. The bridge is basically a transport layer which acts as a connection between Javascript and Native modules, it does the work of transporting asynchronous serialized batched response messages from JavaScript to Native modules.</p><p>Now for an example, there is some state change that happens, because of which React Native will batch Update UI and send it to the Bridge. The bridge will pass this Serialized batched response to the Native layer, which will process all commands that it can distinguish from a serialized batched response and will update the User Interface accordingly.</p><ul><li><strong>IOS Platform</strong> - <br><img src='./assets/reactNative/IOS_Platform.png'></li><li><strong>Android Platform</strong> - <br><img src='./assets/reactNative/android_platform.png'></li></ul>"
            },
            {
                "name": "List down some of the steps to optimize the application.",
                "description": "<ul> <li>Use key attribute on list items, it helps React Native to pick which list to update when rendering a long list of data&nbsp;</li><li>Compress images and other graphic elements. Another option to reduce image size is using file types like APNG in place of PNG files.</li><li>Optimize native libraries.</li><li>Optimize the number of state operations and remember to use pure and memoized components when needed</li><li>Clear all the active timers which may lead to heavy memory leakage issues.</li><li>Use Global State wisely for example worst-case scenario is when state change of single control like TextInput or CheckBox propagates render of the whole application. Use libraries like Redux or Overmind.js to handle your state management in a more optimized way.</li><li>Use VirtualizedList, FlatList, and SectionList for large data sets.</li><li>Don’t store raw JSON data, &nbsp;eIther we need to Compress it or convert it into static object IDs.</li><li>Use Proguard to minimize the application size.(It does this by stripping parts of the React Native Java bytecode (and its dependencies) that your app is not using)</li><li>Create reduced-sized APK files for specific CPU architectures. When you do that, your app users will automatically get the relevant APK file for their specific phone's architecture. This eliminates the need to keep JSCore binaries that support multiple architectures and consequently reduces the app size.</li></ul>"
            },
            {
                "name": "Describe Memory leak Issue in React Native , how can it be detected and resolved ?",
                "description": "<p>In JavaScript memory is managed automatically by Garbage Collector (GC). In short, Garbage Collector is a background process that periodically traverses the graph of allocated objects and their references. If it happens to encounter a part of the graph that is not being referenced directly or indirectly from root objects (e.g., variables on the stack or a global object like window or navigator) that whole part can be deallocated from the memory.<br><br>In React Native world each JS module scope is attached to a root object. Many modules, including React Native core ones, declare variables that are kept in the main scope (e.g., when you define an object outside of a class or function in your JS module). Such variables may retain other objects and hence prevent them from being garbage collected.<br><br><strong>Some Causes of Memory Leak:</strong></p><ul><li>Unreleased timers/listeners added in componentDidMount</li><li>Closure scope leaks</li></ul><p><strong>Detecting memory leaks for IOS:</strong><br><br>In Xcode,<br><br>Go to XCode → Product → Profile (⌘ + i)<br><br>After that shows you all templates choose leaks.<br><br><strong>Detecting memory leaks for Android :</strong><br><br>Run React Native app normally (react-native run-android)<br>Run Android Studio<br><br>On the menu,<br>click Tools → Android → Enable ADB Integration<br>Click Tools → Android → Android Device Monitor<br>When Android Device Monitor shows up, click Monitor → Preferences<br><br>There is also one more way in Android<br>Perf Monitor (Performance Monitor) is a good choice to use for android leak monitoring.</p>"
            },
            {
                "name": "What is wrong with this code for querying a native API?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/reactNative/gyroPosition.png'></p><br><p><strong>Answer</strong> - </p><p>This code will always throw an error because the value of <code>gyroscopePosition</code> will always be an unresolved <code>Promise</code>. </p><p>It’s important to remember that the <strong>bridge</strong> that connects JavaScript and native code is <em>asynchronous</em>. We can either receive results from this side by passing in a callback (not done in this example), or by returning a <code>Promise</code>. In this case, we need to append a <code>then()</code> call to the <code>gyroPosition()</code> call and set the position <em>inside</em> it.</p>"
            },
            {
                "name": "What is reselect and how it works?",
                "description": "<p><em>Reselect</em> is a <strong>selector library</strong> (for Redux) which uses <em>memoization</em> concept. It was originally written to compute derived data from Redux-like applications state, but it can't be tied to any architecture or library.</p><p>Reselect keeps a copy of the last inputs/outputs of the last call, and recomputes the result only if one of the inputs changes. If the the same inputs are provided twice in a row, Reselect returns the cached output. It's memoization and cache are fully customizable.</p><p>Let's see the main features of Reselect library,</p><ol><li>Selectors can compute derived data, allowing Redux to store the minimal possible state.</li><li>Selectors are efficient. A selector is not recomputed unless one of its arguments changes.</li><li>Selectors are composable. They can be used as input to other selectors.</li></ol><p><strong>Example of Reselect usage</strong> - Let's take calculations and different amounts of a shipment order with the simplified usage of Reselect:<br><img src='./assets/react/reselect.png'><br><img src='./assets/react/reselect1.png'></p>"
            },
            {
                "name": "Difference between Flow and PropTypes",
                "description": "<p>Flow is a <em>static analysis tool</em> (static checker) which uses a superset of the language, allowing you to add type annotations to all of your code and catch an entire class of bugs at compile time.</p><p>PropTypes is a <em>basic type checker</em> (runtime checker) which has been patched onto React. It can't check anything other than the types of the props being passed to a given component. If you want more flexible typechecking for your entire project Flow/TypeScript are appropriate choices.</p>"
            }
        ]
    }
]