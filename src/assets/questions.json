[
    {
        "folder": "JavaScript",
        "title": "JavaScript",
        "url": "/folder/JavaScript",
        "icon": "logo-javascript",
        "question": [
            {
                "name": "What are the different data types present in javascript?",
                "description": "<ol><li><strong>Primitive types</strong> - Primitive data types can store only a single value. <ol><li><strong>String</strong> - It represents a series of characters and is written with quotes. A string can be represented using a single or a double quote.</li><li><strong>Number</strong> - It represents a number and can be written with or without decimals.</li><li><strong>Boolean</strong> - It represents a logical entity and can have only two values : true or false. Booleans are generally used for conditional testing. </li><li><strong>Undefined</strong> - When a variable is declared but not assigned, it has the value of undefined and it’s type is also undefined</li><li><strong>Null</strong> - It represents a non-existent or a invalid value.</li></ol></li><li><strong>Non Primitive type</strong> - To store multiple and complex values, non-primitive data types are used. <ol><li><strong>Object</strong> - Used to store collection of data.</li></ol></li></ol>"
            },
            {
                "name": "What are the possible ways to create objects in JavaScript",
                "description": "<ol><li><strong>Object literal syntax:</strong> - comma-separated set of name-value pairs wrapped in curly braces. <br><pre>var object = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: \"Kamlesh\",<br>&nbsp;&nbsp;&nbsp;&nbsp;age: 34 <br>};</pre></li><li><strong>Function constructor:</strong> - Create any function and apply the new operator to create object instances,<br><br><pre>// constructor function <br>function Person () { <br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = 'John', <br>&nbsp;&nbsp;&nbsp;&nbsp;this.age = 23<br>}<br><br>// create an object<br>const person = new Person();</pre><br><br></li><li><strong>Function constructor with prototype:</strong> - This is similar to function constructor but it uses prototype for their properties and methods, <br><pre>function Person() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;Person.prototype.name = \"Kamlesh\";<br>&nbsp;&nbsp;&nbsp;&nbsp;var object = new Person();</pre></li><li><strong>Object's create method:</strong> - The create method of Object creates a new object by passing the prototype object as a parameter <br><pre>var object = Object.create(null);<br>&nbsp;&nbsp;&nbsp;&nbsp;a.name = \"Kamlesh\"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;// '{name: \"Kamlesh\"}'</pre></li><li><strong>Object constructor:</strong> - create an empty object is using the Object constructor <br><pre>var object = new Object();<br>&nbsp;&nbsp;&nbsp;&nbsp;a.name = \"Kamlesh\"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;// '{name: \"Kamlesh\"}'</pre></li><li><strong>ES6 Class syntax:</strong> - ES6 introduces class feature to create the objects <br><pre>class Person {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>} <br><br>var object = new Person(\"Kamlesh\");</pre></li><li><strong>Singleton pattern:</strong>  - A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance and this way one can ensure that they don't accidentally create multiple instances. <br><pre>var object = new (function () {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = \"Kamlesh\";<br>})();</pre></li></ol>"
            },
            {
                "name": "What is Hoisting?",
                "description": "<p>Hoisting is a JavaScript mechanism where variables, function and class declarations are moved to the top of their scope before code execution.<br><br><img src='./assets/js/hoisting.png'><br><br><strong>Note</strong> that JavaScript only hoists declarations, not initialisation. Variables declared or initialized with the var keyword will have their declaration 'moved' up to the top of their module/function-level scope, which we call as hoisting. However, only the declaration is hoisted, the assignment (if there is one), will stay where it is.</p>"
            },
            {
                "name": "What are the tools or techniques used for debugging JavaScript code",
                "description": "<ol><li>Chrome Devtools</li><li>debugger statement</li><li>Good old console.log statement</li></ol>"
            },
            {
                "name": "Difference between (equality operator) == and === ?",
                "description": "<p> JavaScript has both strict and type-converting equality comparison. For strict comparison we use === and for type-converting comparison we use == .<br><br><strong>Strict Comparison(===)</strong><br>For strict comparison the items been compared must be the same type.</p><ul> <li>Two strings are strictly equal when they have the same sequence of characters, same length, and same characters in corresponding positions.<br><br><img src='./assets/js/equaltwostring.png'></li><li>Two numbers are strictly equal when they are numerically equal (have the same number value). NaN is not equal to anything, including NaN. Positive and negative zeros are equal to one another.<br><br><img src='./assets/js/equaltwonum.png'></li><li>Two Boolean operands are strictly equal if both are true or both are false.<br><br><img src='./assets/js/equaltwobool.png'></li><li>Two objects are strictly equal if they refer to the same Object.<br><br><img src='./assets/js/equaltwoobj.png'></li><li>Null and Undefined types are not equal<br><br><img src='./assets/js/nullundefined.png'></li></ul><br><br><strong>Type-converting comparison</strong> - The == does a type conversion before comparing, if both items are of different types.<br><br><img src='./assets/js/equality1.png'>"
            },
            {
                "name": "Difference between variables created using let var or const?",
                "description": "<p><strong>#1. Variables</strong> declared using the <code>var</code> keyword are scoped to the function in which they are created, or if created outside of any function, to the global object. <code>let</code> and <code>const</code> are block scoped, meaning they are only accessible within the nearest set of curly braces (function, if-else block, or for-loop).<br><img src='./assets/js/let-var-const.png'><br><br><strong>#2.</strong> <code>var</code> allows variables to be hoisted, meaning they can be referenced in code before they are declared, where as <code>let</code> and <code>const</code> will not allow this, instead they will <strong>throw an error.</strong><br><img src='./assets/js/let-var-const1.png'><br><br><strong>#3.</strong> Redeclaring a variable with <code>var</code> will not throw an error, but <code>let</code> and <code>const</code> will throw.<br><img src='./assets/js/let-var-const2.png'><br><br><strong>#4.</strong> <code>let</code> and <code>const</code> differ to each other in a waya that <code>let</code> allows reassigning of the variable's value while <code>const</code> does not.<br><img src='./assets/js/let-var-const3.png'></p>"
            },
            {
                "name": "What is Coercion in JavaScript?",
                "description": "<p>In JavaScript conversion between different two build-in data types is called coercion. Coercion comes in two forms in JavaScript: explicit and implicit.<br><br><strong>Implicit coercion:</strong> Type coercion is the automatic or implicit conversion of values from one data type to another.<br><img src='./assets/js/implicit.png'><br><br><strong>Explicit coercion:</strong> Type conversion is done explicitly in code using the inbuilt functions like Number(), String(), Boolean(), etc<br><img src='./assets/js/explicit.png'></p>"
            },
            {
                "name": "Difference between null and undefined",
                "description": "<table><thead><tr><th>Undefined</th><th>Null</th></tr></thead><tbody><tr><td>Undefined means the variable has been declared, but its value has not been assigned.</td><td>Null means an empty value or a blank value.</td></tr><tr><td>The typeof() operator returns <strong>undefined</strong> for an undefined variable.</td><td>The typeof() operator returns the type as an <strong>object</strong> for a variable whose value is assigned as null.</td></tr><tr><td>It returns <strong>NaN</strong>on performing arithmetic operations.</td><td>converts to 0 then perform the operation</td></tr><tr><td>As there is no value assigned to the variable, it becomes undefined when we assign to a variable.</td><td>As we assign null to a variable, it becomes as assigned value of that variable.</td></tr></tbody></table>"
            },
            {
                "name": "Why JavaScript 'var null' throw error but 'var undefined' doesn't?",
                "description": "<p><strong>null (var null)</strong> - In JavaScript, null is a reserved identifier, therefore we cannot use it as an identifier in JavaScript. An error can be seen if we will write:<br><br><img src='./assets/js/null.png'><br><br>The web browser throws an error for “var null” since it is a reserved identifier, The following is the error visible<br><strong>Output - SyntaxError: Unexpected token null </strong><br><br><strong>undefined (var undefined)</strong> - The undefined is not a reserved identifier, therefore if you will write the following, then no error would be thrown:<br><br><img src='./assets/js/undefined.png'><br><strong>Output: Undefined</strong></p>"
            },
            {
                "name": "Difference between “undefined” and “not defined”",
                "description": "<p>In JavaScript, <strong>“undefined”</strong> and <strong>“not defined”</strong> are the two separate terms related to memory space. The keyword <strong>“undefined”</strong> means there is a variable that is defined and contains space in memory without an assigned value. While <strong>“not defined”</strong> means the variable is not yet defined in the code.<br><br>Example of undefined:<br><pre>var x; // declaring x<br>console.log(x);<br>//output: undefined</pre><br><br>Example of not defined:<br><pre>console.log(y);<br>// Output: ReferenceError: y is not defined</pre></p>"
            },
            {
                "name": "Difference between function declaration and function expression?",
                "description": "<p>Function declaration is like most other traditional languages, but in JavaScript we use the keyword “function”.<br>In function expression we assign an anonymous function to an variable. They are very useful when we pass function as arguments to other function or return an function.<br><br><img src='./assets/js/function.png'><br><br>One of the key difference is that, we can call a function declaration even before defining it but same is not true for function expression and it will give reference error.</p>"
            },
            {
                "name": "Is JavaScript an interpreted language or compiled language?",
                "description": "<p><strong>JavaScript</strong>is a special case where you directly execute your source code. A webpage will directly execute your JavaScript. So, for that reason many people think JavaScript as a interpreted language. <strong>However there is a compilation step just before the interpretation step in JavaScript. So, JS is both compiled and interpreted language.</strong><br><br><pre>var a = 10; <br>var b = 20; <br>console.log(a+b)</pre><br><br><strong>Compilation Step</strong> – During this step the compiler mainly registers the variable declarations.<br><br>When the compiler goes to line 1, it encounters <code>var a</code> and registers it in the global scope and then goes to line 2 and registers the <code>var b</code>.<br><br><strong>Interpretation Step</strong> – During this the actual execution takes place. <br><br>the interpreter starts at line 1 and see a variable a and ask the compiler, if it have a variable “a” in Global scope and the compiler have it. So, it assigns the value 10 to it. Next the same step is repeated for line 2 and interpreter assigns 20 to variable “b”. Now once the interpreter goes to line 3, it finds console. It first looks for console at global scope from the compiler but don’t find it. So, it checks in the JavaScript global and finds it. Inside the console there are variable a and b, which it finds at global scope. It then adds them using addition operator and display the result.</p>"
            },
            {
                "name": "Is JavaScript a pass by reference or pass by value language?",
                "description": "<p>In JavaScript, <strong>primitive data types are passed by value</strong> and <strong>non-primitive data types are passed by reference.</strong><br><br>Pass-by-value creates a new space in memory and makes a copy of a value with Primitive data types such as string, number, boolean etc will actually create a new copy. Hence, updating one value doesn't impact the other value. i.e, The values are independent of each other.<pre>let a = 5;<br>let b = a;<br><br>b++;<br>console.log(a, b); //5, 6 </pre><br>In the above code snippet, the value of <code>a</code> is assigned to <code>b</code> and the variable <code>b</code> has been incremented. Since there is a new space created for variable <code>b</code>, any update on this variable doesn't impact the variable <code>a</code>.<br><br><br>where as Pass by reference doesn't create a new space in memory but the new variable adopts a memory address of an initial variable. Non-primitives such as objects, arrays and functions gets the reference of the initiable variable. i.e, updating one value will impact the other variable.<br><pre>let user1 = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: 'John',<br>&nbsp;&nbsp;&nbsp;&nbsp;age: 27<br>}; <br><br>let user2 = user1;<br>user2.age = 30;<br><br>console.log(user1.age, user2.age); // 30, 30</pre></p>"
            },
            {
                "name": "Is javascript a statically typed or a dynamically typed language?",
                "description": "<p>JavaScript is a dynamically typed language. In a dynamically typed language, the type of a variable is checked during <strong>run-time </strong>in contrast to a statically typed language, where the type of a variable is checked during <strong>compile-time.</strong><br><br>Since javascript is a loosely(dynamically) typed language, variables in JS are not associated with any type. A variable can hold the value of any data type.<br><br>For example, a variable that is assigned a number type can be converted to a string type:<br><br><pre>var a = 23; <br>var a = \"Hello World!\";</pre></p>"
            },
            {
                "name": "What is NaN in JavaScript?",
                "description": "<p>NaN suggests that the entered value is not a legal number. It is a JavaScript property, which can also be considered as a \"Not-a-Number\" value.<br><br>To determine the entered value is a number or not, you can use the Number.isNaN() method. If the result is “True”, then it would that the given value is not a number, whereas “False” would mean the value is a legal Number.<br><br><strong>Note - </strong> To check whether entered value is a NaN or not, use the Number.isNaN() method. This method returns <strong>true</strong> if the value is not a number, else <strong>false</strong> is returned.<br><pre>var a = 'z';<br><br>isNaN(a) / isNaN(\"Hello\")  // Returns true<br><br>isNaN(345)  // Returns false<br><br>isNaN('1')  // Returns false, since '1' is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;converted to Number type which results in 0 ( a number)<br><br>isNaN(true) // Returns false, since true <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;converted to Number type results in 1 ( a number)<br><br>isNaN(false) // Returns false<br><br>isNaN(undefined) // Returns true</pre></p>"
            },
            {
                "name": "IIFE - Immediate Invoke Function Expression",
                "description": "<p>An IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined.<br><br>It is a design pattern which is also known as a Self-Executing Anonymous Function and contains two major parts:</p><ol> <li>The first is the anonymous function with lexical scope enclosed within the <code>Grouping Operator</code> <code>()</code>. This prevents accessing variables within the IIFE idiom as well as polluting the global scope.</li><li>The second part creates the immediately invoked function expression <code>()</code> through which the JavaScript engine will directly interpret the function.</li></ol><br><br><strong>Syntax:</strong><br><pre>(function(){ <br>&nbsp;&nbsp;&nbsp;&nbsp;// Do something;<br>})();</pre>"
            },
            {
                "name": "What do you mean by strict mode in javascript and characteristics of javascript strict-mode?",
                "description": "<p>In ECMAScript 5, a new feature called JavaScript Strict Mode allows you to write a code or a function in a \"strict\" operational environment. In <strong>'Strict mode,'</strong> almost all forms of errors, including silent errors, will be thrown. As a result, debugging becomes a lot simpler.&nbsp; Thus programmer's chances of making an error are lowered.<br><br>Characteristics of strict mode in javascript</p><ol><li>Duplicate arguments are not allowed by developers.</li><li>In strict mode, you won't be able to use the JavaScript keyword as a parameter or function name.</li><li>The <strong>'use strict'</strong> keyword is used to define strict mode at the start of the script. Strict mode is supported by all browsers.</li><li>Engineers will not be allowed to create global variables in <strong>Strict Mode.</strong></li></ol>"
            },
            {
                "name": "What is a first class function?",
                "description": "<p>In Javascript, functions are first class objects. First-class functions means when functions in that language are treated like any other variable.<br><br>In such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable. For example, in the below example, handler functions assigned to a listener<br><br><img src='./assets/js/first-class.png'></p>"
            },
            {
                "name": "What is a first order function?",
                "description": "<p>First-order function is a function that doesn’t accept other function as an argument and doesn’t return a function as its return value.<br><br><img src='./assets/js/first-order.png'></p>"
            },
            {
                "name": "What are Higher Order Functions",
                "description": "<p>Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.<br><br><strong>Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.</strong><br><br>Higher-order functions are a result of functions being <strong>first-class citizens </strong>in javascript.<br><br><img src='./assets/js/hoc.png'></p>"
            },
            {
                "name": "What are callbacks?",
                "description": "<p><strong>Functions that are used as an argument to another function are called callback functions.</strong> For Example:<br><br><img src='./assets/js/callback.png'></p>"
            },
            {
                "name": "Why do we use callbacks?",
                "description": "<p>A callback function is a method that is sent as an input to another function (now let us name this other function \"thisFunction\"), and it is performed inside the thisFunction after the function has completed execution.<br><br>JavaScript is a scripting language that is based on events. Instead of waiting for a reply before continuing, JavaScript will continue to run while monitoring for additional events. Callbacks are a technique of ensuring that a particular code does not run until another code has completed its execution.</p>"
            },
            {
                "name": "“this” Keyword",
                "description": "<p><strong><code>this</code></strong> keyword is one of the most used keywords in JavaScript. But when it comes to regular functions and arrow functions, it behaves in entirely different ways.<br><br>In regular function, <strong><code>this</code></strong> changes according to the way that function is invoked.</p><ul><li><strong>Simple Invocation: <code>this</code></strong> equals the global object or maybe undefined if you are using strict mode.<br><img src='./assets/js/simplethis.png'></li><li><strong>Method Invocation: <code>this</code></strong> equals the object that owns the method.<br><img src='./assets/js/methodthis.png'></li><li><strong>Indirect Invocation: <code>this</code></strong> equals the first argument.<br><img src='./assets/js/indirectthis.png'></li><li><strong>Constructor Invocation: <code>this</code></strong> equals the newly created instance.<br><img src='./assets/js/constructorthis.png'></li></ul><br><br><p>But, in the arrow functions, the behavior of <strong><code>this</code></strong> changes completely.<br><br>Arrow functions don't have their own “this”, and they don’t redefine the value of “<code>this</code>” within the function. <br><br>Regardless of how you execute arrow functions, <code>this</code> inside an arrow function always refers to <code>this</code> from the outer context. This means that <code>this</code> keyword is <strong>lexically </strong>bound in arrow functions. <br>For Example: <br><img src='./assets/js/this.png'><br><br>This behavior of arrow functions makes them really useful when using callbacks inside methods.<br><br>You don't need to use workarounds like <code>const self = this</code> or <code>callback.bind(this)</code> with arrow functions, and it prevents any mistakes that can be caused by the use of <code>this</code> within callbacks.</p>"
            },
            {
                "name": "How does the \"this\" keyword work? Provide some code examples",
                "description": "<p>In JavaScript <em>this</em> always refers to the “owner” of the function we're executing, or rather, to the object that a function is a method of.<br><img src='./assets/jsCode/foo.png'></p>"
            },
            {
                "name": "Explain ”this” with call, apply and bind in JavaScript?",
                "description": "<p>Every function in JavaScript have call, apply and bind methods. These methods can be used to set the custom value of “this” to the execution context of the function.<br><br> <strong>call</strong><strong> - It's a predefined method in javascript. This method invokes a method (function) by specifying the owner object.<br/></strong>Let's say that we have an object called <strong>obj</strong>. It only has one property called <strong>num</strong>, which has a value of 3. Let's also make a function called <strong>addNumbers</strong>.<br><br> Now, in <strong>addNumbers</strong> we have this.num. But how do we pass the value obj.num to it. We need to pass it a context, which means the value of “this”. We will do this my call method by passing a first argument as obj, so the “this” is the obj now.<br><br><img src='./assets/js/call1.png'/><br><br> <strong>apply</strong><strong><br/></strong>It is totally similar to call, but the only difference is that we can pass array as the second argument. We will use the same code for apply also. But now we have an <em>arr</em>, to be passed as second argument.<br><br><img src='./assets/js/apply1.png'/><br><br> <strong>bind</strong><strong><br/></strong>Bind works in a bit different way then call and apply. It works by returning a copy of the function. We will take the returned function in <strong>bindFunc</strong> and then execute it in the next line.<br><br><img src='./assets/js/bind2.png'/></p>"
            },
            {
                "name": "When would you use the bind function?",
                "description": "<p>A good use of the <code>bind</code> function is when you have a particular function that you want to call with a specific this value. You can then use <code>bind</code> to pass a specific object to a function that uses a <code>this</code> reference.</p><br> <img src='./assets/js/bind1.png'>"
            },
            {
                "name": "Explain currying in JavaScript and implement multiply(2)(3)(4)(10) using it?",
                "description": "<p>Currying is the process of taking a function with multiple arguments and turning it into a sequence of functions each with only a single argument.<br><br>In other words, when a function, instead of taking all arguments at one time, takes the first one and return a new function that takes the second one and returns a new function which takes the third one, and so forth, until all arguments have been fulfilled.<br><br><img src='./assets/js/currying.png'><br><br><strong>Note:</strong> Currying works because of JavaScript concept of closures. The closure created by the nested functions to retain access to each of the arguments. So inner function which do “return a * b * c * d” have access to all arguments.</p>"
            },
            {
                "name": "What is Scope and Scope Chain in JavaScript?",
                "description": "<p>Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime. In other words, scope determines the visibility of variables and other resources in areas of your code.<br><br>There are three types of scopes in JS: <br><strong>#1. Global Scope</strong> - Variables or functions declared in the global namespace have global scope, which means all the variables and functions having global scope can be accessed from anywhere inside the code. <br><br><strong>#2. Local or Function Scope</strong> - Any variables or functions declared inside a function have local/function scope, which means that all the variables and functions declared inside a function, can be accessed from within the function and not outside of it. <br><br><strong>#3. Block Scope</strong> - Block scope is related to the variables declared using let and const. Variables declared with var do not have block scope. Block scope tells us that any variable declared inside a block { }, can be accessed only inside that block and cannot be accessed outside of it.<br><br><strong>##Scope Chain</strong> - When a variable is used in JavaScript, the JavaScript engine will try to find the variable’s value in the current scope. If it could not find the variable, it will look into the outer scope and will continue to do so until it finds the variable or reaches global scope. <br>If it’s still could not find the variable, it will either implicitly declare the variable in the global scope (if not in strict mode) or return an error.<br><img src='./assets/js/scopechain.png'></p>"
            },
            {
                "name": "What is a closure and how do we use it?",
                "description": "<p>Closures are everywhere in JavaScript.<br><br>Closures are basically, the inner function having access to the variables in the outer function scope, even after the outer function has returned. To use a closure, simply define a function inside another function and expose it, I mean return it.<br><br>Consider the below code. The variable <strong>b</strong> have an scope in outer function. So, at when we call the outer function, it can access the value of b.<br><br>So, how does the innerFn() access the value of <strong>b</strong>. This is where the JS feature of Closures comes into play.<br><br><em>When the “var inner” is created, the JS engine not only stores the function object information but also its scope information.&nbsp;</em>So, it stores a scope of variable <strong>b</strong> inside the inner function object.<br><br>Now it doesn’t matter where you call inner, whether in this file. It will always remember the value of <strong>a</strong> and <strong>b</strong>, as if a snapshot is been taken.<br><br><img src='./assets/js/closure.png'></p>"
            },
            {
                "name": "What is an anonymous function",
                "description": "<p>An anonymous function is a function without a name! Anonymous functions are commonly assigned to a variable name or used as a callback function.<br><br><img src='./assets/js/anonymous.png'></p>"
            },
            {
                "name": "What are Object Prototypes and how do we use them in JavaScript?",
                "description": "<p>In JavaScript everything is an Object. So whenever we create an function, there is a one object which is created for that function. But actually there is another object which is created which is known as the <em>Prototype</em> object.<br><br>Now, let's look how to create an function using prototype and the benefit of it. The below code have two function <em>haveFun</em> and <em>drinkBreak</em>. The function <em>haveFun</em> is an normal function inside the Constructor function. The function <em>drinkBreak</em> is created outside and added to the Prototype Object using it's reference prototype.<br><br><img src='./assets/js/functionprototype.jpg'><br><br>Both the function seems to be doing the same thing, then what's the benefit.<br>The benefit of declaring function using prototype is that it's created once in the Prototype object. So, now whenever we create a new instance of the Constructor function the function is not created again. As in the below screenshot, you can see that <strong>emp1</strong> and <strong>emp2</strong> both have <strong>name</strong> and <strong>haveFun</strong>. But the <strong>drinkBreak</strong> is inside the <strong>__proto__</strong>, which is a reference to Prototype object.<br><br><img src='./assets/js/functionprototype1.jpg'></p>"
            },
            {
                "name": "What is memoization?",
                "description": "<p>Memoization is a form of caching where the return value of a function is cached based on its parameters. If the parameter of that function is not changed, the cached version of the function is returned.<br>Let’s understand memoization, by converting a simple function to a memoized function: <br><br><img src='./assets/js/memiozation.png'></p>"
            },
            {
                "name": "Explain recursion in JavaScript?",
                "description": "<p>Recursion is a technique for iterating over an operation by having a function call itself repeatedly until it arrives at a result.<br>Now, in recursive function there are two parts. One is <strong>termination condition</strong> and other is the <strong>recursion</strong> itself. &nbsp;The termination condition is very important or else the recursion never stops and goes into infinite loop.<br><br>Let consider the below simple example to add numbers from the current passed number backwards till 1. Say we pass 3, then 3+2+1 = 6. In the below example <em>If(n≤0)</em> is the termination condition and <em>return n + add(n-1);</em> is the recursion.<br><br><img src='./assets/js/recursive.jpg'><br><br>The recursion works as shown in the diagram below.<br>It works like loop, so the first call will go to recursion part and give “3 + add(2)”.<br><br>Now the add(2) will be called and will be expended into “2 + add(1)”.<br>After that add(1) will be called and expanded into “1 + add(0)”.<br><br>Finally the add(0) will trigger the termination condition <em>If(n≤0)&nbsp;</em>and produce 0.<br>After this everything will be added 3 + 2 + 1 + 0 to give 6.<br><br><img src='./assets/js/recursiveoutput.jpg'></p>"
            },
            {
                "name": "What are constructor functions in JavaScript?",
                "description": "<p>In JavaScript, a constructor gets called when you try to create an object using the new keyword. The purpose of a constructor is <b>If we want to create multiple objects having similar properties and methods, constructor functions are used.</b>.<br><br><img src='./assets/js/constructor.png'></p>"
            },
            {
                "name": "How to make variables private in Constructor functions?",
                "description": "<p>Now, we implement the same in JavaScript using Closures. We have two closure functions <strong>setName</strong> and <strong>getName</strong> which are basically “setters” and “getters”. Now, the variable <strong>_name</strong> is private and cannot be accessed outside the function by <em>person._name</em> and we can access it only by <em>person.getName()</em><br><br><img src='./assets/js/privatevarconstructor.jpg'></p>"
            },
            {
                "name": "What is DOM?",
                "description": "<ul><li>DOM stands for Document Object Model. &nbsp;DOM is a programming interface for HTML and XML documents.</li><li>When the browser tries to render an HTML document, it creates an object based on the HTML document called DOM. Using this DOM, we can manipulate or change various elements inside the HTML document.</li></ul>"
            },
            {
                "name": "List all DOM events ",
                "description": "<ul><li><strong>onblur</strong> - The onblur event occurs when an HTML element loses focus. event is often used on input fields. event is often used with form validation (when the user leaves a form field).</li><li><strong>onchange</strong> - The onchange event occurs when the value of an HTML element is changed.  This event is similar to the oninput event. The difference is that the oninput event occurs immediately after the value of an element has changed, while onchange occurs when the element loses focus, after the content has been changed. The other difference is that the onchange event also works on &lt;select&gt; elements.</li><li><strong>onclick</strong> - The onclick event occurs when the user clicks on an HTML element.</li><li><strong>oncontextmenu</strong> - The oncontextmenu event occurs when the user right-clicks an HTML element to open the context menu.</li><li><strong>onfocus, onfocusin</strong> - The onfocus event occurs when an element gets focus. This event is often used on input fields.</li><li><strong>onfocusout</strong> - The onfocusout event occurs when an element looses focus. This event is often used on input fields. This event is often used with form validation (when the user leaves a form field).</li><li><strong>oninput</strong> - The oninput event occurs when an element gets user input. This event occurs when the value of an &lt;input&gt; or &lt;textarea&gt; element is changed. This event is similar to the onchange event. The difference is that the oninput event occurs immediately after the value of an element has changed, while onchange occurs when the element loses focus, after the content has been changed. The other difference is that the onchange event also works on &lt;select&gt; elements.</li><li><strong>onkeydown</strong> - The onkeydown event occurs when the user presses a key on the keyboard.</li><li><strong>onkeyup</strong> - The onkeyup event occurs when the user releases a key on the keyboard.</li><li><strong>onload</strong> - The onload event occurs when an object has been loaded. onload is most often used within the <body> element to execute a script once a web page has completely loaded all content (including images, script files, CSS files, etc.). The onload event can be used to check the visitor's browser type and browser version, and load the proper version of the web page based on the information.</li><li><strong>onscroll</strong> - The onscroll event occurs when an element's scrollbar is being scrolled. use the CSS overflow style property to create a scrollbar for an element.</li><li><strong>onselect</strong> - The onselect event occurs after some text has been selected in an element. The onselect event is mostly used on &lt;input type=\"text\"&gt; or &lt;textarea&gt; elements.</li></ul>"
            },
            {
                "name": "Difference between DOMContentLoaded and load Events",
                "description": "<p>These two events <strong>DOMContentLoaded</strong> and <strong>load</strong> are used to check when a webpage has loaded completely. Still, there are some factors that determine the preference of one over the other.<br><br><strong>DOMContentLoaded</strong> event gets executed once the basic HTML document is loaded and its parsing has taken place. This event doesn’t wait for the completion of the loading of add-ons such as stylesheets, sub-frames and images/pictures.<br><br><img src='./assets/js/dom.png'><br><br><strong>Advantages of using DOMContentLoaded event:</strong></p><ul><li>It helps in improving user experience as it shows messages or content much faster.</li><li>It takes lesser time in loading the page.</li></ul><br><br><p><strong>load</strong> event performs its execution differently. This event gets completed once all the components i.e. DOM hierarchy along with associated features of a webpage such as CSS files, JavaScript files, images/pictures, and external links are loaded. So basically, the load event helps in knowing when the page has fully-loaded.<br><br><img src='./assets/js/load.png'><br><br><strong>Advantages of using load event:</strong></p><ul><li>This event helps in knowing when all the components of the webpage is loaded.</li></ul>"
            },
            {
                "name": "Draw a Simple JavaScript Dom (Document Object Model).",
                "description": "<p><img src='./assets/js/jsdom.png'></p>"
            },
            {
                "name": "What do you mean by Browser Object Model (BOM)?",
                "description": "<p>Browser Object Model is known as BOM. It allows users to interact with the browser. A browser's initial object is a window. As a result, you may call all of the window's functions directly or by referencing the window. The document, history, screen, navigator, location, and other attributes are available in the window object.</p>"
            },
            {
                "name": "Why Browser Object Model (BOM) introduced in JavaScript?",
                "description": "<p>To interact with the browser, the Browser Object Model has some properties and methods. Some examples include, the height and width of the window/ screen.<br><br>Some of its methods include:</p><ul><li>window.open() – To open a new window</li><li>window.close() – To close the current window</li><li>window.moveTo() – To move the current window</li><li>window.resizeTo() – To resize the current window</li></ul>"
            },
            {
                "name": "Which method is used to retrieve a character from a certain index?",
                "description": "<p>The charAt() function of the JavaScript string finds a char element at the supplied index. The index number begins at 0 and continues up to n-1, Here n is the string length. The index value must be positive, higher than, or the same as the string length.</p>"
            },
            {
                "name": "What are arrow functions?",
                "description": "<p>Arrow functions were introduced in the ES6 version of javascript. They provide us with a new and shorter syntax for declaring functions. Arrow functions can only be used as a function expression.<br><br>Let’s compare the normal function declaration and the arrow function declaration in detail:<br><br><img src='./assets/js/arrow.png'><br><br>Arrow functions are declared without the function keyword. If there is only one returning expression then we don’t need to use the return keyword as well in an arrow function as shown in the example above. Also, for functions having just one line of code, curly braces { } can be omitted.<br><br><img src='./assets/js/arrow1.png'><br><br>If the function takes in only one argument, then the parenthesis () around the parameter can be omitted as shown in the code above.<br><br><img src='./assets/js/arrow2.png'><br><br>The biggest difference between the traditional function expression and the arrow function is the handling of <strong>this </strong>keyword. By general definition, <strong>this </strong>keyword always refers to the object that is calling the function. As you can see in the code above, <strong>obj1.valueOfThis() </strong>returns obj1 since <strong>this </strong>keyword refers to the object calling the function.<br><br>In the arrow functions, there is no binding of <strong>this </strong>keyword. <strong>This</strong> keyword inside an arrow function does not refer to the object calling it. It rather inherits its value from the parent scope which is the window object in this case. Therefore, in the code above, <strong>obj2.valueOfThis() </strong>returns the window object.</p>"
            },
            {
                "name": "What advantages are using arrow functions?",
                "description": "<ul><li><em>Compactness</em>: Arrow functions are easier to read and write.</li><li><em>Clarity</em>: When almost everything is an arrow function, any regular function immediately sticks out for defining the scope. A developer can always look up the next-higher function statement to see what this <code>this </code>object is.</li><li><em>Scope safety</em>: Until arrow functions, every new function defined its own value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an \"object method\", etc.). An arrow function does not create its own this, the <code>this </code>value of the enclosing execution context is used.</li></ul>"
            },
            {
                "name": "When should you NOT use arrow functions in ES6 ",
                "description": "<p>Arrow functions should NOT be used:</p><ul><li>When we want function hoisting - as arrow functions are anonymous.</li><li>When we want to use this/arguments in a function - as arrow functions do not have this/arguments of their own, they depend upon their outer context.</li><li>When we want to use named function - as arrow functions are anonymous.</li><li>When we want to use function as a constructor - as arrow functions do not have their own this.</li><li>When we want to add function as a property in object literal and use object in it - as we can not access this (which should be object itself).</li></ul>"
            },
            {
                "name": "Prototypal Design Pattern?",
                "description": "<p>The Prototype Pattern produces different objects, but instead of returning uninitialized objects, it produces objects that have values replicated from a template – or sample – object. Also known as the Properties pattern, the Prototype pattern is used to create prototypes.<br><br>The introduction of business objects with parameters that match the database's default settings is a good example of where the Prototype pattern comes in handy. The default settings for a newly generated business object are stored in the prototype object.<br><br>The Prototype pattern is hardly used in traditional languages, however, it is used in the development of new objects and templates in JavaScript, which is a prototypal language.</p>"
            },
            {
                "name": "What is Prototypal Inheritance?",
                "description": "<p>Prototypal inheritance is to add new capabilities to a constructor function using Prototype.<br>Let's first understand what are Constructor functions. They are basically JavaScript way to implement the concept of Classes.<br>Let's consider the example below, where we have a “Car” constructor function. In it we have a “model”, which we are also returning by getModel(). Now we can create a new instance of it by using the “new” keyword. Each instance will have its own “this” and have its own getModel().<br><br><img src='./assets/js/functionprototype2.jpg'><br><br>Now, the problem is that every time we create a new instance we get a new copy of <em>getModel().</em> Suppose we have 100 instances, then we will have 100 copies.<br><br>In JavaScript as you know everything is an Object. Whenever a function is created there are two object one is the function object another is the prototype object. Now to access the <strong>Prototype</strong> object we have a property on the function object also known as “<strong>prototype</strong>”.<br><br>We should somehow move the logic for&nbsp;<em>getModel()</em> outside our Constructor function and that is where the concept of Prototype helps.<br><br><img src='./assets/js/functionprototype3.jpg'><br><br>We get the same result and this is known as <strong>Prototypal Inheritance</strong>. Also, each new instance don’t have its own getModel(), which we can see in below console log.<br><br><img src='./assets/js/functionprototype4.jpg'></p>"
            },
            {
                "name": "JavaScript Design Patterns?",
                "description": "<p>JavaScript design patterns are repeatable approaches for errors that arise sometimes when building JavaScript browser applications. They truly assist us in making our code more stable.<br><br>They are divided mainly into 3 categories&nbsp;</p><ul><li><strong>Creational Design Pattern: </strong>The object generation mechanism is addressed by the JavaScript Creational Design Pattern. They aim to make items that are appropriate for a certain scenario.</li><li><strong>Structural Design Pattern: </strong>The JavaScript Structural Design Pattern explains how the classes and objects we've generated so far can be combined to construct bigger frameworks. This pattern makes it easier to create relationships between items by defining a straightforward way to do so.</li><li><strong>Behavioral Design Pattern: </strong>This design pattern highlights typical patterns of communication between objects in JavaScript. As a result, the communication may be carried out with greater freedom.</li></ul>"
            },
            {
                "name": "What is the rest parameter and spread operator?",
                "description": "<p>Both rest parameter and spread operator were introduced in the ES6 version of javascript.<br><br><strong>Rest parameter ( … ):</strong></p><ul><li>It provides an improved way of handling the parameters of a function.</li><li>Using the rest parameter syntax, we can create functions that can take a variable number of arguments.</li><li>Any number of arguments will be converted into an array using the rest parameter.</li><li>It also helps in extracting all or some parts of the arguments.</li><li>Rest parameters can be used by applying three dots (...) before the parameters.</li></ul><br><img src='./assets/js/rest.png'><br><br><strong>**Note- Rest parameter should always be used at the last parameter of a function:</strong></p><br><br><p><strong>Spread operator (…): </strong>Although the syntax of the spread operator is exactly the same as the rest parameter, the spread operator is used to spreading an array, and object literals. We also use spread operators where one or more arguments are expected in a function call.<br><br><img src='./assets/js/spread.png'><br><br><strong>***Note</strong> - Key differences between rest parameter and spread operator:</p><ul><li>Rest parameter is used to take a variable number of arguments and turns them into an array while the spread operator takes an array or an object and spreads it</li><li>Rest parameter is used in function declaration whereas the spread operator is used in function calls.</li></ul>"
            },
            {
                "name": "What are the benefits of using spread syntax in ES6 and how is it different from rest syntax?",
                "description": "<p>ES6's spread syntax is very useful when coding in a functional paradigm as we can easily create copies of arrays or objects without resorting to <code>Object.create</code>, <code>slice</code>, or a library function. This language feature is used often in Redux and rx.js projects.<br><br><img src='./assets/js/es6spread.png'><br><br>ES6's rest syntax offers a shorthand for including an arbitrary number of arguments to be passed to a function. It is like an inverse of the spread syntax, taking data and stuffing it into an array rather than unpacking an array of data, and it works in function arguments, as well as in array and object destructuring assignments.<br><br><img src='./assets/js/es6rest.png'></p>"
            },
            {
                "name": "What are promises JavaScript?",
                "description": "<p>They are mainly used to do asynchronous task like calling a REST api and getting the result back. So, these network calls takes time.<br><br>When the network call is been made, the promise is in <strong>pending state</strong> which means promise has neither been fulfilled nor been rejected, it is in the pending state.<br><br>Once the network call is successful the promise returns a resolve function which means the async operation is completed and in case if it fails it returns reject function meaning operation has failed.<br><br>The resolve is captured by the .then() callback function and reject captured by .catch() callback function.<br><br>Optionally we can also use the fourth state called settled state which schedules a function to be called when the promise is settled i.e. either fulfilled or rejected. The settled is captured by the .finally() callback function</p>"
            },
            {
                "name": "What are classes in javascript?",
                "description": "<p>Introduced in the ES6 version, classes are nothing but syntactic sugars for constructor functions. They provide a new way of declaring constructor functions in javascript.<br><br>Key points to remember about classes:<ul><li>Unlike functions, classes are not hoisted. A class cannot be used before it is declared.</li><li>A class can inherit properties and methods from other classes by using the extend keyword.</li><li>All the syntaxes inside the class must follow the strict mode(‘use strict’) of javascript. An error will be thrown if the strict mode rules are not followed.</li></ul><br><img src='./assets/js/class.png'></p>"
            },
            {
                "name": "What are generator functions?",
                "description": "<p>Introduced in ES6 version, generator functions are a special class of functions.<br><br><strong>They can be stopped midway and then continue from where it had stopped.</strong><br><br>Generator functions are declared with the <strong>function*</strong> keyword instead of the normal <strong>function</strong> keyword<br><br><pre>function* genFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;// Perform operation<br>}</pre><br><br>In normal functions, we use the <strong>return</strong> keyword to return a value and as soon as the return statement gets executed, the function execution stops:<br><br> <pre> function normalFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;return 22;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(2); // This line of code does not get executed<br>}</pre> <br><br>In the case of generator functions, when called, they do not execute the code, instead they return a <strong>generator object</strong>. This generator object handles the execution<br><br><pre> function* genFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 3;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 4;<br>}<br>genFunc(); // Returns Object [Generator]{}</pre><br><br>The generator object consists of a method called <strong>next()</strong> , this method when called, executes the code until the nearest <strong>yield</strong> statement, and returns the yield value.<br><br><img src='./assets/js/generator.png'><br><br>As you can see in the code above, the last line returns done:true , since the code reaches the return statement.</p>"
            },
            {
                "name": "Explain WeakSet in javascript.",
                "description": "<ul><li>Weakset contains only objects and no other type.</li><li>An object inside the weakset is referenced weakly. This means, that if the object inside the weakset does not have a reference, it will be garbage collected.</li><li>Unlike Set, WeakSet only has three methods, <strong>add() </strong>, <strong>delete() </strong>and <strong>has() </strong>.</li></ul><br><img src='./assets/js/weakset.png'>"
            },
            {
                "name": "Differences between WeakSet and Set",
                "description": "<p>The main difference is that references to objects in Set are strong while references to objects in WeakSet are weak. i.e, An object in WeakSet can be garbage collected if there is no other reference to it. Other differences are,</p><ol><li>Sets can store any value Whereas WeakSets can store only collections of objects</li><li>WeakSet does not have size property unlike Set</li><li>WeakSet does not have methods such as clear, keys, values, entries, forEach.</li><li>WeakSet is not iterable.</li></ol>"
            },
            {
                "name": "Explain WeakMap in javascript.",
                "description": "<p>In javascript, Map is used to store key-value pairs. The key-value pairs can be of both primitive and non-primitive types. WeakMap is similar to Map with key differences:</p><ul><li>The keys and values in weakmap should always be an object.</li><li>If there are no references to the object, the object will be garbage collected.</li></ul><br><img src='./assets/js/weakmap.png'>"
            },
            {
                "name": "Differences between WeakMap and Map",
                "description": "<p>The main difference is that references to key objects in Map are strong while references to key objects in WeakMap are weak. i.e, A key object in WeakMap can be garbage collected if there is no other reference to it. Other differences are,</p><ol><li>Maps can store any key type Whereas WeakMaps can store only collections of key objects</li><li>WeakMap does not have size property unlike Map</li><li>WeakMap does not have methods such as clear, keys, values, entries, forEach.</li><li>WeakMap is not iterable.</li></ol>"
            },
            {
                "name": "Explain Destructuring in ES6?",
                "description": "<p>Destructuring is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. You can also handle nested structure by using nested destructuring syntax.<br><br><strong>Object Destructuring - You use an object literal on the left-hand-side of an assignment expression</strong> for object destructuring.<br><br><img src='./assets/js/objdestructure2.jpg'><br><br><strong>Nested Object Destructuring</strong><br>If there is nested object as in below case, we can destructure it by adding it's value to another object syntax<br><br><img src='./assets/js/objdestructure3.jpg'><br><br><strong>Array Destructuring</strong><br>Array destructuring is similar to object destructuring, but here instead of keys you assign any variable.<br><br><img src='./assets/js/objdestructure4.jpg'><br><br><strong>Skipping Items</strong><br>It is possible to skip items in array destructuring by omitting items with comma(,).<br><br><img src='./assets/js/objdestructure5.jpg'></p></div>"
            },
            {
                "name": "Difference between prototypal and classical inheritance",
                "description": "<p>Programers build objects, which are representations of real-time entities, in traditional OO programming. Classes and objects are the two sorts of abstractions. A class is a generalization of an object, whereas an object is an abstraction of an actual thing. A Vehicle, for example, is a specialization of a Car. As a result, automobiles (class) are descended from vehicles (object).<br><br>Classical inheritance differs from prototypal inheritance in that classical inheritance is confined to classes that inherit from those remaining classes, but prototypal inheritance allows any object to be cloned via an object linking method. Despite going into too many specifics, a prototype essentially serves as a template for those other objects, whether they extend the parent object or not.</p>"
            },
            {
                "name": "What is Temporal Dead Zone?",
                "description": "<p>Temporal Dead Zone is a behaviour that occurs with variables declared using <strong>let </strong>and <strong>const </strong>keywords. It is a behaviour where we try to access a variable before it is initialized. Examples of temporal dead zone:<br><br><img src='./assets/js/deadZone.png'><br><br><strong>Example 2</strong><br><br><img src='./assets/js/deadZone1.png'><br><br>In the code above, both in the global scope and functional scope, we are trying to access variables that have not been declared yet. This is called the <strong>Temporal Dead Zone</strong>.</p>"
            },
            {
                "name": "Difference between Async/Await and Generators usage to achieve the same functionality.",
                "description": "<ul><li>Generator function are executed yield by yield i.e one yield-expression at a time by its iterator (the next method) where as Async-await, they are executed sequential await by await.</li><li>Async/await makes it easier to implement a particular use case of Generators.</li><li>The return value of Generator is always {value: X, done: Boolean} where as for Async function it will always be a promise that will either resolve to the value X or throw an error.</li><li>Async function can be decomposed into Generator and promise implementation like:</li></ul><p><img src='./assets/js/asyncAwaitGenerator.png'></p>"
            },
            {
                "name": "What is the role of deferred scripts in JavaScript?",
                "description": "<p>The processing of HTML code while the page loads are disabled by nature till the script hasn't halted. Your page will be affected if your network is a bit slow, or if the script is very hefty. When you use Deferred, the script waits for the HTML parser to finish before executing it. This reduces the time it takes for web pages to load, allowing them to appear more quickly.</p>"
            },
            {
                "name": "What is the object and array type?",
                "description": "<p>The object type refers to a compound value where you can set properties (named locations) that each hold their own values of any type.<br><br><img src='./assets/js/object.png'><br><br>An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions:<br><br><img src='./assets/js/array.png'></p>"
            },
            {
                "name": "What is event bubbling and capturing in JavaScript?",
                "description": "<p>For this we need to understand Event flow is the order in which event is received on the web page. When you click an element that is nested in various other elements, before your click actually reaches its destination, or target element, it must trigger the click event for each of its parent elements first, starting at the top with the global window object. <br><br>We will first see <strong>Event Bubbling</strong>. - In this the event propagation, the event first triggers on the innermost target element .i.e. the child element first, and then successively triggers on the ancestors i.e. parents element in the order of the elements nested hierarchy till it reaches the outermost DOM element. <br><br><strong>It is totally vice-versa of Event Bubbling</strong><br><br>Where as in <strong>Event Capturing</strong>. - the event propagation, the event first triggers on the outermost element .i.e. the parent element first, and then successively triggers on the descendants i.e. child element in the order of the elements nested hierarchy till it reaches the innermost DOM element.</p>"
            },
            {
                "name": "Explain async await in JavaScript?",
                "description": "<p>The <code>Async</code> keyword is short for 'Asynchronous' and in always positioned before a function. This is done to indicate an <code>Async</code> function and more importantly, that the function being specified as <code>Async</code> will always return a promise.<br><br>The body of an <code>Async</code> function can contain zero or more <code>Await</code> keywords. The difference between an <code>Async</code> function with one or more <code>Await</code> keywords and one without any <code>Await</code> keywords is that the non <code>Await</code> function will behave in a synchronous manner while the one containing one or more <code>Await</code> keywords will act in an asynchronous way.<br><br>Next, we have the <code>Await</code> keyword. This keyword is only valid inside <code>Async</code> functions and it primarily serves to make JavaScript wait until the promise inside the <code>Async</code> function settles and returns a result. This single keyword is responsible for converting synchronous functions into asynchronous ones, just by the act of allowing other processes to run while awaiting a value from a promise(no pun intended :) ). So note that it only makes the promise containing code block wait, while the rest of the program executes normally.</p>"
            },
            {
                "name": "Explain Promise.all with async-await?",
                "description": "<p>The <em>Promise.all &nbsp;</em>method returns a single Promise that resolves when all of the promises in the <em>iterable</em> argument have resolved or when the <em>iterable</em> argument contains no promises. It rejects with the reason of the first promise that rejects.<br><br><img src='./assets/js/promiseall.jpg'><br><br>We should use <em>Promise.all</em> in only cases like above, where the result of one Promise is not dependent on other promise.</p>"
            },
            {
                "name": "Explain nested promises JavaScript?",
                "description": "<p>Nested promises are set of promises in which , the result of one promise we call another in the .then statement. It is very useful in practical applications, where the result of fetch from an API endpoint will result in sending the data to another endpoint. Nested promises can also be done with callback functions, but the code get complicated soon.<br><br>Let's look at an example of nested promises. Here we have three functions which return promises- <em>coinTossed, gotCoinTossedResult and happyTeam</em>. Now only the <em>coinTossed</em> is returning resolve() or reject() depending on random number. The other two functions are returning only resolve() for simplicity sake.<br><br>Now, when the <em>coinTossed</em> function is run and return a resolve(), then the immediate .then block will be run or else we will go to the .catch block. In the .then we are returning the next <em>gotCoinTossedResult&nbsp;</em>and in its .then we are returning the <em>happyTeam</em>. We are passing the message from one function to other, so it will be appended.<br><br><img src='./assets/js/cointoss.png'></p>"
            },
            {
                "name": "How do we handle errors in async-await function?",
                "description": "<p>In Promises we handle any error or reject in the .catch block. Let's look at the below example, where we are sending reject() from Promise inside a function expression. So, now the error will be caught by the .catch block and then we are displaying the same in console log.<br><br><strong>try…catch block available in JavaScript</strong><br><br><img src='./assets/js/tryCatch.png'></p>"
            },
            {
                "name": "What are the limitations of JavaScript?",
                "description": "<ol> <li><strong>Writing files on server</strong> - JavaScript cannot directly write files on server. However, they can do this using server-side script</li><li><strong>Disable JavaScript</strong> - Due to security reasons, every web browser provides an option to disable JavaScript.</li><li><strong>Networking</strong> - It cannot be used for Networking applications.</li><li><strong>Browser Compatibility</strong> - Applications may behave differently in different web browsers. To support all modern browsers, you need to write cross browser codes.</li><li><strong>Security</strong> - Since the code executes on client's computer, the chances are high for vulnerability and can be exploited for malicious purposes</li><li><strong>Databases</strong> - JavaScript cannot access databases. You need AJAX and a server-side script for this.</li></ol>"
            },
            
            {
                "name": "Different ways to make an object non-extensible?",
                "description": "<p>You can mark an object non-extensible in 3 ways,</p><ol> <li><strong>Object.freeze()</strong> - simply converts an object passed as the argument into a frozen state. An object called by this method can not have any further changes on it. <ul> <li>Cannot add new properties.</li><li> Cannot remove existing properties.</li><li> Cannot change existing property values.</li><li> Cannot reconfigure any existing property. writable and configurable are set to false.</li><li> Cannot change its prototype.</li></ul> <p> Trying to make any changes mentioned above after an object being frozen will fail and will throw errors in strict mode.<br><br><strong><em>Object.isFrozen()</em></strong> is an Object method to check if an object is frozen by passing the object as the argument, where the return type is a boolean</p></li><br><li> <strong>Object.seal() </strong>simply converts an object passed as the argument into a sealed state. An object called by this method can not have any new properties being added. But it <strong>can change</strong> existing property values as long as <em>writable</em> metadata is true. <ul> <li>Cannot add new properties.</li><li> Cannot remove existing properties.</li><li> Cannot reconfigure any existing property.</li><li> Cannot convert a data property to accessor property or vice versa.</li></ul> <p><strong><em>Object.isSealed()</em></strong> is an Object method to check if an object is sealed by passing the object as the argument, where the return type is a boolean</p></li><br><li> <strong>Object.preventExtensions() </strong>simply converts an object passed as the argument into a non-extensible state. An object called by this method can not have any new properties being added. This method inherits functionality from its superset object.seal. Hence, it <strong>can change</strong> existing property values as long as <em>writable</em> metadata is true. In contrast to sealed objects, non-extensible objects can be deleted or reconfigured. <p><strong><em>Object.isExtensible()</em></strong> is an Object method to check if an object is extensible by passing the object as the argument.</p></li></ol>"
            },
            {
                "name": "Difference between const vs Object.freeze()",
                "description": "<p>In <strong>const</strong> reassignment of the variable is not allowed but the value referenced by the const variable can still be changed. <br><br>#Ex. Value is Immutable<br> <img src='./assets/js/const-object.png'> <br><br>#Binding is Mutable<br> <img src='./assets/js/const-object1.png'><br><br>#Mutable binding with object<br> <img src='./assets/js/const-object2.png'></p><br><br><p><strong>Object.freeze()</strong> prevents modification or extension to the existing value of an object. <br><br>Ex. Ignoring the value modification to an object<br> <img src='./assets/js/const-object3.png'> <br><br>#But the same work on binding<br> <img src='./assets/js/const-object4.png'></p>"
            },
            {
                "name": "Difference between Object.values() vs Object.entries()",
                "description": "<p><code>Object.values()</code> takes an object and returns an array with the values, in the same order that a for…in loop function would give us. Object.values doesn’t follow the prototype chain and only iterates over the value that are directly on the provided object.<br><img src='./assets/js/object-value.png'><br><br><strong>Object.entries()</strong> returns an array with arrays of key-value pairs:<br><img src='./assets/js/object-entries.png'></p>"
            },
            {
                "name": "Difference between native, host and user objects?",
                "description": "<ul><li>Native objects are objects that are part of the JavaScript language defined by the ECMAScript specification, such as <code>String</code>, <code>Math</code>, <code>RegExp</code>, <code>Object</code>, <code>Function</code>, etc.</li><li>Host objects are provided by the runtime environment (browser or Node), such as <code>window</code>, <code>XMLHTTPRequest</code>,<code>DOM</code> nodes etc.</li><li><code>User objects</code> are objects defined in the javascript code. For example, User object created for profile information</li></ul>"
            },
            {
                "name": "'Deep-Freeze' object in JavaScript?",
                "description": "<p>To make an object immutable, we generally use utilize <code>Object.freeze()</code>, which prevents the addition of new properties and prevent deletion and changes to existing properties to some extent. However, while <code>Object.freeze()</code> provides somewhat kind of a solution, it only handles the problem to the next nesting level, as in reality it performs a shallow freeze during its process. This means that properties that are objects or arrays can still be mutated:<br><br><img src='./assets/js/freezeexample.png'><br><br>Here to solve the issue we can use recursion method, by checking if each property is itself an object using, <code>Object.isFrozen()</code> method which is returning <code >false</code>, then apply <code>Object.freeze()</code> to it:<br><br><img src='./assets/js/deepfreezeexample.png'></p>"
            },
            {
                "name": "How do you check if a key exists in an object?",
                "description": "<ul> <li>Traditional way <br><pre>var user = {name:'test'} <br>//Test condition <br>user.name === undefined //Output <br> true</pre> </li><li> The <strong><code>hasOwnProperty()</code></strong> method returns a boolean indicating whether the object has the specified property or not in it. <br><pre>object_name.hasOwnProperty('key_name')</pre> </li><li>Using <code>'in'</code> operator - <br><pre>!(keyName in objectName);</pre></li></ul>"
            },
            
            {
                "name": "instanceof / typeof operator in JavaScript",
                "description": "<p>If you want to check the type of an object at runtime, then use the instanceof operator where the result is a boolean.<br><br>where as typeof operator is used to find the data type of a JavaScript variable where the result is a string.</p>"
            },
            {
                "name": "String Reference",
                "description": "<ul> <li><strong>charAt(x)</strong> - This function will return the character at the x position within the string.<br><img src='./assets/js/stringcharat.png'><br><br></li><li><strong>charCodeAt(x)</strong> - This function will return the unicode value of the character at position ‘x’ within the string.<br><img src='./assets/js/stringchartat.png'><br><br></li><li><strong>concat(v1,v2..)</strong> - This function combines one or more strings(argv1,v2 etc) into existing one.<br><img src='./assets/js/stringconcat.png'><br><br></li><li><strong>fromCharcode(c1,c2)</strong> - This function will return a string created by using specified sequence of unicode values(argc1,c2).<br><img src='./assets/js/stringfromcharcode.png'><br><br></li><li><strong>indexOf(substr, [start])</strong> - Searches and (if found) returns the index number of the searched character or substring within the string. If not found, -1 is returned. “Start” is an optional argument specifying the position within string to begin the search. Default is 0.<br><img src='./assets/js/stringindexof.png'><br><br></li><li><strong>lastIndexOf(substr, [start])</strong> - Searches and (if found) returns the index number of the searched character or substring within the string. Searches the string from end to the beginning. If not found, -1 is returned. “Start” is an optional argument specifying the position within string to begin the search. Default is string.length-1.<br><img src='./assets/js/stringlastindexof.png'><br><br></li><li><strong>match(regexp)</strong> - Executes a search for a match within a string based on a regular expression. It returns an array of information or null if no match is found.<br><img src='./assets/js/stringmatch.png'><br><br></li><li><strong>replace(regexp/substr, replacetext)</strong> - Searches and replaces the regular expression (or sub string) portion (match) with the replaced text instead.<br><img src='./assets/js/stringreplace.png'><br><br></li><li><strong>search(regexp)</strong> - Tests for a match in a string. It returns the index of the match, or -1 if not found.<br><img src='./assets/js/stringsearch.png'><br><br></li><li><strong>slice(start, [end])</strong> - This function returns a substring of the string based on the “start” and “end” index arguments, NOT including the “end” index itself. “End” is optional, and if none is specified, the slice includes all characters from “start” to end of the string.<br><img src='./assets/js/stringslice.png'><br><br></li><li><strong>split(delimiter, [limit])</strong> - This will split a string into many according to the specified delimiter, and returns an array containing each element. The optional “limit” is an integer that lets you specify the maximum number of elements to return.<br><img src='./assets/js/stringsplit.png'><br><br></li><li><strong>substr(start, [length])</strong> - This function returns the characters in a string beginning at “start” and through the specified number of characters, “length”. “Length” is optional, and if omitted, up to the end of the string is assumed.<br><img src='./assets/js/stringsubstr.png'><br><br></li><li><strong>substring(from, [to])</strong> - It returns the characters in a string between “from” and “to” indexes, NOT including “to” itself. “To” is optional, and if omitted, up to the end of the string is assumed.<br><img src='./assets/js/stringsubstring.png'><br><br></li><li><strong>toLowerCase()</strong> - This will return the string with all of its characters converted to lowercase.<br><img src='./assets/js/stringlowercase.png'><br><br></li><li><strong>toUpperCase()</strong> - This will return the string with all of its characters converted to uppercase.<br><img src='./assets/js/stringuppercase.png'><br><br></li><li><strong>includes()</strong> - It is used to check whether a string contains the specified string or characters.<br><img src='./assets/js/stringincludes.png'><br><br></li><li><strong>endsWith()</strong> - This function checks whether a string ends with specified string or characters.<br><img src='./assets/js/stringendwith.png'><br><br></li><li><strong>repeat()</strong> - This returns a new string with a specified number of copies of an existing string.<br><img src='./assets/js/stringrepeat.png'><br><br></li><li><strong>valueOf()</strong> - It is used to return the primitive value of a String object.<br><img src='./assets/js/stringvalueof.png'><br><br></li><li><strong>trim()</strong> - This function removes whitespace from both ends of a string.<br><img src='./assets/js/stringtrim.png'><br><br></li></ul>"
            },
            {
                "name": "toString() vs join()?",
                "description": "<p>array.toString() and array.join() does the same thing of converting an array into a string. Since toSting() does not accept any arguments its is less preferred while in join() one can pass arguments. Ex. [1,2,3].join(', ')</p>"
            },
            {
                "name": "Explain join() vs concat() in Javascript",
                "description": "<p>To join two or more strings, use the JavaScript <code>string.concat(string1, string2, ..., stringX)</code> method. A new string is returned with the joined strings.<br><br>The <code>array.join(separator)</code> method returns an array as a string. The elements will be separated by a specified separator. The default separator is comma (,).<br><br><code>join()</code> does not change the original array.</p>"
            },
            {
                "name": "Remove whitespace from both sides of a string in JavaScript",
                "description": "<p>The <code>trim()</code> method is used to remove whitespace from both sides of a string.<br><br><pre>var myStr = \" &nbsp; &nbsp; Cup of tea! &nbsp; &nbsp;\";<br>myStr.trim( ) <br><br>// Output - 'Cup of tea!'</pre>"
            },
            {
                "name": "How do you make first letter of the string in an uppercase?",
                "description": "<img src='./assets/js/first-letter-capital.png'>"
            },
            {
                "name": "How to convert string to title case with javascript?",
                "description": "<img src='./assets/js/first-letter-capital1.png'>"
            },
            {
                "name": "How do you check whether a string contains a substring?",
                "description": "<p>There are 3 possible ways to check whether a string contains a substring or not,</p><ul><li>Using includes(): String.includes() method to test a string contains a substring<br><img src='./assets/js/substring.png'></li><li>Using indexOf(): String.indexOf() which returns the index of a substring. If the index value is not equal to -1 then it means the substring exist in the main string.<br><img src='./assets/js/substring1.png'></li><li>Using RegEx: The advanced solution is using Regular expression's test method(RegExp.test), which allows for testing for against regular expressions<br><img src='./assets/js/substring2.png'></li></ul>"
            },
            {
                "name": "Search for a string in a string with JavaScript (search() / includes())",
                "description": "<p>To search for a string in a string, use the search() method. The method searches a string for a specified value. The returned value is the position of the match. However, -1 is returned if the match isn’t found.<br><br>Where as the <code>includes()</code> method returns true if a string contains a specified string, otherwise false</p>"
            },
            {
                "name": "Difference between substr() vs substring() vs slice() in JavaScript?",
                "description": "<p>The substr() and substring() methods are simpler, yet they have some differences. The 2nd argument of the substring() method is the index to halt the search, whereas the 2nd&nbsp;parameter of substr() is the maximum length.<br><br><strong>substr() method</strong> - The substr() method returns the characters in a string beginning at the specified location. It goes through the number of characters which is specified by the user. The parameters of substr(start, len):</p><ul><li>start&nbsp;− Location start extracting characters.</li><li>length&nbsp;− The count of characters to extract.</li></ul><pre>let str = \"Hello world!\"; <br> str.substr(1, 4) <br> // Console Returns \"ello\"</pre><br><br><p><strong>substring() method</strong> - The substring() method returns subset of a string. The parameters of substring(i1, i2):</p><ul><li>i1&nbsp;– Index from where you want the substring.</li><li>i2&nbsp;− Index till when you want the substring.</li></ul><pre>let str = \"Hello world!\"; <br> str.substring(1, 4) <br> // Console Returns \"ell\"</pre>"
            },
            {
                "name": "Array Reference",
                "description": "<ul> <li><strong>map( )</strong> - This method creates a new array with the results of calling a provided function on every element in this array. <br><img src='./assets/js/arraymap.png'><br><br></li><li><strong>filter( )</strong> - This method creates a new array with only elements that passes the condition inside the provided function.<br><img src='./assets/js/arrayfilter.png'><br><br></li><li><strong>sort( )</strong> - This method is used to arrange/sort array's elements either in ascending or descending order.<br><img src='./assets/js/arraysort.png'><br><br></li><li><strong>forEach( )</strong> - This method helps to loop over array by executing a provided callback function for each element in an array.<br><img src='./assets/js/arrayforeach.png'><br><br></li><li><strong>concat( )</strong> - This method is used to merge two or more arrays and returns a new array, without changing the existing arrays.<br><img src='./assets/js/arrayconcat.png'><br><br></li><li><strong>every( )</strong> - This method checks every element in the array that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arrayevery.png'><br><br></li><li><strong>some( )</strong> - This method checks if at least one element in the array that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arraysome.png'><br><br></li><li><strong>includes( )</strong> - This method checks if an array includes the element that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arrayincludes.png'><br><br></li><li><strong>join( )</strong> - This method returns a new string by concatenating all of the array's elements separated by the specified separator.<br><img src='./assets/js/arrayjoin.png'><br><br></li><li><strong>reduce( )</strong> - <p>Reduce the values of an array to a single value (going left-to-right) and for right-to-left use reduceRight().<br>The reduce() method executes a provided function for each value of the array (from left-to-right)<br>The return value of the function is stored in an accumulator (result/total)<br><img src='./assets/js/reduce.png'><br><br></li><li><strong>find( )</strong> - This method returns the value of the first element in an array that pass the test in a testing function.<br><img src='./assets/js/arrayfind.png'><br><br></li><li><strong>findIndex( )</strong> - This method returns the index of the first element in an array that pass the test in a testing function.<br><img src='./assets/js/arrayfindindex.png'><br><br></li><li><strong>indexOf( )</strong> - This method returns the index of the first occurrence of the specified element in the array, or -1 if it is not found.<br><img src='./assets/js/arrayindexof.png'><br><br></li><li><strong>fill( )</strong> - This method fills the elements in an array with a static value and returns the modified array.<br><img src='./assets/js/arrayfill.png'><br><br></li><li><strong>slice( )</strong> - This method returns a new array with specified start to end elements.<br><img src='./assets/js/arrayslice.png'><br><br></li><li><strong>reverse( )</strong> - This method reverses an array in place. Element at last index will be first and element at 0 index will be last.<br><img src='./assets/js/arrayreverse.png'><br><br></li><li><strong>push( )</strong> - This method adds one or more elements to the end of array and returns the new length of the array.<br><img src='./assets/js/arraypush.png'><br><br></li><li><strong>pop( )</strong> - Remove an item from the end of an array and returns the item(string) which was removed from that array<br><img src='./assets/js/pop.png'><br><br></li><li><strong>shift( )</strong> - This method removes an item from the start of an array and returns the item which was removed from that array<br><img src='./assets/js/arrayshift.png'><br><br></li><li><strong>unshift( )</strong> - This method adds one or more elements to the beginning of an array and returns the new length of the array.<br><img src='./assets/js/arrayunshift.png'><br><br></li></ul>"
            },
            {
                "name": "Difference between some() vs every() in javascript",
                "description": "<p>The <code>some()</code> method checks if any of the elements in an array pass a test (provided as a function)., where as the <code>every()</code> method returns true if all elements in an array passes the test (provided as a function).<br><br><code>some()</code> executes the function once for each element in the array: which means, during the execution If it finds an array element where the function is returning a <em>true</em> value against the test condition, then some() method returns true (and does not check the remaining values), Otherwise it returns false<br><br>The <code>every()</code> method executes the function once for each element present in the array: which means, during the execution If it finds an array element where the function is returning a <em>false</em> value against the test condition, then every() method returns false (and does not check the remaining values), Otherwise it returns true<br><br><strong>Both</strong> does not execute the function for empty array elements.<br><br><strong>Both</strong> does not change the original array.</p>"
            },
            {
                "name": "How to check if an object is an array or not? (object is array)",
                "description": "<p><img src='./assets/js/arrayorobject.png'></p>"
            },
            {
                "name": "List different ways of empty array in Javascript?",
                "description": "<p>In Javascript,&nbsp;there are many ways to empty an array in Javascript, below we have listed 4 major<br><br><img src='./assets/js/emptyarray.png'></p>"
            },
            {
                "name": "How do you add an element at the begining of an array? How do you add one at the end?",
                "description": "<p><img src='./assets/jsCode/addelement.png'></p>"
            },
            {
                "name": "Remove element from an array in JavaScript (splice)",
                "description": "<p>To remove a single element from an array in JavaScript, the splice() method is used. With that you can also replace, and/or add elements in an array.<br><br>We are using the splice() method to remove a single element by setting the location from where it start, and the number of elements to be removed. Here, we have set 1, therefore only a single element will get removed:</p><pre><pre>let myArr = [1,2,3,4,5];<br>let newArr = myArr.splice(3, 1);<br>console.log(myArr);<br>console.log(newArr);<br><br>// Output <br>[1, 2, 3, 5]<br>[4]</pre>"
            },
            {
                "name": "Methods to Search Through Arrays (include, find, filter)",
                "description": "<p>The <code>.includes()</code> method returns a boolean value and is perfect for telling you whether an element exists in an array or not. It gives a simple true or false answer.<br><strong>Syntax</strong>: <code>arr.includes(valueToFind, [fromIndex]); //fromIndex is optional</code><br><strong>Example</strong>: <code>const alligator = ['thick scales', 80, '4 foot tail', 'rounded snout'];<br>alligator.includes('thick scales'); // returns true</code><br><br>The <code>.find()</code> method is used to find and return the first occurence of an element in an array, under a defined testing function. and if the condition is not met, it returns <code>undefined</code><br><strong>Syntax</strong>: <code>array.find(testingFunction);</code><br><code>const trees = [<br> { name: 'birch', count: 4 },<br> { name: 'oak', count: 2 }<br> { name: 'maple', count: 5 },<br> { name: 'oak', count: 8 }<br> ];<br><br> const result = trees.find(tree => tree.name === 'oak');<br> // { name: 'oak', count, 2 }</code><br><br>The <code>.filter()</code> method is like the find() method, in that it requires a function passed and a condition for what will be returned. The main difference is, filter() always returns an array, even if there is only one matching element. But it will return all the matching elements, whereas find() only returns the first matching. The important thing with filter is that it returns all the elements matching your criteria.<br><strong>Syntax</strong>:<code>var newArray = array.filter(function(item) {<br> return condition;<br> });</code><br><code>var heroes = [ <br> {name: 'Batman', franchise: 'DC'}, <br> {name: 'Ironman', franchise: 'Marvel'}, <br> {name: 'Thor', franchise: 'Marvel'}, <br> {name: 'Superman', franchise: 'DC'} <br> ]; <br> <br> var marvelHeroes = heroes.filter(function(hero) { <br> return hero.franchise == 'Marvel'; <br> }); <br> <br> // [ {name: 'Ironman', franchise: 'Marvel'}, {name: 'Thor', franchise: 'Marvel'} ]</code></p>"
            },
            {
                "name": "What are the different types of pop-up boxes in JavaScript?",
                "description": "<p><strong>Alert Box</strong> - The alert box is for an alert or message to the user. User needs to click “OK”. The alert() method is used to add a message in the alert:<br><br><strong>Prompt Box</strong> - To input a value from the user and display it, use the prompt box. Users need to click “OK” to return the entered input, else click “Cancel” to return null.<br><br><strong>Confirm Box</strong> - The confirm box is used in JavaScript to take user's consent or accept something. User need to click “OK” to return true, else click “Cancel” to return false.</p>"
            },
            {
                "name": "Role of JSON.stringify() in JavaScript",
                "description": "<p>When data is sent to a web server, it has to be in the form of string. The <code>JSON.stringify()</code> method is used in JavaScript to convert an object to string.</p>"
            },
            {
                "name": "Anonymous functions vs JavaScript closures",
                "description": "<p><strong>JavaScript Closures</strong> - Closures are basically, the inner function having access to the variables in the outer function scope, even after the outer function has returned. To use a closure, simply define a function inside another function and expose it, I mean return it.<br><br><strong>Anonymous functions</strong> - An anonymous function is a function without a name! Anonymous functions are commonly assigned to a variable name or used as a callback function.</p>"
            },
            {
                "name": "What does “javascript:void(0)” mean?",
                "description": "<p>The javascript:void(0) evaluates an expression even if its addition to a web page brings unwanted output.<br><br>Use the void(0) to get the undefined primitive value. Here, we are preventing the page from loading on clicking the hyperlink:</p>"
            },
            {
                "name": "How to unset a JavaScript variable?",
                "description": "<p>The “undefined” is used to unset a variable in JavaScript.<br><br>Declare and initialize a variable:</p><strong>var a = 50;</strong><p>Now reassign the variable with undefined since we wish to unset it:</p><strong>a = undefined; </strong><p>The output displays undefined:</p>"
            },
            {
                "name": "Is JavaScript synchronous or asynchronous and what is event loop?",
                "description": "<p>JavaScript is a synchronous, blocking, single-threaded language. That just means that only one operation can be in progress at a time.<br><br>Many people think JavaScript is asynchronous because we can do async tasks like setTimeout, callbacks, promises in it. But the asynchronous behaviour of JavaScript(setTimeout, callbacks, promises) is not a part of JavaScript itself and built on top of JavaScript language in browser and accessed through browser APIs.<br><br>The browser have a Call Stack, Browser API and Message Queue and the order of their processing is called <strong>event loop</strong>.<br><br><img src='./assets/js/eventloop.png'><br><br>The output will be A C B , even after the setTimeout() was set to display “b” after 0 ms. This happens because of the internal working of the browser.<br><br>The main() is pushed into Call Stack, which then console logs A. Then it is popped out and the setTimeout is pushed into Call Stack. Now the setTimeout() uses Browser API, so it is pushed there and the console log C is pushed into Call Stack.</p><ul><li>Even with the delay of 0ms the exec() for setTimeout have to go to the Message Queue.</li><li>After all the statements of main() is run and the Call Stack is empty, then only the exec() from Message Queue can be pushed to the Call Stack.</li></ul><p>This is how event loop works and the asynchronous, non-blocking part of JavaScript comes from.</p>"
            },
            {
                "name": "Format numbers as currency string in JavaScript",
                "description": "<p>The number formatter would allow you to format numbers as the currency you want it to work.</p><ul> <li>USD - <br><img src='./assets/js/formatus.png'></li><li>EUR - <br><img src='./assets/js/formateur.png'></li></ul>"
            },
            {
                "name": "Difference between parseInt(string) and Number(string) in JavaScript?",
                "description": "<p>The <strong>parseInt()</strong> method parses up to the first non-digit and returns the parsed value, whereas <strong>Number()</strong> converts the string into a number, which can also be a float.<br><br><pre>console.log(parseInt(\"20demo\"));<br>//Output: 20 </pre><br><br>Using the <strong>Number(string)</strong> method, the expression returns NaN:<br><pre>console.log(Number(\"20demo\"));<br>//Output: NaN</pre><br><br>Let us now workaround for a float value with both Number(string) and parseInt(string)<br><pre>console.log(Number(\"12.99demo\"));<br>console.log(\"parseInt(\"12.99demo\"));<br>//Output: NaN / 12</pre></p>"
            },
            {
                "name": "How to detect a mobile device with JavaScript?",
                "description": "<p>To detect a mobile device, let's say Android device, use the navigator.userAgent.match. Here, we have set it in a function:<br><br><pre><strong> Android: function() {<br>&nbsp; &nbsp; &nbsp; return navigator.userAgent.match(/Android/i);<br> },<br><br>iOS: function() {<br>&nbsp; &nbsp; &nbsp; return navigator.userAgent.match(/iPhone|iPad/i);<br> },</strong></pre></p>"
            },
            {
                "name": "What is the value of typeof undefined == typeof NULL?",
                "description": "<p>The expression will be evaluated to true, since NULL will be treated as any other undefined variable.<br>Note: JavaScript is case-sensitive and here we are using NULL instead of null.</p>"
            },
            {
                "name": "How do you make synchronous / asynchronous XML HTTP request?",
                "description": "<p>Browsers provide an XMLHttpRequest object which can be used to make asynchronous HTTP requests from JavaScript by passing 3rd parameter as true for asynchronous and false for synchronous.<br><br><img src='./assets/js/xmlhttprequest.png'><br><br><img src='./assets/js/xmlhttprequest1.png'></p>"
            },
            {
                "name": "How would you create a private variable in JavaScript?",
                "description": "<p>To create a private variable in JavaScript that cannot be changed you need to create it as a local variable within a function. Even if the function is executed the variable cannot be accessed outside of the function. For example:<br><img src='./assets/js/private-variable.png'><br><br>To access the variable, a helper function would need to be created that returns the private variable.<br><img src='./assets/js/private-variable1.png'></p>"
            },
            {
                "name": "Difference between: `function Person(){}`, `var person = Person()`, and `var person = new Person()`?",
                "description": "<p><code>function Person(){}</code> is just a normal function declaration.<br><br><code>var person = Person()</code> invokes the <code>Person</code> as a function, and not as a constructor. Invoking as such is a common mistake if it the function is intended to be used as a constructor. Typically, the constructor does not return anything, hence invoking the constructor like a normal function will return <code>undefined</code> and that gets assigned to the variable intended as the instance.<br><br><code>var person = new Person()</code> creates an instance of the Person object using the <code>new</code> operator, which inherits from <code>Person.prototype</code><br><br><img src='./assets/js/share.png'><br><br><strong>What will happen if I write <code>Person.name = “John”;</code></strong><br>Answer : It will throw error Cannot assign to read-only property ‘name’.</p><br><p><strong>What will happen if I write </strong><br><pre>var p1 = new Person(“YYY”,21); <br>p1.name =”ZZZ”; <br>console.log(p1.name);<br>Answer: ZZZ</pre></p>"
            },
            {
                "name": "Difference between a `.forEach` vs `.map()` loop",
                "description": "<p>The main difference between <code>.forEach</code> and <code>.map()</code>, is that <code>.map()</code> utilizes <code>return statement</code> and actually returns a new Array of the same size.<br><br><strong><code>forEach</code></strong></p><ul><li>Iterates through the elements in an array.</li><li>Executes a callback for each element.</li><li>Does not return a value.</li></ul><p><img src='./assets/js/foreach.png'><br><br><strong><code>map</code></strong></p><ul><li>Iterates through the elements in an array.</li><li>'Maps' each element to a new element by calling the function on each element, creating a new array as a result.</li></ul><p><img src='./assets/js/map.png'></p>"
            },
            {
                "name": "Boolean Reference",
                "description": "<p><table class='table table-striped'><tbody><tr><th style='width:20%'>Method</th><th>Description</th></tr><tr><td>toString()</td><td>Converts a boolean value to a string, and returns the result</td></tr><tr><td>valueOf()</td><td>Returns the primitive value of a boolean</td></tr></tbody></table></p>"
            },
            {
                "name": "Class Reference",
                "description": "<p>A class is a type of function, but instead of using the keyword function to initiate it, we use the keyword class, and the properties are assigned inside a constructor() method:<br><br>Class Methods<br><table class='table table-striped'><tbody><tr><th style='width:20%'>Method</th><th>Description</th></tr><tr><td>constructor()</td><td>A special method for creating and initializing objects created within a class</td></tr></tbody></table><br><br>Class Keywords<br><table class='table table-striped'><tbody><tr><th style='width:20%'>Keyword</th><th>Description</th></tr><tr><td>extends</td><td>It is used to create a child class of another class (parent)</td></tr><tr><td>static</td><td>The <code>static</code> keyword defines static methods for classes. Static methods are called directly on the class - without creating an instance/object of the class</td></tr><tr><td>super</td><td>The <code>super</code> keyword refers to the parent class. It is used to call the constructor of the parent class and to access the parent's properties and methods.</td></tr></tbody></table><br><br>Example of extends and Super keyword<br><img src='./assets/js/super-class.png'></p>"
            },
            {
                "name": "JSON Reference",
                "description": "<p><table class='table table-striped'><tbody><tr><th style='width:30%'>Method</th><th>Description</th></tr><tr><td>parse()</td><td>When receiving the data from a web server, the data is always in a string format. But you can convert this string value to javascript object using parse() method. <code>var userString = '{'name':'John','age':31}';<br> var userJSON = JSON.parse(userString);<br> console.log(userJSON);<br>// {name: 'John', age: 31}</code></td></tr><tr><td>stringify()</td><td>When sending data to a web server, the data has to be in a string format. You can achieve this by converting JSON object into a string using stringify() method.<code>var userJSON = {'name': 'John', age: 31}<br> var userString = JSON.stringify(user);<br> console.log(userString); <br>// '{'name':'John','age':31}'</code></td></tr></tbody></table></p>"
            },
            {
                "name": "Difference between splice() and slice()",
                "description": "<p>The <strong>slice()</strong> method returns a new array with a copy of sliced item from the original array. Here, the first optional argument marks the beginning index and the second optional argument marks the ending index. Where as index marked with negative number starts from the end of the array. <br>###Slice method won't mutate the original array but it returns the subset as new array.<br><br>The <strong>splice()</strong> method changes the content of the array in place and can be used to add or remove items from the array. It returns the removed items in the array. The first argument marks the array position for insertion or deletion, whereas the second optional argument marks the number of elements to be deleted. <br>###Splice method modifies the original array and returns the deleted array.</p>"
            },
            {
                "name": "Difference between filter() and map()",
                "description": "<p><strong>filter()</strong>: creates a new array with elements that fall under a given condition from an existing array.<br><br><strong>map()</strong>: 'Maps' each element to a new element by calling the function on each element, creating a new array as a result.</p>"
            },
            {
                "name": "Difference between findIndex() and indexof()",
                "description": "<p><strong>findIndex()</strong>: This function returns index of the first element of the given array which satisfies the testing function.<br><br><strong>indexof()</strong>: This function is used to find the index of the first occurrence of the element provided for search as the argument to the function. If the item is present more than once, the indexOf method returns the position of the first occurence.</p>"
            },
            {
                "name": "Difference between find() and filter()",
                "description": "<p><strong>find()</strong>: The find() method returns the first value that matches from the collection. Once it matches the value in findings, it will not check the remaining values in the array collection.<br><br><strong>filter()</strong>: creates a new array with elements that fall under a given condition from an existing array.</p>"
            },
            {
                "name": "Difference between console.dir and console.log?",
                "description": "<ul><li><code>console.log(input)</code>: The browser logs in a nicely formatted manner</li><li><code>console.dir(input)</code>:  The browser logs just the object with all its properties</li></ul>"
            },
            {
                "name": "Difference between window and document?",
                "description": "<table><thead><tr><th>Window</th><th>Document</th></tr></thead><tbody><tr><td>It is the root level element in any web page</td><td>It is the direct child of the window object. This is also known as Document Object Model(DOM)</td></tr><tr><td>By default window object is available implicitly in the page</td><td>You can access it via window.document or document.</td></tr><tr><td>It has methods like alert(), confirm() and properties like document, location</td><td>It provides methods like getElementById, getElementByTagName, createElement etc</td></tr></tbody></table>"
            },
            {
                "name": "What is a Regular Expression or RegExp?",
                "description": "<p>A regular expression is a sequence of characters that forms a search pattern. You can use this search pattern for searching data in a text. These can be used to perform all types of text search and text replace operations.</p><img src='./assets/js/searchStringPattern.png'>"
            },
            {
                "name": "What are modifiers in RegExp?",
                "description": "<p>Modifiers can be used to perform case-insensitive and global searches. Let's list down some of the modifiers,</p><table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody><tr><td>i</td><td>Perform case-insensitive matching</td></tr><tr><td>g</td><td>Perform a global match rather than stops at first match</td></tr><tr><td>m</td><td>Perform multiline matching</td></tr></tbody></table><br><img src='./assets/js/globalmodifier.png'>"
            },
            {
                "name": "What are RegExp patterns?",
                "description": "<p>Regular Expressions provided group of patterns in order to match characters. Basically they are categorized into 3 types,</p><ul><li><strong>Brackets:</strong> These are used to find a range of characters. For example, below are some use cases,<ul><li>[abc]: Used to find any of the characters between the brackets(a,b,c)</li><li>[0-9]: Used to find any of the digits between the brackets</li><li>(a|b): Used to find any of the alternatives separated with |</li></ul></li><li><strong>Metacharacters:</strong> These are characters with a special meaning For example, below are some use cases,<ul><li>d: Used to find a digit</li><li>s: Used to find a whitespace character</li><li>b: Used to find a match at the beginning or ending of a word</li></ul></li><li><strong>Quantifiers:</strong> These are useful to define quantities For example, below are some use cases,<ul><li>n+: Used to find matches for any string that contains at least one n</li><li>n*: Used to find matches for any string that contains zero or more occurrences of n</li><li>n?: Used to find matches for any string that contains zero or one occurrences of n</li></ul></li></ul>"
            },
            {
                "name": "Object Equality - How would you compare two objects in JavaScript?",
                "description": "<p>To check that, you can get the keys for both the objects. If the number of properties doesn't match, these two objects are not equal. Secondly, you will check each property whether they have the same value. If all the properties have same value, they are equal.<br><br><img src='./assets/js/objectcompare.png'></p>"
            },
            {
                "name": "What Is Garbage Collection in JavaScript?",
                "description": "<p>This type of <em>automatic memory management</em> monitors memory allocation to reclaim and free up allocated memory blocks that are no longer needed by the JavaScript program.</p>"
            },
            {
                "name": "List the 7 Error Types in JavaScript.",
                "description": "<ul><li><strong>EvalError:</strong> Error regarding the global function <em>eval()</em></li><li><strong>InternalError:</strong> Internal error in the JS engine (stack overflow, etc)</li><li><strong>RangeError: </strong>Numeric variable or parameter is outside of valid range</li><li><strong>ReferenceError:</strong> Invalid variable reference</li><li><strong>SyntaxError:</strong> Syntax error while parsing code in <em>eval()</em></li><li><strong>TypeError:</strong> Parameter or variable not of a valid type</li><li><strong>URIError:</strong> Invalid parameters passed to <em>decodeURI()</em> or <em>encodeURI()</em></li></ul>"
            },
            {
                "name": "What’s the Difference Between the Javascript Engine & Javascript Runtime?",
                "description": "<p>The JavaScript engine converts JavaScript code into machine code that can be executed by the computer, while the JavaScript runtime is the environment in which the code is executed, such as a web browser or <strong>Node.js</strong></p>"
            },
            {
                "name": "How Can You Optimize the Performance of a Javascript Application?",
                "description": "<ul><li>Minimize use of global variables</li><li>Prioritize access to local variables</li><li>Use caching &amp; memoization</li><li>Compressing code and further uglification of code</li><li>Use object &amp; array literals instead of constructors</li><li>Avoid unnecessary function calls</li><li>Defer the load of JavaScript that is not necessary</li><li>Use web workers when you need to execute code that needs a lot of execution time</li><li>Remove unused JavaScript such as unused library which is not in use</li></ul>"
            },
            {
                "name": "How Can You Measure the Performance of a JavaScript Function?",
                "description": "<p>You can use <em>performance.now()</em> to return high-resolution timestamps in milliseconds and thus calculate the time it takes for a function to execute, as shown below.<br><img src='./assets/js/performance.png'></p>"
            },
            {
                "name": "How does a javascript engine work behind the scenes ?",
                "description": "<p>Every browser provides a JavaScript engine that runs the JavaScript code.<br><br><strong>Execution Context</strong> - When the JavaScript engine scans a script file, it makes an environment called the Execution Context that handles the entire transformation and execution of the code. <br>During the context runtime, the parser parses the source code and allocates memory for the variables and functions. The source code is generated and gets executed. <br>There are two types of execution contexts: global and function. The global execution context is created when a JavaScript script first starts to run, and it represents the global scope in JavaScript. A function execution context is created whenever a function is called, representing the function's local scope.<br><br><strong>Phases of the JavaScript Execution Context</strong> -<br>#1. In <strong>Creation Phase</strong>, the JavaScript engine creates the execution context and sets up the script's environment. The <strong>Creation Phase</strong> includes creating the global and function execution contexts, creating the scope chain, and allocating memories for the variables and functions.<br>#2. During the <strong>Execution Phase</strong>, the JavaScript engine executes the code line by line. This includes evaluating and executing statements.</p><br><br><p><strong>Call Stack</strong> - To keep the track of all the contexts, including global and functional, the JavaScript engine uses a <strong>call stack</strong>. A call stack is also known as an 'Execution Context Stack', 'Runtime Stack', or 'Machine Stack'. <br>When the engine first starts executing the script, it creates a global context and pushes it on the stack. Whenever a function is invoked, similarly, the JS engine creates a function stack context for the function and pushes it to the top of the call stack and starts executing it. <br>When execution of the current function is complete, then the JavaScript engine will automatically remove the context from the call stack and it goes back to its parent.<br><br><img src='./assets/js/callstack.png'><br><br>In this example, the JS engine creates a global execution context that enters the creation phase.<br><br>First it allocates memory for <code>funcA</code>, <code>funcB</code>, the <code>getResult</code> function, and the <code>res</code> variable. Then it invokes <code>getResult()</code>, which will be pushed on the call stack.<br><br>Then <code>getResult()</code> will call <code>funcB()</code>. At this point, <code>funcB</code>'s context will be stored on the top of the stack. Then it will start executing and call another function <code>funcA()</code>. Similarly, <code>funcA</code>'s context will be pushed. <br><br>Once execution of each function is done, it will be removed from the call stack.</p>"
            },
            {
                "name": "Difference between TypeScript and JavaScript",
                "description": "<table><tbody><tr><td><strong>TypeScript</strong></td><td><strong>JavaScript</strong></td></tr><tr><td>Superset of JavaScript developed to overcome code complexity for large projects.</td><td>A scripting language that helps create dynamic web page content.</td></tr><tr><td>Errors can be found and corrected during compile time.</td><td>Errors can be found only during run-time as it is an interpreted language.</td></tr><tr><td>Strongly typed, supports both static and dynamic typing.</td><td>Weakly typed, no option for static typing.</td></tr><tr><td>Converted into JavaScript code to be understandable for browsers.</td><td>Can be directly used in browsers.</td></tr><tr><td>Since it is a superset, all the JavaScript libraries, and other JavaScript code works without any changes.</td><td>JS libraries work by default.</td></tr><tr><td>There is support for ES3, ES4, ES5 and ES6.</td><td>No support for compiling additional ES3, ES4, ES5 or ES6 features.</td></tr><tr><td>Supports modules, generics and interfaces to define data.</td><td>No support for modules, generics or interface.</td></tr><tr><td>Functions can have optional parameters.</td><td>Functions cannot have optional parameters.</td></tr><tr><td>Numbers and strings are considered as interfaces.</td><td>Number and string are objects.</td></tr><tr><td>Powerful and intuitive language for large projects.</td><td>Neat and clean, most suitable for simple web applications.</td></tr><tr><td>Community support is still growing.</td><td>Huge community support with lots of documentation and support for solving issues.</td></tr><tr><td>Prototyping is possible</td><td>No support for prototyping.</td></tr><tr><td>Takes time to learn and code, scripting knowledge is a must.</td><td>Can be learned on the go, no prior scripting experience is needed.</td></tr><tr><td>Proper build setup (npm package) is required for static type definitions</td><td>No build setup is required.</td></tr></tbody></table>"
            },
            {
                "name": "What are the differences between ES6 class and ES5 function constructors?",
                "description": "<p>ES6 class constructors work quite the same as class constructors in other object-oriented languages. They are used to create new objects.<br><br>ES5 function constructors are also used to create objects. The above example can be modified as following through the use of function constructors.</p><table><thead><tr><th><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ES6 class constructors</strong></th><th><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ES5 function constructors</strong></th></tr></thead><tbody><tr><td>As discussed above ES6 class constructors creates objects by adding function to their prototypes (Blueprint).</td><td>ES5 function constructors also create objects along with inheritance property.&nbsp;</td></tr><tr><td>It ensures that<i> this</i> keyword used by the developer is referring to the object being created by the developer.&nbsp;</td><td>Any function can be used as a function constructor and it primarily focuses on the creation of reusable object creation code.</td></tr><tr><td>Its syntax is similar to object creation in other object-oriented programming languages.</td><td>Its syntax is unique and is not generally found in other object-oriented programming languages.</td></tr><tr><td>This can be said to be a syntax base for constructor functions and instantiate objects using a new operator.</td><td>This also uses a new operator for object creation but focuses on how the objects are being instantiated.</td></tr></tbody></table>"
            },
            {
                "name": "enums in JavaScript and typescript",
                "description": "<p>Enums in Javascript - <br><img src='./assets/js/enumjs.png'><br><br>Enums in Typescript - <br><img src='./assets/js/enumts.png'></p>"
            },
            
            
            {
                "name": "How do you clone an object?",
                "description": "<p><strong><code>var obj = {a: 1 ,b: 2}<br>var objclone = Object.assign({},obj);</code></strong><br><br>Now the value of <code>objclone</code> is <code>{a: 1 ,b: 2}</code> but points to a different object than <code>obj</code>.<br><br>Note the potential pitfall, though: <code>Object.assign()</code> will just do a shallow copy, <em>not</em> a deep copy.  This means that nested objects aren’t copied.  They still refer to the same nested objects as the original:<br><br><img src='./assets/js/objclone.png'></p>"
            },
            
            {
                "name": "What does the term Transpiling stand for?",
                "description": "<p>There's no way to polyfill new syntax that has been added to the language. So the better option is to use a tool that converts your newer code into older code equivalents. This process is commonly called&nbsp;<strong>transpiling</strong>, a term for&nbsp;<em>transforming + compiling</em>.<br><br>Typically you insert the&nbsp;<em>transpiler</em>&nbsp;into your build process, similar to your code linter or your minifier. There are quite a few great transpilers for you to choose from:</p><ul><li><p><strong>Babel</strong>: Transpiles ES6+ into ES5</p></li><li><p><strong>Traceur</strong>: Transpiles ES6, ES7, and beyond into ES5</p></li></ul>"
            },
            {
                "name": "Difference between Relative path and absolute path",
                "description": "<p>A relative path describes the location of a file relative to the current (working) directory*.</p>"
            },
            {
                "name": "Difference between Function, Method and Constructor calls in JavaScript",
                "description": "<p>In JavaScript, a <strong>function</strong> is a piece of reusable code that has the potential to take input values, perhaps do something with them, and potentially return a value.<br><br>Now, if the same function is called with the new keyword preceding it, it is known as <strong>constructor</strong> since it creates and returns a new object. (The collection of all objects that were generated using the same function constructor is then known as a class)<br><br>Likewise suppose a JavaScript Object contains as property in the form of function definition then it becomes a <strong>method</strong></p>"
            },
            {
                "name": "What are Service Workers and when can you use them?",
                "description": "<p>It’s a technology that allows your web application to use cached resources first, and provide default experience offline, before getting more data from the network later. This principle is commonly known as Offline First.<br><br>Service Workers actively use promises. A Service Worker has to be installed,activated and then it can react on fetch, push and sync events.<br><br>As of 2017, Service Workers are not supported in IE and Safari.</p>"
            }
        ]
    },
    {
        "folder": "JavaScript Coding",
        "title": "JavaScript Coding",
        "url": "/folder/JavaScript Coding",
        "icon": "logo-javascript",
        "question": [
            {
                "name": "Output - every() true/false?",
                "description": "<br><img src='./assets/jsCode/every.png'>"
            },
            {
                "name": "Output - undefined var inside for loop result - NaN",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/resultnan.png'><br><br><strong>Answer: </strong> The result is <strong>NaN</strong> because the var result  variable is immediately initialized, by setting it to undefined, Inside the loop since the result in uninitialized so the value of the variable result remains undefined. as we know, undefined isn’t converted into any number, so using it in maths calculations returns NaN. i.e., <strong>undefined + 5 = NaN</strong></p>"
            },
            {
                "name": "Output - eval method",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/eval.png'><br><br><strong>Answer: </strong> The result is <strong>B) 105</strong> because The eval function we see here can be used to calculate the Javascript in the form of string also as the as multiplication operator has greater priority than addition operator so it will first execute 10 x 10 is equal to 100 and then it at 5 to it so it becomes <strong>Number 105</strong></p>"
            },
            {
                "name": "Output - string and array when updated",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/printstringhello.png'><br><br><strong>Answer: </strong> The result is <strong>\"𝗛𝗲𝗹𝗹𝗼\" ['𝗛', '𝗮', '𝗹', '𝗹', '𝗼']</strong> because string is immutable. so this will log original str i.e., \"𝗛𝗲𝗹𝗹𝗼\", and array is mutable so this will log updated value ['𝗛', '𝗮', '𝗹', '𝗹', '𝗼']</p>"
            },
            {
                "name": "Output -  union of arrays / merge with unique value / intersection of array using prototype",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/arrayconcat.png'><br><br><strong>Answer: </strong> The result is <strong>[1, 2, 3, 4]</strong> because here the logic is in this way <br><strong>#1.</strong> First get the elements that are contained in first array using <strong>filter method</strong> and not contained in the second array using <strong>includes method</strong>, <br><strong>#2.</strong> concat the result with the element of the second array using <strong>concat method</strong></p>"
            },
            {
                "name": "Find the intersection of two arrays programatically",
                "description": "<p> The logic here is to create a hashmap with the elements of the firstArray as the keys. <br>After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash <br>If it does exist, add that element to the new array.<br><br>Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added<br><br><img src='./assets/js/intersection.png'></p>"
            },
            {
                "name": "Output - remove duplicate values from an object using Map",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/arraymap.png'><br><br><strong>Answer: </strong> The result is <strong>[{ 𝗸𝗲𝘆: 𝟭 }, { 𝗸𝗲𝘆: 𝟮 }]</strong> because the element exists in map object then skip to the next element, if not, add it to the result array.</p>"
            },
            {
                "name": "Output - Sum using Currying",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/currying.png'><br><br><strong>Answer:</strong> The result is <strong>5 5</strong> because Currying is a function that takes one argument at a time and returns a new function expecting the next argument</p>"
            },
            {
                "name": "Output - Closures, Currying, and Higher-Order Functions with returning multiple values from the function",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/problem7.png'><br><br><strong>Answer: </strong> The result is <strong>6 10</strong> because <br><strong>#1.</strong> In the first statement  we get back the array [𝟲, function(z) { return 2 * 3 + z; }]. so calling mul(2)(3)[0] evaluates to the first element of the array returned by the inner function, which is the product of 2 and 3, i.e., <strong>6</strong>. <br><strong>#2.</strong> //returning index 1, which returns the function that takes z as a parameter. i.e., calls the second closure in the array with an argument of 4, and once z is passed to the function it returns 2*3 + 4 = <strong>10</strong>.</p>"
            },
            {
                "name": "Output - Object Key using square bracket operator",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/objectkey.png'><br><br><strong>Answer:</strong> The result is <strong>Jayesh 24</strong> because value of the key can be any expression as long as it is wrapped in brackets []. The result of an expression enclosed in brackets becomes the property name. i.e., age</p>"
            },
            {
                "name": "Ouput - replace string expression",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/replace.png'><br><br><strong>Answer:</strong> The result is <strong>jx@gmail.com logged-in</strong> replace() method is used to replace a part of a given string with a new substring</p>"
            },
            {
                "name": "output - using default value and function expression for addition",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/defaultpara.png'><br><br><strong>Answer:</strong> The result is <strong>3 6</strong> Default values allow the named parameters to get initialized with a default value or when no value is passed. Now using a value in first parameter will overwrite it and while using function add as default value expression the value becomes 3+3 = 6</p>"
            },
            {
                "name": "Output - array using reverse and then push new item",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/arrayrev.png'><br><br><strong>Answer:</strong> The result is <strong>[3,2,1,4] [3,2,1,4]</strong> <br> <strong>#1.</strong> The reverse() method reverses the array immediately; this means that the original elements of the array are swapped, and the original sequence is lost. <br><strong> #2.</strong> since reverse and push both method mutates the original array.so arr2.push will also modify the arr1. <br><strong>#3.</strong> after push operation this will log [3,2,1,4] because they’re both referencing the same array</p>"
            },
            {
                "name": "Output - using Object.is check for number, string and objects.",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/objectis.png'><br><br><strong>Answer:</strong> The result is <strong>false false</strong> <br> <strong>#1.</strong> TheObject.is() workons on strict comparison operator .i.e - === <br><strong> #2.</strong> return false since for strict equality number and string comparison will return false. <br><strong>#3.</strong> The specified objects look the same; however, they are two different objects as they refer to different memory addresses. This is why the Object.is() method marked these objects as unequal after comparing their references and return false.</p>"
            },
            {
                "name": "Output - compare string using sort method",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/stringsort.png'><br><br><strong>Answer:</strong> The result is <strong>true</strong> <br> since both str1 and str2 will be 'ehllo' after sorting and join. so this will return true</p>"
            },
            {
                "name": "Output - trim",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/trim.png'><br><br><strong>Answer:</strong> The result is <strong>\"&nbsp;&nbsp;Jayesh&nbsp;&nbsp;\" \"Jayesh\"</strong> <br> string.trim() removes sequences of whitespaces and line terminators from both the start and the end of the string. It doesn't change the original string but returns a new string without leading and trailing white spaces.</p>"
            },
            {
                "name": "Output  - Array with single and multiple arguments",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/emptyarray.png'><br><br><strong>Answer:</strong> The result is <strong>[empty x 3][1,2,3]</strong> <br> <strong>#1.</strong>  arr1 = new Array(3); will create array arr1 with a specified number of empty slots (e.g. Array(3) creates the array [empty x 3]). so this will log [𝗲𝗺𝗽𝘁𝘆 × 𝟯] <br><strong>#2.</strong>new Array(1, 2, 3); //an array with three elements</p>"
            },
            {
                "name": "Output - console.log(foo(), typeof x, typeof y);",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/scopelocalglobal.png'><br><br><strong>Answer: </strong> The result is <strong>1, undefined and number</strong> because <br><strong>#1.</strong> Of course the return value of <code>foo()</code> is 1 due to the increment operator. But the statement <code>let x = y = 0</code> declares a local variable x. Whereas y declared as a global variable accidentally. <br><strong>#2.</strong> Since the block scoped variable x is undefined outside of the function, the type will be undefined too. Whereas the global variable <code>y</code> is available outside the function, the value is 0 and type is number.</p>"
            },
            {
                "name": "Output - Equality Coercion",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/equalityProblem.png'><br><br><strong>Solution - </strong>Output in the following order due to equality coercion:<br><img src='./assets/jsCode/equalitySolution.png'></p>"
            },
            {
                "name": "Output - null and undefined",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/equalityProblem2.png'><br><br><strong>Answer: </strong> The result is <strong>true false</strong> because here the logic is in this way <br><strong>#1.</strong> both undefined and null will return false. i.e., Boolean(null) and Boolean(undefined) both return false and the equality operator is used it compares only the values. So, == returns <strong>true</strong> <br><strong>#2.</strong> when we use the strict equality operator (===) which checks both type and value, since undefined and null are of different types (object is not equal to undefined), the strict equality operator returns <strong>false</strong>.</p>"
            },
            {
                "name": "Output - using spread operator",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/spread.png'><br><br><strong>Answer: </strong> The result is <strong>{name: 'Jayesh', admin: true}</strong> because here the logic is in this way <br>Using the && operator to return the object only when condition is true. If the object is returned then it’ll be spread into person object. And if the expression returns false then nothing gets spread, and no new keys are added to the object.<br><br><br><strong>Problem</strong><br><img src='./assets/jsCode/spread1.png'><br><br><strong>Answer: </strong> The result is <strong>{0: 'Jayesh', 1: 'Virat'}</strong> becaue her the spread syntax will unpack the values of an array into a new Object where the indexes of the array becomes the object's key and the elements in the array become object's values</p>"
            },
            {
                "name": "Output of Boolean values using OR operator",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/console.png'><br><br><strong>Answer: </strong> The result is <strong>{} \"\" []</strong> because here the logic is in this way <br><strong>#1.</strong>const one = false || { } || null; // <strong>Boolean(false) || Boolean({}) || Boolean(null) = false || true || false = true;</strong> since one of them is true so this will returns the first true operand value <strong>i.e., {}</strong> <br><strong>#2.</strong>const two = null || false || \"\"; // <strong>Boolean(null) || Boolean(false) || Boolean(\"\") = false || false || false = false;</strong> since all falsy so this will returns the last operand value <strong>i.e., \"\"</strong><br><strong>#3.</strong> const three = [ ] || 0 || true; // <strong>Boolean([]) || Boolean(0) || Boolean(true) = true || false || true = true;</strong> since one of them is true so this will returns the first true operand value <strong>i.e., []</strong></p>"
            },
            {
                "name": "Output - Union of duplicate values in two Array ",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/arrayfilter.png'><br><br><strong>Answer: </strong> The result is <strong>[1,2,3]</strong> because here the logic is in this way <br><strong>#1.</strong> using filter we are checking array 1 which includes values in array 2 and only returning that matched value</p>"
            },
            {
                "name": "Output - display value using ?? / nullish operator ",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/displayamount.png'><br><br><strong>Answer: </strong> The result is <strong>0</strong> because here due to hoisting - amount is <strong>undefined</strong> inside arrow function so this will evaluate <strong>0</strong></p>"
            },
            {
                "name": "Output - Baba / NaN / banana",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/baba.png'><br><br><strong>Answer: </strong> The result is <strong>banana BANANA</strong> here the logic is in this way <br><strong>#1.</strong> 'b' + 'a' +( + 'b') + 'a' // here due to <strong>unary plus (+) operator precedence</strong>, <strong>(+'b')</strong> will try to convert 'b' to a number. Since 'b' is not a number, the result is NaN (\"Not a Number\") <br><strong>#2.</strong> 'b' + 'a' + NaN + 'a' // here, adding NaN to \"ba\" turns NaN into the string \"NaN\" due to type conversion, this gives 'baNaN'. <br><strong>#3.</strong> the result 'ba'+'NaN'+'a' will become 'baNaNa'.</p>"
            },
            {
                "name": "Output - concat",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/merge.png'><br><br><strong>Answer: </strong> The result is <strong>[1,2] [1,2,3,4]</strong> here the logic is in this way <br><strong>#1.</strong> Array.concat() returns a new array and does not modify the existing arrays. <br><strong>#2.</strong> returns a new array res having the merge result</p>"
            },
            
            {
                "name": "Output - global variable value in inner and outer function",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/problem8.png'><br><br><strong>Answer: </strong> The result is <strong>JC JC</strong> because here the variable name is declared outside of the function getName and is a global variable. It means the variable name can be used anywhere in the program. Now the value of a global variable name can be changed inside a function.</p>"
            },
            {
                "name": "Output - prototype in function declaration and expression",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/proto3.png'><br><br><strong>Answer: </strong> The result is <strong>{constructor: f} undefined</strong> because <strong>Regular functions</strong> are working well with objects using the <strong>new keyword</strong>. They have the constructor function by which values can be initialized during object creation. It can be managed using the prototype chaining. However, arrow function does not have constructor function, prototype chaining. That means, unlike <strong>regular functions</strong>, arrow functions can never be called with the new keyword because they do not have the [[Construct]] method. As such, the prototype property also does not exist for arrow functions.</p>"
            },
            {
                "name": "Output - What is the result of X, Y, Z / A, B C object?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/xyzObjectProblem.png'><br><br><strong>Solution - </strong><br><img src='./assets/jsCode/xyzObject.png'><br><br>Adding objects as properties of another object should be done carefully.<br><br>Writing x[y]={name:”Vivek”}, is same as writing x[‘object Object’]={name:”Vivek”},<br><br>While setting a property of an object, javascript coerces the parameter into a string.<br><br>Therefore, since y is an object, it will be converted to ‘object Object’.<br><br>Both x[y] and x[z] are referencing the same property.</p>"
            },
            {
                "name": "Output - Console results of string and numbers?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/stringNumberConsole.png'><br><br><strong>Solution - </strong><br><img src='./assets/jsCode/stringNumberConsoleResult.png'></p><br><br><p><strong>Problem</strong><br><img src='./assets/jsCode/stringNumberConsole1.png'><br><br><strong>Solution - </strong><br><img src='./assets/jsCode/stringNumberConsoleResult1.png'></p><p><strong>Problem</strong><br><img src='./assets/jsCode/stringNumberConsole2.png'><br><br><strong>Solution - </strong><br><img src='./assets/jsCode/stringNumberConsoleResult2.png'></p>"
            },
            {
                "name": "Output - Hoisting a variable and random function",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/hoistingProblem.png'><br><br><strong>Solution - </strong>Output is <strong>NaN</strong><p>random() function has functional scope, since x is declared and hoisted in the functional scope.<br><br>Rewriting the random function will give a better idea about the output:<br><img src='./assets/jsCode/hoistingSolution.png'></p>"
            },
            {
                "name": "Output - What is the issue with the below code and how it can be fixed? (console sort)",
                "description": "<p><strong>Problem</strong><br><strong>const array=[1,2,15,4,30,7,45];<br>console.log(array.sort());</strong><br><br>The sort() method is used to sort the elements of an array. But the output of the above is not what expected out of sort() function.<br><br>This is because the default sort is according to tring Unicode points. The fix to it is by adding an anonymous function and tell to sort according to ascending or descending order. <br><br><img src='./assets/jsCode/sort.png'><br><br><strong>Sorting Programatically</strong><br><img src='./assets/jsCode/sortprogram.png'></p>"
            },
            {
                "name": "Output - How to shuffle an array in JavaScript?",
                "description": " <ul> <li><img src='./assets/jsCode/shuffle.png'></li><li><strong>[3,5,1,95,8,23].sort( ()=>Math.random()-0.5)</strong></li><li><img src='./assets/jsCode/shuffle1.png'></li></ul>"
            },
            {
                "name": "Output - What should be the value of “i” so that we get the mentioned result?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/printi.png'><br><br><strong>Answer</strong><br><br>Everything is ok, but the last one produce NaN(Not a Number) because “<em>0 divide by 0 will produce infinity”</em><br><br>So, we need a number which is like zero but gives 1 if we divide it by itself. Fortunately there is such a number in JavaScript. The number is the minimum value that is allowed in JavaScript and is represented by <strong>Number.MIN_VALUE</strong><br><br><img src='./assets/jsCode/printians.png'></p>"
            },
            {
                "name": "Output - What are the different way to access “this” inside an inner function for below code?",
                "description": "<p><img src='./assets/jsCode/problem1.png'><br><br><strong>Solution 1</strong> - Use call method to use the outer “this” inside the innerFunc().<br><br><img src='./assets/jsCode/solution1.png'><br><br><strong>Solution 2</strong> - Use bind method to use the outer “this” inside the innerFunc().<br><br><img src='./assets/jsCode/solution2.png'><br><br><strong>Solution 3</strong> - Use a “that” variable in&nbsp;cleanRoom() for accessing “this” inside innerFunc(). Basically “that” is nothing but the outer “this”.<br><br><img src='./assets/jsCode/solution.png'><br><br><strong>Solution 4</strong> - Use arrow function in the innerFunc(). Arrow functions have special meaning for “this” and it is that, it takes the value of “this” from the enclosing scope and is very useful in this case.<br><br><img src='./assets/jsCode/solution3.png'></p>"
            },
            {
                "name": "Output - What is the output of the below code and why?(identity)",
                "description": "<p><img src='./assets/jsCode/problem2.png'><br><br><strong>Problem</strong>What is the issue with the code and how can it be fixed?<br><br>The output logged will be:</p><strong><code>undefined<br>Johnny Deep</code></strong><p>The first console.log prints <strong>undefined</strong> because heroIdentity() is been invoked in the global context (i.e., the window object) where the <strong>_name</strong> property doesn’t exists.<br><br>The other way to fix it is by binding, it to hero object by using bind.</p><strong><code>var heroIdentity = hero.getIdentity.bind(hero);</code></strong>"
            },
            {
                "name": "Deep / Nested Compare JavaScript Objects",
                "description": "<p><strong>#1. Angular: angular.equals(obj1, obj2) : </strong>The Angular library also provides a method that helps us to determine deep equality between two objects. This method is provided under the ng module. It takes two parameters, the operands, to be compared for equality and returns a Boolean value indicating whether the operands are equal based on JavaScript strict equality (===).<br><img src='./assets/jsCode/nestedcompareobj.png'><br><br><strong>#2. JSON.stringify() method : </strong>in this method, we convert our two objects into strings using the JSON.stringify() method and compare the two values to determine whether the objects are deep equal. Even if the objects have nested properties, this method can handle those as well.<br><img src='./assets/jsCode/jsoncompareobj.png'></p>" 
            },
            {
                "name": "Output - What is the output of the below code and why? (arguments / method)",
                "description": "<p><img src='./assets/jsCode/method.png'><br><br>The output logged will be:</p><strong><code>10<br>2</code></strong><p>When inside the method, fn() is called the “this” of the function fn is at window level. So, “this.length” will produce <strong>10</strong>.<br>Now, when <code>arguments[0]()&nbsp;</code>is called, then <code>arguments[0]()&nbsp;</code> is equivalent to “fn” and function fn is called. But “this” now is the arguments array, which is of length 2 because it contains two arguments (fn, 1). So, “this.length” will produce <strong>2</strong>.</p>"
            },
            {
                "name": "Output - What is the output of the below code and why? (console proto)",
                "description": "<p><strong>Problem</strong></p><strong>console.log(('hello').__proto__.__proto__.__proto__);</strong></p><br><p><strong>Answer</strong> - The output logged will be: <code>null</code><br><br>The reason is for prototype chaining. The __proto__ of ‘hello’ is the global String.</p><strong>console.log(('hello').__proto__);</strong><p><img src='./assets/jsCode/proto1.png'><br><br>Then the __proto__ of it is the global Object.</p><strong>console.log(('hello').__proto__.__proto__);</strong><p><img src='./assets/jsCode/proto2.png'><br><br>Now, the Object is the final thing from which everything in JavaScript is created and it points to <strong>null</strong>.</p>"
            },
            {
                "name": "Output - Find the missing number in the array",
                "description": "<p><img src='./assets/jsCode/missingNumber.png'></p>"
            },
            {
                "name": "Output - Find the min and max values in the array",
                "description": "<p><img src='./assets/jsCode/minmax.png'><br><br><img src='./assets/jsCode/minmax1.png'><br><br><img src='./assets/jsCode/minmax2.png'></p>"
            },
            {
                "name": "Output - Capitalize all words in a sentence",
                "description": "<p><img src='./assets/jsCode/capitalize.png'><br><br><img src='./assets/jsCode/capitalize1.png'><br><br><img src='./assets/jsCode/capitalize2.png'><br><br><img src='./assets/jsCode/capitalize3.png'></p>"
            },
            {
                "name": "Output - Find the duplicate values in an string / find a character with maximum occurrence in a string",
                "description": "<ul><li><strong>Using filter + indexOf</strong><br><img src='./assets/jsCode/duplicateValue4.png'></li><li><strong>Using classical for loop</strong><br><img src='./assets/jsCode/duplicateValue5.png'></li></ul>"
            },
            {
                "name": "Output - Find the duplicate values in an array",
                "description": "<ul> <li><strong>By simply Traversing the Array</strong> <br><img src='./assets/jsCode/duplicateValue.png'></li><li><strong>Using filter + indexOf</strong> <br><img src='./assets/jsCode/duplicateValue1.png'></li><li><strong>Using reduce + includes</strong> <br><img src='./assets/jsCode/reduceinclude.png'></li><li><strong>Using includes</strong> <br><img src='./assets/jsCode/duplicateValue2.png'></li><li><strong>Using ES6 \"Set\"</strong> <br><img src='./assets/jsCode/duplicateValue3.png'></li></ul>"
            },
            {
                "name": "Output - Remove duplicates from an array",
                "description": "<ul><li><strong>Using empty array / helper array</strong> <br><img src='./assets/jsCode/duplicate.png'></li><li><strong>Using Object</strong> <br><img src='./assets/jsCode/duplicate1.png'></li><li><strong>Using filter + indexOf</strong> <br><img src='./assets/jsCode/duplicate2.png'></li><li><strong>Using ES6 \"Set\"</strong> <br><pre>var arr=[...new Set(arr)]</pre></li><li><strong>Using ES6 \"Set\" with from()</strong> <br><pre>var temp.from(new Set(arr))</pre><br>Here, the <strong>from()</strong> method returns an Array object from any object which has a capability of defining length property or any iterable object.</li></ul>"
            },
            {
                "name": "Output - Reverse each word in the sentence",
                "description": "<p><img src='./assets/jsCode/reverse4.png'><br><br><img src='./assets/jsCode/reverse5.png'><br><br><img src='./assets/jsCode/reverse6.png'><br><br><img src='./assets/jsCode/reverse2.png'><br><br><img src='./assets/jsCode/reverse.png'><br><br><img src='./assets/jsCode/reverse1.png'><br><br><strong>Reversing word greater than 5 letters</strong><br><img src='./assets/jsCode/reverse3.png'><br><br><img src='./assets/jsCode/reverseString.png'><br><br>Here, <strong>The <code>split()</code> method splits a string into an array of substrings, and returns the new array. If an empty string (\"\") is used as the separator, the string is split between each character, where as the <code>reverse()</code> method reverses the order of the elements in an array, and the <code>join()</code> method returns an array as a string.</strong></p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop",
                "description": "<p><code>// setTimeout inside a For loop<br><br>for(var i = 0;i &lt; 5; i++){<br>&nbsp;&nbsp;&nbsp;setTimeout(function(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('count ', i);<br>&nbsp;&nbsp;&nbsp;}, 3000);<br>}</code><br><br>//Console<br><br><code>count  5<br>count  5<br>count  5<br>count  5<br>count  5</code><br><br>The <em>setTimeout</em> function callback isn’t triggered until the for loop execution has completed. When the for loop has finished executing the value of i is 5. Now when the <em>setTimeout</em> call begins to execute it uses the last set value of i which is 5. Hence 5 is printed in all the <em>setTimeout</em> callbacks.</p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using IIFE",
                "description": "<p>You can use IIFE to create a new scope for each setTimeout callback without polluting the global scope. Simply wrap up the setTimeout code inside a IIFE.</p><br><img src='./assets/jsCode/settimeoutforloop.png'>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using let Keyword",
                "description": "<p>The let keyword creates a separate scope for each iteration making it possible to print the consecutive variable value.</p><br><img src='./assets/jsCode/settimeoutforloop1.png'>"
            },
            {
                "name": "Output - indexOf",
                "description": "<p><img src='./assets/jsCode/problem3.png'><br><br><strong>Answer</strong>: The first answer is 1 because 2 is at position 1, second and third is -1 because the index does not use for object and arrays. If you want to find and element in array use map and then check the index. The last line answer is 4 because the string is consider as an array of char in javascript.</p>"
            },
            {
                "name": "Output - filter.call()",
                "description": "<p><img src='./assets/jsCode/problem4.png'><br><br>Answer: This will start reading after 5. The beauty of this question is how it is written. Sometimes look like a puzzle. It will return set of array <strong><em>[“W”, “o”, “r”, “l”, “d”]</em></strong></p>"
            },
            {
                "name": "Output - printMessage",
                "description": "<p><img src='./assets/jsCode/problem5.png'><br><br>Answer: Here, We are creating two objects printVal1 and printVal2. printVal1.printMessage() clearly logs In printVal1 …because message is initialize as “In printVal1 …”. In the next line assigning method printMessage to printVal2 Object. In printVal2 message is initialize as “In printVal2 …”. So code block will log: <strong>In printVal1 … and In printVal2 …</strong></p>"
            },
            {
                "name": "Output - return statement",
                "description": "<p><img src='./assets/jsCode/problem6.png'><br><br>Answer - when you see this example closely there is return and rest of the code is written after that. So JavaScript just return from second line of code. Code after line 2 will not be executed.</p>"
            },
            {
                "name": "Output - ===",
                "description": "<p><strong>Problem</strong><br><strong>console.log(0.1+0.2===0.3)</strong><br><br>Answer: when adding 0.1 and 0.2 in javascript it will not be 0.3. It will be more than a fraction value of 0.3.<br> Only this will work <strong>(0.1+0.2).toFixed(1)==0.3</strong></p><br><br><p><strong>Problem</strong><br><img src='./assets/jsCode/equalityProblem1.png'><br><br><strong>Answer</strong> The triple-equal operator <code>===</code> behaves like any traditional equality operator would: evaluates to true if the two expressions on either of its sides have the same type and the same value. The double-equal operator, however, tries to coerce the values before comparing them. It is therefore generally good practice to use the <code>===</code> rather than <code>==</code>.  The same holds true for <code>!==</code> vs <code>!=</code>.</p>"
            },
            {
                "name": "Output - Fibonacci series",
                "description": "<p>Fibonacci series is a series that generates subsequent series of numbers by the addition of the two previous numbers. ... The first two terms of the Fibonacci series are zero and one, respectively. And the next terms are the addition of the two previous terms.<br><br><img src='./assets/jsCode/fibonacci.png'></p>"
            },
            {
                "name": "Output - Swap number without temp",
                "description": "<p><img src='./assets/jsCode/swaping.png'></p>"
            },
            {
                "name": "Output - Sum of two / sumFinder",
                "description": "<p><strong>Problem</strong> - From a unsorted array, check whether there are any two numbers that will sum up to a given number?<br><br><strong>Answer</strong><br><img src='./assets/jsCode/sumoftwo.png'></p>"
            },
            {
                "name": "Output - Sum of two largest numbers in the array",
                "description": "<p><img src='./assets/jsCode/sumoftwo1.png'></p>"
            },
            {
                "name": "Output - Sum of Squares of array list",
                "description": "<p><strong>Problem</strong> - Write a function that sums squares of numbers in list that may contain more lists?<br><img src='./assets/jsCode/recursionsumarray1.png'><br><br><strong>Answer</strong><br><img src='./assets/jsCode/recursionsumarray.png'></p>" 
            },
            {
                "name": "Output - Search JS object",
                "description": "<p><strong>Problem</strong> - Write a function called contains that searches for a value in a nested object. It returns true if the object contains that value.<br><img src='./assets/jsCode/searchjsobject.png'><br><br><strong>Answer</strong><br><img src='./assets/jsCode/searchjsobject1.png'></p>" 
            },
            {
                "name": "Output - Product of an array",
                "description": "<p><strong>Problem</strong> - Write a function called productOfArray which takes in an array of numbers and returns the product of them all?<br><img src='./assets/jsCode/productofarray.png'><br><br><strong>Answer</strong><br><img src='./assets/jsCode/productofarray1.png'><br><br><img src='./assets/jsCode/productofarray2.png'><br><br><img src='./assets/jsCode/productofarray3.png'></p>" 
            },
            {
                "name": "Output - check whether a number is even or not",
                "description": "<p><img src='./assets/jsCode/evenodd.png'></p>" 
            },
            {
                "name": "sum every integer element in an array",
                "description": "<p><img src='./assets/jsCode/sumofarray.png'><br><img src='./assets/jsCode/sumofarray1.png'></p>" 
            },
            {
                "name": "sum all nonnegative integers up to n",
                "description": "" 
            },
            {
                "name": "Output - delete operator with Emp Object prototype",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete1.png'><br><br><p><strong>Answer</strong> - Above code will output <strong>xyz</strong> as output. Here <strong>emp1</strong> object got company as prototype property. <strong>delete</strong> operator doesn't delete prototype property.<br><br><strong>emp1</strong> object doesn't have <strong>company</strong> as its own property. You can test it like:<br><br><img src='./assets/jsCode/delete2.png'><br><br>However, we can delete company property directly from <strong>Employee</strong> object using <strong>delete Employee.company</strong> or we can also delete from <strong>emp1</strong> object using <strong>__proto__</strong> property <strong> delete emp1.__proto__.company</strong>.</p>"
            },
            {
                "name": "How to merge two sorted Arrays into a Sorted Array?",
                "description": "<p><img src='./assets/jsCode/merge-two-sorted-array-algorithm.png'><br><br><img src='./assets/jsCode/merge-two-sorted-array-algorithm1.png'></p>"
            },
            {
                "name": "Output - let and var inside setTimeout",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/letvaroutput.png'></p><br><p><strong>Answer</strong> - Outputs 2 and 12. Since, even though let variables are not hoisted, due to the async nature of javascript, the complete function code runs before the setTimeout function. Therefore, it has access to both x and y.</p>"
            },
            {
                "name": "Output - In what order will the numbers 1-4 be logged to the console",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/order.png'></p><br><p><strong>Answer</strong> - 2<br>4<br>3<br>1 // After two seconds<br><br>Even though the second timeout function has a waiting time of zero seconds, the javascript engine always evaluates the setTimeout function using the Web API, and therefore, the complete function executes before the setTimeout function can execute.</p>"
            },
            {
                "name": "Output - hero / getPower / powerlevel",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/powerlevel.png'></p><br><p><strong>Answer</strong> - undefined<br>42<br><br>Reason - The first output is <strong>undefined </strong>since when the function is invoked, it is invoked referencing the global object:<br><br><code>window.getPower() = getPower();</code></p>"
            },
            {
                "name": "Write the code to find the vowels",
                "description": "<p><img src='./assets/jsCode/vowels.png'></p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using const variable",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/const.png'></p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/const1.png'></p>"
            },
            {
                "name": "Output - Given two strings, return true if they are anagrams of one another",
                "description": "<p><strong>Problem</strong> - For example: Mary is an anagram of Army</p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/anagram.png'></p>"
            },
            {
                "name": "Output - typeof f()",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/typeoff.png'></p><br><p><strong>Answer</strong> - You can see function expression instead function declaration inside if statement. So it always returns true. Since it is not declared(or assigned) anywhere, f is undefined and typeof f is undefined too.</p>"
            },
            {
                "name": "Output - delete operator",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete3.png'></p><br><p><strong>Answer</strong> - The output would be 0. The delete operator is used to delete properties from an object. Here x is not an object but a local variable. delete operators don’t affect local variables.</p>"
            },
            {
                "name": "Output - delete operator with x object - foo bar",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete.png'></p><br><p><strong>Answer</strong> - The output would be undefined. The delete operator is used to delete the property of an object. Here, x is an object which has the property foo, and as it is a self-invoking function, we will delete the foo property from object x. After doing so, when we try to reference a deleted property foo, the result is undefined.</p>"
            },
            {
                "name": "Output - delete operator deleting an array index",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete4.png'><br><br><strong>Answer: </strong> The result is <strong>[undefined/empty, 'b', 'c', 'd'], undefined, 4</strong> because The <code>delete</code> operator will delete the object property but it will not reindex the array or change its length. So the number or elements or length of the array won't be changed. If you try to print myChars then you can observe that it doesn't set an undefined value, rather the property is removed from the array.</p>"
            },
            {
                "name": "Output - return value of Duplicate paramater to function",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/duplicate3.png'><br><br><strong>Answer: </strong> The result is <strong>3, 2, 3</strong> because In non-strict mode, the regular JavaScript functions allow duplicate named parameters. The above code snippet has duplicate parameters on 1st and 3rd parameters. The value of the first parameter is mapped to the third argument which is passed to the function. Hence, the 3rd argument overrides the first parameter. In strict mode, duplicate parameters will throw a Syntax Error. <br><br><br><strong>Problem</strong><br><img src='./assets/jsCode/duplicate4.png'><br><br><strong>Answer: </strong> The result is <strong>SyntaxError: Duplicate parameter name not allowed in this context</strong> because Unlike regular functions, the arrow functions doesn't not allow duplicate parameters in either strict or non-strict mode. So you can see <code>SyntaxError</code> in the console.</p>"
            },
            {
                "name": "Output - What is the output of the below code and why? compare",
                "description": "<p><strong>Problem</strong><br><pre>console.log(10 == [10], 10 == [[[[[[[10]]]]]]]);</pre><br><br><strong>Answer: </strong> The result is <strong>True, True</strong> because As per the comparison algorithm in the ECMAScript specification(ECMA-262), the above expression converted into JS as below <br><pre>10 === Number([10].valueOf().toString()); // 10</pre><br>So it doesn't matter about number brackets([]) around the number, it is always converted to a number in the expression.</p>"
            },
            {
                "name": "Output - named function expression - foo bar typeof",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/namedexpression.png'></p><br><p><strong>Answer</strong> - The output would be Reference Error. A function definition can have only one reference variable as its function name.</p>"
            },
            {
                "name": "Write a function that would allow you to do this? addSix / createBase / closures",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/addsix.png'></p><br><p><strong>Answer</strong> - You can create a closure to keep the value passed to the function createBase even after the inner function is returned.<br><img src='./assets/jsCode/addsixfunc.png'></p>"
            },
            {
                "name": "FizzBuzz Challenge",
                "description": "<p><strong>Problem</strong>Create a for loop that iterates up to <code>100</code> while outputting <strong>\"fizz\"</strong> at multiples of <code>3</code>, <strong>\"buzz\"</strong> at multiples of <code>5</code> and <strong>\"fizzbuzz\"</strong> at multiples of <code>3</code> and <code>5</code>.</p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/fizzbuzz.png'></p>"
            },
            {
                "name": "How would you use a closure to create a private counter?",
                "description": "<p>You can create a function within an outer function (a closure) that allows you to update a private variable but the variable wouldn't be accessible from outside the function without the use of a helper function.<br><img src='./assets/jsCode/closureconter.png'></p>"
            },
            {
                "name": "Output - Value of b in expression var a=b=5",
                "description": "<p>The code above will output 5 even though it seems as if the variable was declared within a function and can't be accessed outside of it. This is because <br><strong><code>var a = b = 5</code></strong><br> is interpreted the following way: <br><strong><code>var a = b;<br>b = 5;</code></strong><br><br>But <code>b</code> is not declared anywhere in the function with var so it is set equal to <strong>5</strong> in the <strong>global scope</strong>.</p><br><br><p><strong>Another Case Problem</strong><br><img src='./assets/jsCode/aandb.png'></p><br><p><strong>Answer</strong> - <br><strong>a defined? false <br>b defined? true</strong> - since the statement <code>var a = b = 3;</code> is shorthand for the statements <code>b = 3;</code> and <code>var a = b;</code>, <code>b</code> ends up being a global variable (since it is not preceded by the <code>var</code> keyword) and is therefore still in scope even outside of the enclosing function.</p>"
            },
            {
                "name": "Output - 3>2>1 - returns false while 3>2>0 return true",
                "description": "<p>Let's pick this apart. First, it evaluates <strong>+(3 &gt; 2)</strong>. Yes, three is greater than two. Therefore, you now have expression like this <strong> +(true) &gt; 1</strong><br><br><strong>true</strong> is coerced into a number. That number happens to be <strong>1</strong>. <strong>1 &gt; 1</strong> is obviously false. Therefore, the result is: <strong>false</strong></p><br><br><p>Whereas in other case expression 1 > 0, and hence the result is true</p>"
            },
            {
                "name": "Output - 1<2<3 returns true",
                "description": "<p>Let's pick this apart. First, it evaluates <strong>+(1 &lt; 2)</strong>. Yes, one is less than two. Therefore, you now have expression like this <strong> +(true) &lt; 3</strong><br><br><strong>true</strong> is coerced into a number. That number happens to be <strong>1</strong>. <strong>1 &lt; 3</strong> is obviously true. Therefore, the result is: <strong>true</strong></p>"
            },
            {
                "name": "Output - 1<3>2 and 1>3<2",
                "description": "Result - false / true"
            },
            {
                "name": "Output - console 'this foo bar self'",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/outputfoobar.png'></p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/outputfoobar1.png'><br>In the outer function, both <code>this</code> and <code>self</code> refer to <code>myObject</code> and therefore both can properly reference and access <code>foo</code>.<br>In the inner function, though, <code>this</code> no longer refers to <code>myObject</code>.  As a result, <code>this.foo</code> is undefined in the inner function, whereas the reference to the local variable <code>self</code> remains in scope and is accessible there.</p>"
            },
            {
                "name": "Output - Palindrome",
                "description": "<p><img src='./assets/jsCode/palindrome.png'><br><br><img src='./assets/jsCode/palindrome1.png'></p>"
            },
            {
                "name": "Output - object property",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/objref.png'></p><br><p><strong>Answer</strong> - When setting an object property, JavaScript will implicitly <strong>stringify</strong> the parameter value. In this case, since <code>b</code> and <code>c</code> are both objects, they will <em>both</em> be converted to <code>\"[object Object]\"</code>. As a result, <code>a[b]</code> and<code>a[c]</code> are both equivalent to <code>a[\"[object Object]\"]</code> and can be used interchangeably.  Therefore, setting or referencing <code>a[c]</code> is precisely the same as setting or referencing <code>a[b]</code>.</p>"
            },
            {
                "name": "Output - Testing knowledge on \"this\"",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/this.png'></p><br><p><strong>Answer</strong> - <strong><code><br>10<br>2</code></strong><br><br>When setting an object property, JavaScript will implicitly <strong>stringify</strong><br><br>In the first place, as <code>fn</code> is passed as a parameter to the function <code>method</code>, the scope (<code>this</code>) of the function <code>fn</code> is <code>window</code>.  <code>var length = 10;</code> is declared at the <code>window</code> level. It also can be accessed as <code>window.length</code> or <code>length</code> or <code>this.length</code> (when <code>this === window</code>.)<br><br>Now, we know that we can access any number of arguments in a JavaScript function using the <code>arguments[]</code> array.<br><br>Hence <code>arguments[0]()</code> is nothing but calling <code>fn()</code>. Inside <code>fn</code> now, the scope of this function becomes the <code>arguments</code> array, and logging the length of <code>arguments[]</code> will return <code>2</code>.</p>"
            },
            {
                "name": "Output - try catch",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/varhoisting.png'></p><br><p><strong>Answer</strong> - <strong><code><br>1<br>undefined<br>2</code></strong><br><br><code>var</code> statements are hoisted (without their value initialization) to the top of the global or function scope it belongs to, even when it’s inside a <code>with</code> or <code>catch</code> block. However, the error’s identifier is only visible inside the <code>catch</code> block. It is equivalent to:<br><img src='./assets/jsCode/varhoisting1.png'></p>"
            },
            {
                "name": "Output - not hoisted / girl / 21 / 20",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/hoisting.png'></p><br><p><strong>Answer</strong> - Neither 21, nor 20, the result is <code>undefined</code>. It’s because JavaScript initialization is not hoisted.<br><br>(Why doesn’t it show the global value of 21? The reason is that when the function is executed, it checks that there’s a local <code>x</code> variable present but doesn’t yet declare it, so it won’t look for global one.)</p>"
            },
            {
                "name": "Output - closures / outer / inner",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/closure.png'></p><br><p><strong>Answer</strong> - Output to the console will be “3”.<br><br>There are three closures in the example, each with it’s own <code>var b</code> declaration. When a variable is invoked closures will be checked in order from local to global until an instance is found. Since the <code>inner</code> closure has a <code>b</code> variable of its own, that is what will be output.</p>"
            },
            {
                "name": "Output - Check if a given string is a isomorphic",
                "description": "<p>For two strings to be isomorphic, all occurrences of a character in string A can be replaced with another character to get string B. There must be one-to-one mapping for every char of string A to every char of string B.<br><img src='./assets/jsCode/isomorphic.png'></p><ul><li><strong>Step 1</strong> - Check if the same lenght. If not, they cannot be isomorphic</li><li><strong>Step 2</strong> - If the letter does not exist, create a map and map it to the value of the second letter</li><li><strong>Step 3</strong> - Eles if letterA already exists in the map, but it does not map to letterB, that means that A is mapping to more than one letter.</li><li><strong>Step 4</strong> - If after iterating through and conditions are satisfied, return true. They are isomorphic</li></ul>"
            },
            {
                "name": "Output - this in global/window object",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/closure1.png'></p><br><p><strong>Answer</strong> - <br><strong><code>global/window object<br>object \"b\"<br>global/window object</code></strong><br><br><br>Since we are using the arrow function inside <strong>func2, this </strong>keyword refers to the global object.<br><br><strong>Code 3 </strong>- Outputs in the following order:</p>"
            },
            {
                "name": "Output - this in IIFE",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/this1.png'></p><br><p><strong>Answer</strong> - <br><strong><code>\"Vivek\"<br>blank_value/undefined<br>\"Vivek\"</code></strong> - Only in the IIFE inside the function <strong>f</strong>, <strong>this </strong>keyword refers to the global/window object.</p>"
            },
            {
                "name": "Write the code for dynamically inserting new components / append nodes to the list.",
                "description": "<p><strong>Answer</strong><br><img src='./assets/js/append.png'></p>"
            },
            {
                "name": "Output of the following code? bar boolean",
                "description": "<p><strong>Problem</strong><br><img src ='./assets/jsCode/bartrue.png'><br><br><strong>Answer<br>1<br>truexyz<br>2<br>1</strong></p>"
            },
            {
                "name": "True False Rapid Fire",
                "description": "<p><strong>Question: </strong>Is<code>'false'</code>is!1?<br><strong>Answer: </strong>No.Because,it's a string with length greater than 0. Only empty string is false.</p><p><strong>Question: </strong> Is <code>' '</code> is false?<br><strong>Answer: </strong> No. Because, it's not an empty string.There is a white space in it.</p><p><strong>Question: </strong>What about<code>{}</code>?<br><strong>Answer: </strong> Its Truthy. It's an object. An object without any property is an object can't be falsy.</p><p><strong>Question: </strong>Tell me about<code>[]</code>?<br><strong>Answer: </strong>This is also truthy.It's an array object (array is child of object) is truthy.</p><p><strong>Question: </strong>You talked bout <code>''</code> to be falsy. What about <code>new String('')</code>?<br><strong>Answer: </strong> Though you are passing empty string to the string constructor, it is creating an String object. More precisely a instance of String object. It becomes an object. Hence, it is not false. so, it is truthy.</p><p><strong>Question: </strong> Tell me about <code>new Boolean(false)</code><br><strong>Answer: </strong> truthy. As it creates an instance of the Boolean object which is an object. Object is truthy.</p><p><strong>Question: </strong> <code>Boolean(function(){})</code><br><strong>Answer: </strong> <code>true</code> if you pass a truthy value to Boolean, it will be true.</p><p><strong>Question: </strong> <code>Boolean(/foo/)</code><br><strong>Answer: </strong> <code>true</code></p><p><strong>Question: </strong> <code>true%1</code><br><strong>Answer: </strong> 0. When you are trying to find reminder of true, true becomes 1 and reminder of 1 while dividing by 1 is 0. you will get same result if you doe <code>false%1</code></p><p><strong>Question: </strong> <code>''%1</code><br><strong>Answer: </strong>0</p>"
            },
            {
                "name": "Rapid Fire",
                "description": "<p><strong>Question: </strong> What is <code>typeof []</code><br><strong>Answer: </strong> Object. Actually Array is derived from Object. If you want to check array use <code>Array.isArray(arr)</code></p><p><strong>Question: </strong> What is <code>typeof arguments</code><br><strong>Answer: </strong> Object. arguments are array like but not array. it has length, can access by index but can't push pop, etc.</p><p><strong>Question: </strong> What is <code>2+true</code><br><strong>Answer: </strong> 3. The plus operator between a number and a boolean or two boolean will convert boolean to number. Hence, true converts to 1 and you get result of 2+1</p><p><strong>Question: </strong> What is <code>'6'+9</code><br><strong>Answer: </strong> 69. If one of the operands of the plus (+) operator is string it will convert other number or boolean to string and perform a concatenation. For the same reason, <code>'2'+true</code> will return '2true'</p><p><strong>Question: </strong> What is the value of <code>4+3+2+'1'</code><br><strong>Answer: </strong> 91 . The addition starts from the left, 4+3 results 7 and 7+2 is 9. So far, the plus operator is performing addition as both the operands are number. After that 9 + '1' where one of the operands is string and plus operator will perform concatenation.</p><p><strong>Question: </strong> What is the value of <code>'1'+2+4</code><br><strong>Answer: </strong> '124'. For this one '1' + 2 will produce '12' and '12'+4 will generates '124'.</p><p><strong>Question: </strong> What is the value of <code>-'34'+10</code><br><strong>Answer: </strong> -24. minus(-) in front of a string is an unary operator that will convert the string to a number and will make it negative. Hence, -'34' becomes, -34 and then plus (+) will perform simple addition as both the operands are number.</p><p><strong>Question: </strong> What is the value of <code>+'dude'</code><br><strong>Answer: </strong> NaN. The plus (+) operator in front of a string is an unary operator that will try to convert the string to number. Here, JavaScript will fail to convert the 'dude' to a number and will produce NaN.</p><p><strong>Question: </strong> What is <code>console.log(10 + \"10\", 10 - \"10\");</code><br><strong>Answer:  1010, 0</strong> The concatenation operator(+) is applicable for both number and string types. So if any operand is string type then both operands concatenated as strings. Whereas subtract(-) operator tries to convert the operands as number type.</p><p><strong>Question: </strong> What is <code>let [a, ...b,] = [1, 2, 3, 4, 5]; console.log(a, b);</code><br><strong>Answer:  SyntaxError</strong> When using rest parameters, trailing commas are not allowed and will throw a SyntaxError. If you remove the trailing comma then it displays <strong>[1, 2, 3, 4, 5]</strong></p><p><strong>Question: </strong> If you have <code>var y=1, x=y=typeof x;</code> What is the value of x?<br><strong>Answer: </strong> 'undefined'</p><p><strong>Question: </strong> for <code>var a=(2, 3, 5);</code> what is the value of a?<br><strong>Answer: </strong> 5. The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand.</p><p><strong>Question: </strong> for <code>var a=(1, 5 - 1) * 2</code> what is the value of a?<br><strong>Answer: </strong> 8</p><p><strong>Question: </strong> What is the value of <code>!'bang'</code><br><strong>Answer: </strong> false. <code>!</code> is NOT. If you put <code>!</code> in front of truthy values, it will return false. Using !! (double bang) is a tricky way to check anything truthy or falsy by avoiding implicit type conversion of==comparison.</p><p><strong>Question: </strong> What is the value of <code>parseFloat('12.3.4')</code><br><strong>Answer: </strong> 12.3</p><p><strong>Question: </strong> What is the value of <code>Math.max([2,3,4,5]);</code><br><strong>Answer: </strong> NaN</p><p><strong>Question: </strong> <code>3 instanceof Number</code><br><strong>Answer: </strong> false</p><p><strong>Question: </strong><code>null==undefined</code><br><strong>Answer: </strong> true</p><p><strong>Question: </strong>What is the value of <code>!!function(){};</code><br><strong>Answer: </strong> true</p><p><strong>Question: </strong> What is the value of <code>typeof bar</code><br><strong>Answer: </strong> 'undefined'</p><p><strong>Question: </strong> What is the value of <code>typeof null</code><br><strong>Answer: </strong> 'object'</p><p><strong>Question: </strong> If <code> var a=2, b=3</code> what would be value of <code>a &amp;&amp; b</code><br><strong>Answer: </strong> 3</p><p><strong>Question: </strong> What would be consoled <code>var foo='outside'; function logIt(){console.log(foo); var foo='inside';}logIt();</code><br><strong>Answer: </strong> undefined</p><p><strong>Question: </strong> What is <code>-5%2</code><br><strong>Answer: </strong>-1. the result of remainder always get the symbol of first operand</p><p><strong>Question: </strong> Why <code>.1+.2 !=.3</code><br><strong>Answer: true - floating point errors in internally representing certain numbers. 0.1 + 0.2 does not nicely come out to 0.3</strong></p><p><strong>Question: </strong> What is <code>console.log([1, 2] + [3, 4]);</code><br><strong>Answer:  1,23,4</strong> The + operator is not meant or defined for arrays. So it converts arrays into strings and concatenates them.</p><p><strong>Question: <code>42..toString()</code></strong><br><strong>Anwser:</strong> <code>'42'</code></p><p><strong>Question: </strong> <code>4.2..toString</code><br><strong>Anwser:</strong> //SyntaxError: Unexpected token .</p><p><strong>Question: </strong><code>42 . toString()</code><br><strong>Anwser:</strong> <code>'42'</code></p><p><strong>Question: </strong> <code>typeof(NaN)</code><br><strong>Anwser:</strong>'number'</p><p><strong>Question: </strong> <code>2 in [1,2]</code><br><strong>Anwser:</strong> false. Because 'in' returns whether a particular property/index available in the Object. In this case object has index 0 and 1 but don't have 2. Hence you get false.</p>"
            },
            {
                "name": "Output - Recursion example Flatten array",
                "description": "<p><strong>Algorithm steps:</strong></p><ul><li>First, we iterate through the given array.</li><li>Then check each element:<ul><li>if it is not an array then push the elements in an updated array.</li><li>if it is an array then again call the same function <code>flatten()</code> i.e. recursion. Then we will combine our updated array and return values of <code>flatten()</code> using the spread operator in ES6. This will keep flatting the updated array.</li></ul></li></ul><p><strong>Solution 1</strong><br><img src='./assets/jsCode/flattenforloop.png'><br><br><strong>Solution 2</strong><br><img src='./assets/jsCode/flatten.png'></p>"
            },
            {
                "name": "Output - Recursion example 'display countdown numbers'",
                "description": "<p><strong>Algorithm steps:</strong></p><ul><li>First, we iterate through the given number.</li><li>Then we decrease the number by 1 and store that value in a variable</li><li>Then we evaluate the new stored value against the condition greater than 0, if it is then we again trigger the countdown function.</li></ul><p><img src='./assets/jsCode/recursioncountdown.png'></p>"
            },
            {
                "name": "Output - Recursion example 'display 1 to 10 from array'",
                "description": "<p><img src='./assets/jsCode/recursioncountdown1.png'><br><img src='./assets/jsCode/recursioncountdown2.png'></p>" 
            }, 
            {
                "name": "Output - Find Factorial",
                "description": "<p>The factorial function says to multiply all the whole numbers from the chosen number down to one. In more mathematical terms, the factorial of a number <strong>(n!) is equal to n(n-1)</strong>.<br><br><img src='./assets/jsCode/factorial.png'></p>"
            },
            {
                "name": "Output - Find out prime factors of the number",
                "description": "<p><strong>Solution 1</strong><br><img src='./assets/jsCode/factors1.png'><br><br><strong>Solution 2</strong><br><img src='./assets/jsCode/factors.png'></p>"
            },
            {
                "name": "Output - Perfect number using Javascript",
                "description": "<p>In number theory, a perfect number is a positive integer that is equal to the sum of its proper positive divisors, that is, the sum of its positive divisors excluding the number itself<br><i>Example</i> : The first perfect number is 6, because 1, 2, and 3 are its proper positive divisors, and 1 + 2 + 3 = 6. Equivalently, the number 6 is equal to half the sum of all its positive divisors: ( 1 + 2 + 3 + 6 ) / 2 = 6. The next perfect number is 28 = 1 + 2 + 4 + 7 + 14.<br><br><img src='./assets/jsCode/perfectnumber.png'></p>"
            },
            {
                "name": "Output - digits from a string with numbers",
                "description": "<p><strong>var strNum = \"only123!\"; </strong><br><br>To fetch the digits from the above string, the following RegExp is used: <img src='./assets/jsCode/regexp.png'><br><br><img src='./assets/jsCode/findnumber.png'></p>"
            },
            {
                "name": "Output - non-digit characters from a string",
                "description": "<p><strong>var strNum = \"DEMO989#@#@\";</strong><br><br>The following RegExp is used to get a non-digits:&nbsp;<img src='./assets/jsCode/regexp1.png'><br><br><img src='./assets/jsCode/findalphabets.png'></p>"
            }
        ]
    },
    {
        "folder": "Angular",
        "title": "Angular",
        "url": "/folder/Angular",
        "icon": "logo-angular",
        "question": [
            {
                "name": "What is Angular Framework?",
                "description": "<p>Angular is a open-source framework for building complex web applications using the Model-View-Controller (MVC) pattern using HTML and TypeScript. It  facilitates creating sophisticated, efficient and complex single page applications.<br><br> Angular gives features like Dependency Injection, Declarative Templates, end-to-end tooling with cli which bootstrap a new development environment by creating, compiling, bundling and deploying the application in one go</p>"
            },
            {
                "name": "Difference between AngularJS and Angular?",
                "description": "<p>Angular is a completely revived component-based framework in which an application is a tree of individual components.</p><img src='./assets/angular/angularjsvsangular.png' />"
            },
            {
                "name": "What is Typescript?",
                "description": "<p>TypeScript is a superset of JavaScript created by Microsoft that adds optional types, classes, async/await, and many other features, and compiles to plain JavaScript. Angular 2+ versions are entirely built in TypeScript and acts its primary language.<br><br><strong>Data types of Typescript</strong><strong>#1. String <br>#2. Number <br>#3. Boolean</strong> <br><strong>#4. Array</strong>: Example const myArr: number[] = [12, 90, 71]; <br><strong>#5. Any</strong> - is the type we set whenever we're unsure of the types of data we'll be getting. <br><strong>#6. Tuple</strong> - is an arrays with a fixed number of elements and its type of index value. <br><img src='./assets/angular/tuple.png'> <br><strong>#7. Enum</strong> - It represents a group of constants (unchangeable variables) <br><img src='./assets/js/enumts.png'> <br><strong>#8. Interface</strong> - It is a group of more complex object/array with other data types <br><img src='./assets/angular/interface.png'><br><strong>#9. Functions <br>#10. Classes</strong> </p><br><br><strong>Advantages of Typescript over Javascript</strong><ul><li>TypeScript is able to find compile time errors at the development time only and it makes sures less runtime errors. Whereas javascript is an interpreted language.</li><li>TypeScript is strongly-typed or supports static typing which allows for checking type correctness at compile time. This is not available in javascript.</li><li>TypeScript compiler can compile the .ts files into ES3,ES4 and ES5 unlike ES6 features of javascript which may not be supported in some browsers.</li></ul>"
            },
            {
                "name": "Difference between TypeScript and JavaScript",
                "description": "<table><tbody><tr><td><strong>TypeScript</strong></td><td><strong>JavaScript</strong></td></tr><tr><td>Superset of JavaScript developed to overcome code complexity for large projects.</td><td>A scripting language that helps create dynamic web page content.</td></tr><tr><td>Errors can be found and corrected during compile time.</td><td>Errors can be found only during run-time as it is an interpreted language.</td></tr><tr><td>Strongly typed, supports both static and dynamic typing.</td><td>Weakly typed, no option for static typing.</td></tr><tr><td>Converted into JavaScript code to be understandable for browsers.</td><td>Can be directly used in browsers.</td></tr><tr><td>Since it is a superset, all the JavaScript libraries, and other JavaScript code works without any changes.</td><td>JS libraries work by default.</td></tr><tr><td>There is support for ES3, ES4, ES5 and ES6.</td><td>No support for compiling additional ES3, ES4, ES5 or ES6 features.</td></tr><tr><td>Supports modules, generics and interfaces to define data.</td><td>No support for modules, generics or interface.</td></tr><tr><td>Functions can have optional parameters.</td><td>Functions cannot have optional parameters.</td></tr><tr><td>Numbers and strings are considered as interfaces.</td><td>Number and string are objects.</td></tr><tr><td>Powerful and intuitive language for large projects.</td><td>Neat and clean, most suitable for simple web applications.</td></tr><tr><td>Community support is still growing.</td><td>Huge community support with lots of documentation and support for solving issues.</td></tr><tr><td>Prototyping is possible</td><td>No support for prototyping.</td></tr><tr><td>Takes time to learn and code, scripting knowledge is a must.</td><td>Can be learned on the go, no prior scripting experience is needed.</td></tr><tr><td>Proper build setup (npm package) is required for static type definitions</td><td>No build setup is required.</td></tr></tbody></table>"
            },
			{
                "name": "What is a TypeScript Map file?",
                "description": "<p><code>.map</code> files are source map files that let tools map between the emitted JavaScript code and the TypeScript source files that created it. Many debuggers (e.g. Visual Studio or Chrome's dev tools) can consume these files so you can debug the TypeScript file instead of the JavaScript file.</p>"
            },
			{
                "name": "What are the key components / building blocks of Angular?",
                "description": "<p></p><ol><li><strong>Component:</strong> These are the basic UI building blocks of angular application to control HTML views.</li><li><strong>Directives: </strong>Directives add behaviour to an existing DOM element or an existing component instance. We write a directive when we want to write reusable behaviour to supplement existing DOM elements.</li><li><strong>Modules:</strong> An angular module is set of angular basic building blocks like component, directives, services etc. An application is divided into logical pieces and each piece of code is called as 'module' which perform a single task.</li><li><strong>Templates:</strong> This represent the views of an Angular application.</li><li><strong>Services:</strong> It is used to create components which can be shared across the entire application.</li><li><strong>Dependency Injection: </strong>Dependency Injection (DI) is a technique in which a class receives its dependencies from external sources rather than creating them itself. It allows us to inject dependencies into the Component, Directives, Pipes, or Services.</li><li><strong>Data Binding:</strong> Allows to define communication between a component and the DOM</li><li><strong>Metadata:</strong> This can be used to add more data to an Angular class.</li></ol>"
            },
			{
                "name": "What is NgModule / Module / declarations / exports / imports / provider / bootstrap ?",
                "description": "<p>An <strong>NgModule</strong> is defined by a class decorated with @NgModule(). The @NgModule() decorator is a function that takes a single metadata object, whose properties describe the module.<br><br>There are basically <strong>two types of modules.<br>First,</strong> is your <code>'Root module'</code>, which is the entry point of your app. You can technically put everything in your app into just one module.<br><br>Then Second comes your <code>'Feature modules'</code>, which are used for separation of concerns during development, but also for things like lazy-loading of parts of the app. This is more of an issue for larger apps, but it doing it early can certainly help you set things up \"right\".<br><br><br><strong>About the most important properties of a @NgModule which takes a single meta data are as follows.<br><br>#1. declarations:</strong> This array is used to define components, directives, and pipes in the respective module You should add only those, which belong to this module. The Component cannot belong to more than one module.<br><br><strong>#2. exports:</strong> If you want other modules to use the component, pipes, directives of this NgModule, then those must be specified here. Remember: Only those components declared here are visible to the other ngModules, when they import this module.<br><br><strong>#3. imports:</strong> If you want this ngModule require any feature or functionality, then those modules need to be imported here. Any components, directives, and pipes that are defined and exported in that module can be used in this module.<br><br><strong>#4. providers:</strong> In this array <strong>Services</strong>, which you want to add to the global collection of services are added here. The services are then available for injection via <strong>dependency injection</strong>.<br><br><strong>#5. bootstrap:</strong> The main component of this module, which needs to be loaded when the module is loaded is specified here. This is a must if you are the first module (<strong> called the root module) </strong>that is loaded when the Angular App starts. It is the responsibility of the root module to load the first view and it is done by specifying the component here. If the module is not the root module, then you should keep this blank</p>"
            },
            {
                "name": "What are directives? and its types",
                "description": "<p>Directives add behaviour to an existing DOM element or an existing component instance. We write a directive when we want to write reusable behaviour to supplement existing DOM elements.</p><ul><li><strong>Components</strong> — These are directives with a template.</li><li><strong>Structural directives</strong> — These directives change the DOM layout by adding and removing DOM elements. Ex. *ngFor, *ngIf, *ngSwitchCase,</li><li><strong>Attribute directives</strong> — These directives change the appearance or behavior of an element, component, or another directive. [ngClass],[ngStyle], [ngModel],  [routerLinkActive] etc</li></ul><br><p><img src='./assets/angular/custom-directive.png'><br><br>To apply - &lt;p appHighlight&gt;Highlight me&lt;/p&gt;</p>"
            },
            {
                "name": "What are components?",
                "description": "<p>Components are the most basic <strong>UI</strong> building block of an Angular app which form a tree of Angular components. The components basically represent itself as subset of directives. The only thing differing is that components always have a template and only one component can be instantiated per an element in a template.<br><br><img src='./assets/angular/component.png' />"
            },
			{
                "name": "What are dynamic components?",
                "description": "<p>Dynamic components are the components in which components location in the application is not defined at build time.i.e, They are not used in any angular template. But the component is instantiated and placed in the application at runtime.<br><br><p><strong>Steps to Create a component dynamically</strong></p><ul><li>Step 1 - First We need a container element in the component. This can be achieved by using a entry point template or a container template</li><li>Step 2 - Second In the AppComponent, we need to import<ol><li>ViewChild, ViewContainerRef, and ComponentFactoryResolver from @angular/core</li><li>ComponentRef and ComponentFactory from @angular/core</li><li>MessageComponent from message.component</li></ol><ul><li><strong>ViewContainerRef</strong> represents container where one or more view can be attached. This can contain two types of views.</li></ul></li><li>Step 3 - Let us create a variable called entry which will refer template element. In addition, we have injected <strong>ComponentFactoryResolver</strong> services to component class, which will be needed to dynamically load the component. <strong>Keep in mind that entry variable which is reference of template element has API to create components, destroy components etc.</strong><ol><li>The <strong>ComponentFactoryResolver</strong> service exposes one primary method, <strong>resolveComponentFactory</strong>.</li><li>The <strong>resolveComponentFactory()</strong> method takes a component and returns a <strong>ComponentFactory</strong>.</li><li>You can think of <strong>ComponentFactory</strong> as an object that knows how to create a component. The <strong>ComponentFactory</strong> exposes the <strong>create()</strong> method that will be used by the container ( ViewContainerRef ) internally.</li></ol></li><li>Last Step - Finally destroy the component using the <strong>ComponentFactory</strong> destroy() method</li></ul><br><br><img src='./assets/angular/dynamic-component.png'><br><img src='./assets/angular/dynamic-component1.png'></p>"
            },
			{
                "name": "Difference between Component and Directives?",
                "description": "<p>In a short note, A component(@component) is a directive-with-a-template</p><ul><li>To register a <strong>Component</strong> we use <strong>@Component</strong> meta-data annotation and for <strong>Directive</strong> we use <strong>@Directive</strong> meta-data</li><li><strong>Directives</strong> add behaviour to an existing DOM element or an existing component instance.</li><li><strong>Component</strong>, rather than adding/modifying behaviour, actually creates its own view (hierarchy of DOM elements) with attached behaviour.</li></ul><br><p><strong>Conclusion:</strong> We write a component when you want to create a reusable set of DOM elements of UI with custom behaviour.<br>We write a directive when you want to write reusable behaviour to supplement existing DOM elements.</p>"
            },
			{
                "name": "Difference between Angular Component and Module?",
                "description": "<p><strong>Components</strong> control views (html). They also communicate with other components and services to bring functionality to your app.<br><br><strong>Modules</strong> consist of one or more components. They do not control any html. Your modules declare which components can be used by components belonging to other modules, which classes will be injected by the dependency injector and which component gets bootstrapped. Modules allow you to manage your components to bring modularity to your app.</p>"
            },
			{
                "name": "What is a template / choose between inline and external template file? ",
                "description": "<p>A template is a HTML view where you can display data by binding controls to properties of an Angular component.<br><br>You can store your component's template in one of two places. You can define it inline using the <strong>template</strong> property, or you can define the template in a separate HTML file and link to it in the component metadata using the <strong>@Component</strong> decorator's <strong>templateUrl</strong> property.</p>"
            },
			{
                "name": "What are Pipes? Pure and Impure Pipes",
                "description": "<p>Angular Pipes takes data as input and formats or transform the data to display in the template. We use them to change the appearance of the data before presenting it to the user. The most common use case of pipes is displaying the dates in the correct format as per the user’s locale.<br><br>One can create its own custom pipes. Example of pipes such are <code>DatePipe</code>, <code>UpperCasePipe</code>, <code>LowerCasePipe</code>, <code>CurrencyPipe</code>, and <code>PercentPipe</code>.<br><br>A <strong>pure pipe</strong> is only called when Angular detects a change in the value or the parameters passed to a pipe. For example, any changes to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object).<br><br>An <strong>impure pipe</strong> is called for every change detection cycle no matter whether the value or parameters changes. i.e, An impure pipe is called often, as often as every keystroke or mouse-move.</p>"
            },
			{
                "name": "What is a parameterized pipe?",
                "description": "<p>A pipe can accept any number of optional parameters to fine-tune its output. The parameterized pipe can be created by declaring the pipe name with a colon ( : ) and then the parameter value. If the pipe accepts multiple parameters, separate the values with colons. Let's take a birthday example with a particular format(dd/MM/yyyy)</p>&lt;div&gt;Birthday is {{ birthday | date:'dd/MM/yyyy'}}&lt;/div&gt;"
            },
            {
                "name": "How do you chain pipes?",
                "description": "<p>&lt;div&gt;Birthday is {{ birthday | date | uppercase}}&lt;/div&gt;</p>"
            },
            {
                "name": "What is slice pipe?",
                "description": "<p>The slice pipe is used to create a new Array or String containing a subset (slice) of the elements. The syntax looks like as below,<br><br><code>{{ value_expression | slice : start [ : end ] }}<br><br><li *ngFor='let i of greeting | slice:0:5'>{{i}}</li></code></p>"
            },
			{
                "name": "Write code for custom pipe for change the string to title case?",
                "description": "<p><img src='./assets/expertAngular/titlecasePipe.png'></p>"
            },
            {
                "name": "How pipe change detection works for primitive and references objects ?",
                "description": "<p><strong>Detecting pure changes to primitives and object references</strong> - With a pure pipe, Angular ignores changes within composite objects, such as a newly added element of an existing array, because checking a primitive value or object reference is much faster than performing a deep check for differences within objects. Angular can quickly determine if it can skip executing the pipe and updating the view. <br>However, a pure pipe with an array as input may not work the way you want. <br>The app shows unexpected behavior: - This happens because whenever you add a new data to the array and that too by does so by pushing it onto the heroes array: The change detector ignores changes to elements of an array, so the pipe doesn't run. The reason Angular ignores the changed array element is that the reference to the array hasn't changed. Since the array is the same, Angular does not update the display. <br>One way to get the behavior you want is to change the object reference itself. You can replace the array with a new array containing the newly changed elements, and then input the new array to the pipe. <br> if you mutate(eg: push, pop) the input array, the pure pipe doesn't execute. If you replace the input array, the pipe executes and the display is updated.<br><br><strong>Detecting impure changes within composite objects</strong> - To execute a custom pipe after a change within a composite object, such as a change to an element of an array, you need to define your pipe as impure to detect impure changes. because Angular executes an impure pipe every time it detects a change with every keystroke or mouse movement.</p>"
            },
            {
                "name": "What are lifecycle hooks available?",
                "description": "<p>Angular application goes through an entire set of processes or has a lifecycle right from its initiation to the end of the application</p><ul><li><strong>ngOnChanges:</strong> When the value of a <strong>input</strong> property of the component or directive changes, then this method is called.</li><li><strong>ngOnInit:</strong> This hook is <strong>fired only once and immediately after <strong>ngOnChanges</strong> creation</strong> (during the first change detection). This is a perfect place where you want to add any <strong>initialisation logic for your component</strong>.  Here you have access to every input property of the component. You can use them in <strong>http get requests to get the data from the back end server or run some initialization logic</strong> etc.</li><li><strong>ngDoCheck:</strong> The Angular invokes the <strong>ngDoCheck</strong> hook event <strong>during every change detection cycle</strong>. This hook is invoked even if there is no change in any of the properties. Angular invokes it after the <strong>ngOnChanges</strong> & <strong>ngOnInit</strong> hooks.</li><li><strong>ngAfterContentInit:</strong> This hook is called <strong>after the Component's projected content has been fully initialized</strong>. Angular also updates the properties decorated with the <strong>ContentChild and ContentChildren</strong> before raising this hook. <strong>ngAfterContentInit:</strong> hook is also raised, even if there is no content to project.</li><li><strong>ngAfterContentChecked:</strong> This hook is very similar to the ngAfterContentInit hook. Both are called after the external content is initialized, checked & updated. Only difference is that ngAfterContentChecked is raised after every change detection cycle. While ngAfterContentInit during the first change detection cycle.</li><li><strong>ngAfterViewInit:</strong> This hook is called after the Component's View & all its child views are fully initialized. Angular also updates the properties decorated with the <strong>ViewChild & ViewChildren</strong> properties before raising this hook.<br><br>The View here refers to the template of the current component and all its child components & directives.<br><br>This hook is called during the first change detection cycle, where angular initializes the view for the first time<br><br>At this point all the lifecycle hook methods & change detection of all child components & directives are processed & Component is completely ready </li><li><strong>ngAfterViewChecked:</strong> The Angular fires this hook after it checks & updates the component's views and child views. This event is fired after the <strong>ngAfterViewInit</strong> and after that during every change detection cycle<br><br>This hook is very similar to the <strong>ngAfterViewInit</strong> hook. Both are called after all the child components & directives are initialized and updated. Only difference is that <strong>ngAfterViewChecked</strong> is raised during every change detection cycle. While <strong>ngAfterViewInit</strong> during the first change detection cycle.</li><li><strong>ngOnDestroy:</strong> This hook is called <strong>just before the Component/Directive instance is destroyed</strong> by Angular<br><br>You can Perform any cleanup logic for the Component here. This is the correct place where you would like to <strong>Unsubscribe Observables</strong> and detach event handlers to avoid memory leaks.</li></ul>"
            },
			{
                "name": "Difference between constructor and ngOnInit?",
                "description": "<ul><li>The main difference between <strong>constructor</strong> and <strong>ngOnInit</strong> is that <strong>ngOnInit</strong> is <strong>lifecycle hook</strong> and runs after <strong>constructor</strong> which is <strong>class method</strong>.</li><li>The <strong>constructor</strong> is a default method of the class in typescript/javascript engine that is executed when the class is instantiated, whereas <strong>ngOnInit</strong> method is specific to Angular</li><li><strong>Constructor</strong> is automaticlly called at the time of creating object of the class, whereas <strong>ngOninit</strong> Invoked by Angular when component is initialized</li><li>Common purpose of <strong>Constructor</strong> that it is used for Injecting dependencies, whereas in <strong>ngOninit</strong> the actual business logic performed here</li></ul>"
            },
            {
                "name": "What is a data binding?",
                "description": "<p>Data binding is a core concept in Angular that allows to define communication between a component and the DOM</p><ul><li> <strong>From the Component to the DOM</strong>: <br>#Interpolation: {{ value }}: Adds the value of a property from the component<br>#Property binding: [property]='value': The value is passed from the component to the specified property or simple HTML attribute</li><li><strong>From the DOM to the Component</strong>: Event binding: (click)='functionName()': When a specific DOM event happens (eg.: click, change, keyup), call the specified method in the component</li><li><strong>Two-way binding: Two-way data binding: [(ngModel)]='value'</strong>: Two-way data binding allows to have the data flow both ways from view to componenet and component to the view.</li></ul>"
            },
			{
                "name": "What is Metadata and types of decorators in Angular",
                "description": "<p>The whole purpose of Angular decorators is to store metadata about a class, method, or property. When you configure a component, you are providing a metadata for that class that tells Angular that you have a component, and that component has a specific configuration. Each decorator has a base configuration with some default values. When the decorator is created using the relevant factory, the default configuration is passed.<br><br><strong>There are four types of decorators in Angular:</strong></p><ol><li>Class Decorators</li><li>Property Decorators</li><li>Method Decorators</li><li>Parameter Decorators</li></ol><p><strong>Class Decorators</strong> - Class Decorators are the top-level decorators that are used to define the purpose for the classes. They provide information to Angular that a particular class is a component, or module. <br><img src='./assets/expertAngular/classDecorator.png'><br><br><strong>Property Decorators</strong> - Property decorators are used to decorate the specific properties within the classes. Take a look at <code>@Input()</code>. Imagine that you have a property within the class that you want to have an input binding. for which Angular's compiler will automatically create an input binding from the property name and link them. <br><img src='./assets/expertAngular/propertyDecorator.png'><br><br><strong>Method Decorators</strong> - A Method Decorator decorates specific methods within your class with functionality. This is declared just before a method declaration. A good example of this is <code>@HostListener</code>. This tells Angular that when an event on your host happens, you want the decorated method to be called with the event. <br><img src='./assets/expertAngular/methodDecorator.png'><br><br><strong>Parameter Decorators</strong> - Parameter decorators are used to decorate parameters in your class constructors. For example- <code>@Inject</code>. It tells Angular that what you want that parameter to be initiated with. <br><img src='./assets/expertAngular/parameterDecorator.png'></p>"
            },
			{
                "name": "What are the class decorators in Angular?",
                "description": "<p>A class decorator is a decorator that appears immediately before a class definition, which declares the class to be of the given type, and provides metadata suitable to the type.<br>The following list of decorators comes under class decorators,</p><ul><li>@Component()</li><li>@Directive()</li><li>@Pipe()</li><li>@Injectable()</li><li>@NgModule()</li></ul>"
            },
            {
                "name": "What are class field decorators?",
                "description": "<p>The class field decorators are the statements declared immediately before a field in a class definition that defines the type of that field. Some of the examples are: @input and @output,<br><img src='./assets/angular/class-field.png'></p>"
            },
            {
                "name": "Differences between an Annotation and a Decorator in Angular?",
                "description": "<p>Annotations and Decorators both share the same @ symbol in Angular, they both are different language features.<br><br><strong>Annotations:</strong> These are hard-coded language feature. Annotations are only metadata set on the class that is used to reflect the metadata library. When user annotates a class, the compiler creates an attribute on that class called annotations, stores an annotation array in it, then tries to instantiate an object with the same name as the annotation, passing the metadata into the constructor. Annotations are not predefined in AngularJs so we can name them on our own. <strong>Example:</strong> Here component is annotated as <strong>ComponentAnnotation</strong> and further used. <br><img src='./assets/angular/annotation.png'><br><br><strong>Decorators:</strong> A decorator is a function that adds metadata to a class, its members, or its method arguments. A decorator is just a function that gives you access to the target that needs to be decorated. There are four type of decorators all of them are mentioned below: #Class decorators like @Component, @NgModule, #Property decorators like @Input and @Output, #Method decorators like @HostListener, #Parameter decorators like @Injectable</p>"
            },
			{
                "name": "What is angular CLI?",
                "description": "<p>Angular CLI(<strong>Command Line Interface</strong>) is a command line interface use to build angular apps using nodejs style (commonJs) modules. You need to install using below npm command,<br><br><code>npm install @angular/cli@latest</code><br><br>List Of Commands: <br><strong>#1. Creating New Project:</strong> ng new <br><strong>#2. Generating Components, Directives &amp; Services:</strong> ng generate class / component / directive / pipes / service <br><strong>#3. Running the Project:</strong> ng serve</p>"
            },
			{
                "name": "What is a service?",
                "description": "<p>A service is used when a common functionality needs to be shared with multiple modules. Services allow separation of concerns i.e. by allowing you to extract common functionality out of components is the main reason why Angular services came into existence. Angular services are instantiated only once during the lifetime of an application.</p>"
            },
			{
                "name": "What is dependency injection in Angular?",
                "description": "<p><strong>Dependency Injection (DI) is a technique in which a class receives its dependencies from external sources rather than creating them itself</strong>.<br><br>The Angular dependency injection is now the core part of the Angular 2+ versions. It allows us to inject dependencies into the Component, Directives, Pipes, or Services.</p>"
            },
            {
                "name": "What is a provider token?",
                "description": "<p>The Dependency Injection system in Angular uses tokens to uniquely identify a Provider. There are three types of tokens that you can create in Angular. They are <strong>Type Token, String Token, and Injection Token.</strong></p><br><p><strong>DI Tokens</strong> - We declare the Provider in with providers metadata. This is how it looks like. <br><img src='./assets/expertAngular/provider.png'><br>The syntax has two properties. <strong><code>provide (provide: ProductService)</code></strong> & <strong><code>provider (useClass: ProductService)</code></strong><br>The first property is <code>Provide</code> holds the <strong>Token or DI Token</strong>. The Tokens act like a key. The DI systems need the key to locate the <code>provider</code> in the <code>Providers</code> array. <br><img src='./assets/expertAngular/Angular-Provider.png'><br>The Token can be either a <strong>type</strong>, a <strong>string</strong> or an instance of <strong>InjectionToken</strong>.</p><br><p><strong>Type Token</strong> - Here the type being injected is used as the token. <br>For Example, we would like to inject the instance of the <code>ProductService</code>, we will use the <code>ProducService</code><br><img src='./assets/expertAngular/Angular-Provider.png'><br>The <code>ProductService</code> is then injected into the component by using the following code.<br><img src='./assets/expertAngular/provider1.png'><br>You can keep the same token (ProductService) and change the class to another implementation of the Product service. For Example in the following code, we change it to <code>BetterProductService</code>.<br><img src='./assets/expertAngular/provider2.png'><br>Angular does not complain if we use the token again. In the following example token <code>ProductService</code> used twice. In such a situation last to register wins <code>(BetterProductService)</code>.</p><br><p><strong>String token</strong> - You can use the Type token only if you have Type representation. But that is not the case always. Sometimes we need to inject simple string values or simple object literal, where there is no type.<br><img src='./assets/expertAngular/provider3.png'><br>You can then use the Inject the <code>ProductService</code> using the <code>@Inject</code> method<br><img src='./assets/expertAngular/provider4.png'><br><br><strong>Example</strong><br><img src='./assets/expertAngular/provider5.png'><br><img src='./assets/expertAngular/provider6.png'></p>"
            },
            {
                "name": "What is a factory provider?",
                "description": "<p>A Provider works as an instructor for the dependency injection system to resolve the dependencies.<br><br>With <strong>Factory provider</strong> you can configure the Injector to return a value by invoking a specific function. <br><img src='./assets/expertAngular/factory.png'><br><br>The <code>provide</code> property configures the token that will be used in dependency injection and the <code>useFactory</code> is pointing to the function that will be used to return the desired value. The <code>deps</code> property configures the tokens that will be passed to your factory function.<br><br><strong>When to use it?</strong> - Factory provider can be very handy when you need to create a dependent value dynamically, based on information you won't have until run time. You can make an informed decision on which value to return based on other services and application state.<br><br><strong>Example:</strong> - Let’s try to guess which mobile device a user is logged in from. We will try to use information such as the browser user-agent, screen width, and screen height. Let’s define three token that will be used later on to identify the device name. <br>The <strong>InjectionToken</strong> class — Creates a token that can be used in Angular dependency injection. <strong>InjectionToken</strong> is parameterized on T which is the type of object which will be returned by the Injector. This provides an additional level of type safety. <br><img src='./assets/expertAngular/factory1.png'><br><br>Now we can come up with an algorithm to detect the device name based on the three tokens we defined above. We pass an arrow function to the useFactory that has 3 dependencies, in order to resolve those dependencies, we pass in a dependency array (dep) with the listed tokens. <br><img src='./assets/expertAngular/factory2.png'><br>Finally, we will consume the device name in our Angular component.<br><img src='./assets/expertAngular/factory3.png'><br><br>The Inject parameter decorator indicates to Angular DI that this parameter (deviceName) should be resolved from a defined token — DeviceName.</p>"
            },
            {
                "name": "How do you configure injectors with providers at different levels?",
                "description": "<p>You can configure injectors with providers at different levels of your application by setting a metadata value. The configuration can happen in one of three places,</p><ol><li>In the <code>@Injectable()</code> decorator for the service itself</li><li>In the <code>@NgModule()</code> decorator for an NgModule</li><li>In the <code>@Component()</code> decorator for a component</li></ol>"
            },
			{
                "name": "What is purpose / use of Async pipe?",
                "description": "<p>The <strong>async pipe</strong> can make a huge difference in your change detection strategy for your Angular app. In Angular, the <strong>async pipe</strong> is a pipe that essentially does these three tasks:</p><ul><li>It subscribes to an observable or a promise and returns the last emitted value.</li><li>Whenever a new value is emitted, it marks the component to be checked. That means Angular will run Change Detector for that component in the next cycle.</li><li>It unsubscribes from the observable when the component gets destroyed.</li></ul>"
            },
            {
                "name": "What is interpolation?",
                "description": "<p>It is represented by double curly braces({{}}). The text between the braces is often the name of a component property. Angular replaces that name with the string value of the corresponding component property.</p>"
            },
            {
                "name": "String interpolation in TypeScript?  ",
                "description": "<ul><li>You can use <em>template iterals</em>,</li><li><em>Template literals</em> are literals delimited with backticks<code>(`)</code>.</li></ul><br><pre>let value = 100;<br>console.log(`The size is ${value}`);</pre>" 
            },
            {
                "name": "How could you check null and undefined in TypeScript?",
                "description": "<p>Just use: <br><pre>if(value){<br>}</pre><br>It will evaluate to <strong>true</strong> if <strong>value</strong> is not: <strong>null, undefined, NaN, empty string '', 0, false</strong></p>" 
            },
            {
                "name": "Nullish operator (??) ?",
                "description": "<p>The <strong>nullish coalescing operator (<code>??</code>)</strong> is a logical operator that returns its right-hand side operand when its left-hand side operand is <code>null</code> or <code>undefined</code>, and otherwise returns its left-hand side operand.Its main purpose is to simplify <em>assigning default values</em>. The <em>nullish coalescing</em> operator tests for <code>null</code> and <code>undefined</code> only.</p>" 
            },
            {
                "name": "What does the pipe, | mean in TypeScript? ",
                "description": "<ul><li>This is called <code>union</code> type in TypeScript. A <code>union</code> type describes a value that <em>can be one of several types</em>.</li><li><code>Pipe(|)</code> is used to <em>separate each type</em>. So, for example <code>number | string | boolean</code> is the type of a value that can be a <code>number</code>, a <code>string</code>, or a <code>boolean</code>.</li></ul>" 
            },
            {
                "name": "What is Optional Chaining in TypeScript?",
                "description": "<p>An <strong>optional chain</strong> is an optional expression followed by one or more subsequent regualr <em>property access, element access, or call argument lists</em>:</p>" 
            },
            {
                "name": "What is the difference between unknown and any type?",
                "description": "<ul><li><code>unknown</code> is the type-safe counterpart of <code>any</code></li><li>Anything is assignable to <code>unknown</code></li><li>But <code>unknown</code> isn't assignable to anything but itself and <code>any</code> without a type assertion or a control flow based narrowing</li><li>Likewise no operations are permitted on an <code>unknown</code> without first asserting or narrowing to a more specific type.</li></ul>" 
            },
            {
                "name": "Double Exclamation Operator (!!)",
                "description": "<p>In JavaScript, the double exclamation operator converts an <strong>Object</strong> to <strong>Boolean</strong>. This happens such that “falsy” objects become <strong>false</strong> and “truthy” objects become <strong>true</strong>.</p><ul><li><strong>!! 0</strong> –&gt; <strong>false</strong></li><li><strong>!! null</strong> –&gt; <strong>false</strong></li><li><strong>!! undefined</strong> –&gt; <strong>false</strong></li><li><strong>!! 48</strong> –&gt; <strong>true</strong></li><li><strong>!! “hello”</strong> –&gt; <strong>true</strong></li><li><strong>!! [1, 2, 3]</strong> –&gt; <strong>true</strong></li></ul><p>When you apply the not operator twice on a JavaScript object, here is what happens:</p><ul><li>The first <strong>not</strong> operator converts the object to an inverted boolean value.</li><li>The second <strong>not</strong> operator inverts the inverted boolean value. In other words, this makes it the real boolean value of the object. </li></ul>" 
            },
			{
                "name": "What are template expressions?",
                "description": "<p><code>{{ admin == true ? 'Admin Available' : 'Admin Not Available' }}</code><br><br>The content inside the double braces is called <strong>Template Expression</strong><br><br>The Angular first evaluates the Template Expression and converts it into a string. Then it replaces Template expression with the result in the original string in the HTML. Whenever the template expression changes, the Angular updates the original string again</p>"
            },
			{
                "name": "What are template statements?",
                "description": "<p>A template statement responds to an event raised by a binding target such as an element, component, or directive. The template statements appear in quotes to the right of the = symbol like (event)=\"statement\"</p>"
            },
            {
                "name": "How does an Angular application work?",
                "description": "<p>An Angular application is a <strong>Single Page Application</strong>, or SPA. This means that the entire application lives within a single page, and all of the resources (HTML, CSS, JavaScript, etc.) are loaded when the page is first loaded. Angular uses MVC, architecture pattern to manage its data and views. The <strong>Model</strong> is the data that the application uses, the <strong>View</strong> is what the user sees, and the <strong>Controller</strong> is responsible for managing communication between the <strong>Model</strong> and the <strong>View</strong>.<br><br>When a user interacts with an Angular application, the Angular framework will automatically update the <strong>View</strong> to reflect any changes in the data. This means that Angular applications are very responsive and fast, as the user does not need to wait for the page to reload in order to see updated data.<br><br>The following is is an example of configuration from an angular.json file:<br><img src='./assets/angular/angularJson.png'></p>"
            },
            {
                "name": "What is a bootstrapping module in angular? / runtime / polyfills / styles / vendor / main",
                "description": "<p>The process of loading the index.html page, app-level module, and app-level component is called bootstrapping, or loading the app.<br><br>Here are the steps involved to bootstrap the application: <ol><li>Loads Index.html</li><li>Loads Angular &amp; Third-party libraries &amp; Application</li><li>Executes application entry point (main.ts)</li><li>Load &amp; execute Root Module (app.module.ts)</li><li>Executes the Root Component (app.component.ts)</li><li>Displayes the template (app.component.html)</li></ol></p><ol><li><strong>Load index.html</strong> - The starting point of any Angular web application is the <strong>index.html</strong>. This page refers to all the necessary JavaScript files for the application.</li><li><strong>Load Angular, Other Libraries, and App Code</strong> - To run our application, we use the <code>Angular CLI</code> command <code>ng serve</code> or <code>npm start</code>. You can see that the compiler included five script files. They are <code>runtime</code>, <code>polyfills</code>, <code>styles</code>, <code>vendor</code>, &amp; <code>main</code>. All these files have two versions one is <code>es5</code> &amp; the other one <code>es2015</code><br><strong>#1. runtime.js:</strong> It contains the script that is responsible for the webpack to run<br><strong>#2. polyfills.js</strong> – It contains the scripts which is responsible for supporting the variety of the latest modern browsers<br><strong>#3. styles.js</strong> – This file contains the global style rules bundled as javascript file.<br><strong>#4. vendor.js</strong> – It contains the scripts from the Angular core library and any other 3rd party library. <br><strong>#5. main.js</strong> – It contains the code of the application.</li><li><strong>Execute main.js File</strong> - The code inside the <code>main.js</code> file is the entry point for the application. This file imports the module <code>platformBrowserDynamic</code> from the library <code>@angular/platform-browser-dynamic</code>. Here, <code>platformBrowserDynamic</code> is the module responsible for loading the Angular app in the desktop browser. Similar to this module, the module <code>platformNativeScriptDynamic</code> loads the app in a mobile device. Angular is flexible enough to run in a browser, server, web-worker, or mobile device. </li><li><strong>Load App/Root Module</strong> - The <code>root module</code> has one <code>root component</code>. This <code>root component</code> is loaded when the <code>root modules</code> are loaded by Angular. Apart from the root component, this module also has reference to all external modules imported using the <code>imports</code> array. Then comes <code>declarations</code> array that contains the list of components, directives, & pipes that belong to this Angular Module, The <code>providers</code> array, is where we register the services we create.<br><br> The <code>bootstrap</code> property or key of the <code>NgModule</code> decorator specifies which component should be loaded by Angular when the root module loads. Angular reads the bootstrap metadata and loads the app-level component, called <code>AppComponent</code></li><li><strong>Load App/Root Component</strong> - The TypeScript class of the app-level component, called <span><code>AppComponent</code></span>, is decorated with the <span><code>@Component</code></span> class decorator. The <span><code>@Component</code></span> class decorator provides the metadata about the class to Angular. It has the following three properties: <br> <code>#1. selector <br>#2. templateURL <br>#3. styleUrls.</code><br>If you are injecting a service into this component, then you will have a fourth property, as well, that references the service that will be injected into this class's constructor. The fourth property is called <span><code>providers</code></span>. It is an array of service classes that will be injected into this component.</li><li><strong>Process Template</strong> - The <span><code>templateURL</code></span> property points to the HTML template file, which will be rendered to the browser when this component is processed. The <span><code>selector</code></span> property specifies the CSS selector, where the template will be inserted into the HTML.<br><br>Once <code>platformBrowserDynamic</code> is done with all preparation, it is ready to instantiate the app-level component or root component. <code>platformBrowserDynamic</code> then just iterates through the bootstrap components array and asks <code>ApplicationRef</code> to actually bootstrap each component.</li></ol>"
            },
			{
                "name": "What is HttpClient and its benefits?",
                "description": "<p>Angular provides a simplified client HTTP API known as <strong>HttpClient</strong> which is based on top of XMLHttpRequest interface. This client is avaialble from <code>@angular/common/http</code> package.<br><br><code>import { HttpClientModule } from '@angular/common/http';</code><br><br>The major advantages of HttpClient can be listed as below,</p><ol><li>Contains testability features</li><li>Provides typed request and response objects</li><li>Intercept request and response</li><li>Supports Observalbe APIs</li><li>Supports streamlined error handling</li></ol><br><p>Below are the steps need to be followed for the usage of HttpClient. <br><strong>#1.</strong> Import HttpClient into root module<br><strong>#2.</strong> Inject the HttpClient into the application: Let's create a userProfileService(userprofile.service.ts) as an example. It also defines get method of HttpClient<br><strong>#3.</strong> Create a component for subscribing service: Let's create a component called UserProfileComponent(userprofile.component.ts) which inject UserProfileService and invokes the service method,</p>"
            },
            {
                "name": "How to consume / fetch an JSON REST api?",
                "description": "<p>We are required to import and setup HttpClient service in Angular project to consume REST APIs.<br><br>To work with HttpClient service in Angular, you need to import the <code>HttpClientModule</code> in <code>app.module.ts</code>from @angular/common/http package file. Then Within your Service file inject HttpClient service in constructor method after that you can hit the remote server via HTTP's POST, GET, PUT and DELETE methods. <br><img src='./assets/expertAngular/httpService1.png'><br><img src='./assets/expertAngular/httpService.png'></p>"
            },
            {
                "name": "Which service is used for hitting an api?",
                "description": "<p>inject HttpClient service in constructor method after that you can hit the remote server via HTTP's POST, GET, PUT and DELETE methods.</p>"
            },
            {
                "name": "Differentiate between get and post?",
                "description": "<p>Both <strong>GET</strong> and <strong>POST</strong> method is used to transfer data from client to server in HTTP protocol but Main difference between <strong>POST</strong> and <strong>GET</strong> method is that <strong>GET</strong> carries request parameter appended in URL string while <strong>POST</strong> carries request parameter in message body which makes it more secure way of transferring data from client to server.</p>"
            },
            {
                "name": "What is a header?",
                "description": "<p>Headers let the client and the server share additional information about the HTTP request or response. For example, we use the content-type header to indicate the media type of the resource like JSON, text, blob, etc. Another important header is where you send the bearer token using the Authorization header 'Authorization', 'Bearer <yourTokenhere>'</p>"
            },
            {
                "name": "Where do we put http params in the request ?",
                "description": "<p>In an HTTP <strong>GET</strong> request, parameters are sent as a query string: <br><code>http://example.com/page?parameter=value&also=another</code><br><br>In an HTTP <strong>POST</strong> request, the parameters are not sent along with the URI. This is placed in the request body after the HTTP headers.</p>"
            },
            {
                "name": "What are different type of response type available in angular?",
                "description": "<p>The return type varies based on the <strong>observe</strong> and <strong>responseType</strong> values that you pass to the call.<br><br>By default returns Observable of <strong>JSON response type</strong></p>"
            },
            {
                "name": "What is role of observe/HttpObserve in request ?",
                "description": "<p><code>HttpClient.get</code> method can use <strong>observe</strong> property to define whether we want complete <strong>response or body only or events only</strong>. We need to assign values for observe property such as <br><strong>observe : 'response/body/events'</strong><br><br><strong>#1. Observe body</strong> - which is default <br><strong>#2. Observe response</strong> - accessing complete response, including headers <br><strong>#3. Observe events</strong> - exposes events that capture progress of both the request and response. <br><br>If you are uploading a file with HttpClient's <code>post</code> method and want the progress report, sending reportProgress as true alone will do nothing, you also have to configure observe events.<br><img src='./assets/expertAngular/observe.png'></p>"
            },
            {
                "name": "How to request a typed response?",
                "description": "<p>To specify the response object type, first define an interface with the required properties by using a interface.<br><img src='./assets/expertAngular/typedrequest1.png'><br><br>Then, specify that interface as the HttpClient.get() call's type parameter in the service.<br><img src='./assets/expertAngular/typedrequest.png'></p>"
            },
            {
                "name": "How to make and consume a jsonp request?",
                "description": "<p>JSONP is a method of performing API requests which go around the issue of <code>CORS</code>. <br>We can only use JSONP with APIs that support JSONP.<br><br><strong>Steps to use</strong></p><ol><li>Import HttpClientModule and HttpClientJsonpModule into your module.</li><li>Inject HttpClient into your service.</li><li>Pass the callback key as the second argument for the <code>jsonp</code> method.</li></ol><p><strong>app.module.ts</strong><br><img src='./assets/expertAngular/jsonp.png'><br><br><strong>example.service.ts</strong><br><img src='./assets/expertAngular/jsonp1.png'></p>"
            },
            {
                "name": "How to request non json data ? like download a file.",
                "description": " <p>In the httpOptions we have to pass <code>\"responseType: 'text'\"</code> if we want to download a text file in case of pdf file it will be <code>\"responseType: 'blob'\"</code></p>"
            },
            {
                "name": "How can we apply caching in request?",
                "description": "<p><strong>Using HttpInterceptor in Angular</strong> - We’ll create our <code>HttpInterceptor</code> so that whenever we place a GET request, the request will pass through the interceptors in the chain. Our interceptor will check the request to determine whether it has been cached. If yes, it will return the cached response. If not, it will pass the request along to the remainder of the chain to eventually make an actual server request. The interceptor will watch for the response when it receives the response and cache it so that any other request will return the cached response.<br><img src='./assets/expertAngular/cacheflow.png'><br><br><strong>Implementation of Caching</strong> - First, we will create a service named \"<strong>HttpCacheService</strong>\" and then a HTTPInterceptor named \"<strong>CacheInterceptor</strong>\". <br><br><strong>User of Cache Service</strong><ol><li>Used to retrieve saved response of a particular URL.</li><li>For any new outgoing request, used to save the URL and its response.</li><li>Invalidate a particular URL response.</li><li>Invalidate the entire cache.</li></ol><br><img src='./assets/expertAngular/cacheservice.png'><br><br><strong>Use of Cache Interceptor</strong><br><img src='./assets/expertAngular/cacheinterceptor.png'></p>"
            },
            {
                "name": "How to apply debouncing in request?",
                "description": "<p><strong>3 Ways to Debounce HTTP Requests in Angular - Using RxJS, Using lodash/underscore debounce method, Using Custom Debounce decorators</strong><br><br><strong>#1. Using RxJS</strong> - We can use RxJS <code>debounce</code> operator to delay calls - debounce emits a value form the source Observable only after a particular life span determined by another Observable has passed without another source emission.<br><img src='./assets/expertAngular/debounceTime.png'><br><strong>Note</strong> - emits the `searchText` into the stream. This will cause the operators in its pipe function (defined in the ngOnInit method) to be run. `debounce` runs and then `map`. If the time interval of 1 sec in debounce hasn't elapsed, map will not be called, thereby saving the server from being called.<br><br><strong>#2. Using lodash/underscore debounce method</strong> - The lodash and underscore utility libraries export the debounce function that we can use to debounce methods/functions execution.<br><img src='./assets/expertAngular/lodash.png'><br><img src='./assets/expertAngular/underscore.png'><br><br><strong>#3. Using Custom Debounce decorators</strong> - <br><img src='./assets/expertAngular/debouncedecorator.png'><br><img src='./assets/expertAngular/debouncedecorator1.png'></p>"
            },
            {
                "name": "How to handle more than one api request / parallel api calls in angular",
                "description": "<p><strong>Call The APIs with RXJS CombineLatest</strong> - This operator doesn’t emit an initial value until each observable emits at least one value and it emits every time when any of the observables emits after they’ve emitted at least once.<br><br><strong>Call The APIs with RXJS forkJoin</strong> - This operator is best when you only care about the final emitted value of each which means it only emits once when all of the observables emits at least once or complete.<br><img src='./assets/expertAngular/forkJoin.png'></p>"
            },
            {
                "name": "How to read the full response from HttpClient?",
                "description": "Inorder to get full response, you should use observe option from HttpClient,<br><img src='./assets/expertAngular/observe1.png'>"
            },
            {
                "name": "How do you perform Error handling for HttpClient?",
                "description": "<p>If the request fails on the server or failed to reach the server due to network issues then HttpClient will return an error object instead of a successful reponse. In this case, you need to handle in the component by passing error object as a second callback to subscribe() method.<br><br><img src='./assets/angular/errorhandlinghttp.png'><br><br>It is always a good idea to give the user some meaningful feedback instead of displaying the raw error object returned from HttpClient.</p>"
            },
            {
                "name": "What are Http Interceptors?",
                "description": "<p>Http Interceptors are part of @angular/common/http, which inspect and transform HTTP requests from your application to the server and vice-versa on HTTP responses. These interceptors can perform a variety of implicit tasks, from authentication to logging.<br><br>The syntax of HttpInterceptor interface looks like as below,<br><code>interface HttpInterceptor { <br> intercept(req: HttpRequest<any>, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt;{ <br>return next.handle(req); } <br>}</code><br><br>You can use interceptors by declaring a service class that implements the intercept() method of the HttpInterceptor interface.<br><code>@Injectable() <br> export class MyInterceptor implements HttpInterceptor { <br> constructor() {} <br> intercept(req: HttpRequest<any>, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; { <br> return next.handle(req);<br>... <br> } <br> } <br></code><br><br>After that you can use it in your module,<br><img src='./assets/angular/import-httpinterceptors.png'></p>"
            },
            {
                "name": "10 ways / applications to use Http Interceptors in Angular",
                "description": "<p>It provides a way to intercept HTTP requests and responses to transform or handle them before passing them along.</p><ul><li><strong>Authentication</strong> -  This is one of the most common use cases for interceptors and for a good reason. There are several things connected to authentication we can do: #Add bearer token, #Refresh Token, #Redirect to the login page</li><li><strong>Caching</strong> - Since interceptors can handle requests by themselves, without forwarding to next.handle(), we can use it for caching requests. What we do is use the URL a the key in our cache that is just a key-value map. And if we find a response in the map, we can return an observable of that response, by-passing the next handler. This increases performance since you don't have to go all the way to the backend when you already have the response cached.</li><li><strong>Fake backend</strong> - A mock or fake backend can be used in development when you do not have a backend yet. We mock the response depending on the request. And then return an observable of HttpResponse.</li><li><strong>URL</strong> - Manipulating the URL. for example, want to change HTTP to HTTPS. It's as easy as cloning the request and replacing http:// with https:// at the same time. Then we send the cloned, HTTPS request to the next handler. <br><img src='./assets/angular/interceptorUrl.png'></li><li><strong>Loader</strong> - We could set a loader centrally in an interceptor so that we show a loader whenever there are active requests and while we are waiting for a response. <br><br>For this, we can use a loader service that has a show and a hide function. Before we handle the request, we call the show method and through finalize we can hide the loader when done. <br><img src='./assets/angular/interceptorLoader.png'></li><li><strong>Conversion</strong> - When the API returns a format we do not agree with, we can use an interceptor to format it the way we like it. This could be converting from XML to JSON or like in this example property names from PascalCase to camelCase. If the backend doesn't care about JSON/JS conventions we can use an interceptor to rename all the property names to camelCase. <br><img src='./assets/angular/interceptorConverting.png'></li><li><strong>Manipulating Headers</strong> - Some things are: Authentication/authorization, Caching behavior; for example, If-Modified-Since, XSRF protection <br><img src='./assets/angular/interceptorHeader.png'></li><li><strong>Notifications</strong> - Here we have many different cases where we could show messages. In my example, I show 'Object created' every time we get a 201 created status back from the server. <br><img src='./assets/angular/interceptorNotification.png'></li><li><strong>Errors</strong> - There are two use cases for errors that we can implement in the interceptor: First, we can retry the HTTP call. Secondly, we can check the status of the exception. And depending on the status, we can decide what we should do.</li><li><strong>Profiling</strong> - Because interceptors can process the request and response together, they can do things like time and log an entire HTTP operation. So we can capture the time of the request and the response and log the outcome with the elapsed time. <br><img src='./assets/angular/interceptorProfiling.png'></li></ul>"
            },
            {
                "name": "How to handle JWT Authentication token in angular?",
                "description": "<p>JSON Web Tokens (JWTs) provide one way to solve this issue. Your Angular app can talk to a backend that produces a token. The Angular app can then pass that token in an Authorization header to the backend to prove they’re <strong>authenticated</strong>. The backend should verify the JWT and grant access based on its validity.</p><ul><li><strong>Step 1</strong>: Creating Login page directly on the application. which will send post request for the api with username and password as arguments to a service. on the success method set the response of the token to your web storage such as local or session or cookies</li><li><strong>Step 2</strong>: Create a separate Authentication service. Which will have the logic build for the http post request with the username and password in the body to the api</li><li><strong>Step 3</strong>: Create a seperate Guard Service(CLI <code>ng generate guard guardName</code>). With the default method <code>canActivate()</code> build the logic to return <code>true</code> if the user is logged in as it can only return a boolean value</li><li><strong>Step 4</strong>: Create a token interceptor service(CLI <code>ng generate interceptor interceptorName</code>). With the default intercept method inject the set the token in the http headers, to the backend for validation with the key and value 'Authorization', 'bearer ' + tokenValue</li><li><strong>Step 5</strong>: Calling the HTTP_INTERCEPTORS within the provider of your root module with object configs such as <code>{<br> provide: HTTP_INTERCEPTORS,<br> useClass: TokenInterceptorService,<br> multi: true<br> }</code></li><li><strong>Step 6</strong>: Calling the auth guard service within the routing module and implement the canActivate object to the route path which want to be secured.<br><code>{ <br> path: 'dashboard', <br> canActivate: [AuthGuard], <br> component: DashboardComponent <br> }</code></li></ul>"
            },
            {
                "name": "How to manage token expire scenario by renew it using refresh token without impact of user experience?",
                "description": "<p><strong>Refresh Tokens</strong> are credentials used to obtain access tokens.  Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical scope.<br><br>When you initially receive the access token you are very much likely to get a refresh token<br>{<br>\"access_token\": \"AYjcyMzY3ZDhiNmJkNTY\",<br>\"refresh_token\": \"RjY2NjM5NzA2OWJjuE7c\",<br>\"token_type\": \"bearer\",<br>\"expires\": 3600<br>}<br><br>When the access token is about to get expired a POST request will be made to the service’s token endpoint.<br><br>When we are building the logic within our token interceptor for cloning/adding the authorization bearer token in the request headers then, at that time we have to add an additional logic for checking if the token is expired or not, then here based on the response with a status code 401 we can make another post request to the refreshToken api(along with the refresh_token value in the body of that post request) which will validate at the backend server for the refresh_token send in the body and that backend server will return a new response with the access token and most probably another refresh token as well which is optional, and this new access token is then again cloned with the authorization bearer and added back to the request header of the token interceptor. This way the cycle continues and the user has to avoid login again and again even after the access token expires.</p>"
            },
            {
                "name": "In provider array we use multi true what it does ?",
                "description": "<p>The multi is useful when you register multiple providers for the same token<br><br>So the thumb rule is if you are registering multiple providers for the same TOKEN then always use multi=true to avoid the first provider from not being injected. When it's injected, you can use it in the constructor of the class.<br><br><img src='./assets/expertAngular/multi.png'><br><br>In Simple Terms - When we use <strong>multi: true</strong> then it informs the Angular that the type of token/provider used is multi provider where multiple values can be provided for that single token in Dependency Injection. Therefore, when the dependency of this token is asked then it will provide us a list of all registered and provided values in the form of array.</p>"
            },
            {
                "name": "Explain Template driven and Reactive Forms in Angular ? Among them which is best and why?",
                "description": "<p><strong>Template driven</strong> - In Template Driven Forms we specify behaviors/validations using directives and attributes in our template and let it work behind the scenes. All things happen in Templates hence very little code is required in the component class. How to use Template driven forms.</p><ol><li>The form is set up&nbsp;using <code>ngForm</code> directive</li><li>controls are set up using the <code>ngModel</code> directive</li><li><code>ngModel</code> also provides the two-way data binding</li><li>The Validations are configured in the template via directives</li></ol><br><p><strong>Reactive Forms</strong> - Reactive forms are forms where we define the structure of the form in the component class. i.e. we create the form model with <code>Form Groups</code>, <code>Form Controls</code>, and <code>FormArrays</code>. We also define the validation rules in the component class. Then, we bind it to the HTML form in the template. This is different from the Template driven forms, where we define the logic and controls in the HTML template. <br>How to use Reactive Forms</p><ol><li>Import <code>ReactiveFormsModule</code></li><li>Create Form Model in component class using FormGroup, FormControl &amp; FormArrays</li><li>Create the HTML Form resembling the Form Model.</li><li>Bind the HTML Form to the Form Model</li></ol><br><p><strong>Reasons to use Reactive Forms</strong></p><ol><li><strong>Immutability</strong> - Reactive form keeps the data model pure by providing it as an immutable data structure. It uses an immutable approach to manage the state of a form.</li><li><strong>Predictability</strong> - Reactive form is predictable because it access synchronously to the data model. Reactive forms are built around observable streams to track changes in the form. And that predictability makes testing easy.</li><li><strong>Scalability</strong> - Due to the fact that reactive form is synchronous makes scaling easier. It is reusable and helps a lot with large-scale forms. Template driven form is not reusable because it provides asynchronous access to the form model and therefore the scalability is tough with it.</li></ol>"
            },
            {
                "name": "How does data flow differently in template forms and reactive forms?",
                "description": "<p><strong>Data flow in Reactive forms</strong> - In Reactive form, each form element in the view is directly linked to a form model (FormControl instance). Any updation from the view to the model and the model to the view are synchronous and are not dependent on the UI. <br><br><strong>Data flow from View to Model</strong><br><img src='./assets/expertAngular/dfReactiveForm.png'><br><br><ul><li>First, the user types a value into the input element. In this example, the input element is Favorite Color and the typed value is Blue.</li><li>Then, the form input element emits an \"input\" event with the latest typed value. </li><li>Then the control value accessor(who listen for events on the form input element) immediately relays the new value to the FormControl instance.</li><li>After receiving the value theFormControl instance emits the new value through the valueChanges observable.</li><li>Any subscribers to the valueChanges observable receive the new value.</li></ul><br><br><strong>Data flow from Model to View</strong><br><img src='./assets/expertAngular/dfReactiveForm1.png'></p><ul><li>First, the user calls the favoriteColorControl.setValue() method. This method updates the FormControl value.</li><li>Then, the FormControl instance emits the new value through the valueChanges observable.</li><li>Then, subscribers to the valueChanges observable receive the new value.</li><li>At last, the control value accessor on the form input element updates the element with the new value.</li></ul><br><br><br><br><strong>Data flow in Template driven forms</strong> - Every form element of the Template driven forms is linked to a directive to manage the form model internally.<br><br><strong>Data flow from View to Model:</strong><br><img src='./assets/expertAngular/dfTemplateForm.png'></p><ul><li>First, the user types Blue into the input element.</li><li>Then, the input element emits an \"input\" event having the value Blue.</li><li>Then, the control value accessor attached to the input triggers the setValue() method on the FormControl instance.</li><li>After the setValue() method, the FormControl instance emits the new value through the valueChanges observable.</li><li>Subscribers to the valueChanges observable receive the new value.</li><li>After that, the control value accessor also calls the NgModel.viewToModelUpdate() method which emits an ngModelChange event.</li><li>Here, component template <strong>uses two-way data binding</strong> for the favoriteColor property, the favoriteColor property in the component is updated to the value emitted by the ngModelChange event (Blue).</li></ul><br><br><strong>Data flow from Model to View:</strong><br><img src='./assets/expertAngular/dfTemplateForm1.png'><br><br><ul><li>First, the favoriteColor is updated to anew value in the component. </li><li>Change detection starts.</li><li>During change detection, the ngOnChanges lifecycle hook is called on the NgModel directive instance because the value of one of its inputs has changed.</li><li>The ngOnChanges() method queues an async task to set the value for the internal FormControl instance.</li><li>Change detection is complete now.</li><li>Then, the task to set the FormControl instance value is executed.</li><li>The FormControl instance emits the latest value through the valueChanges observable.</li><li>Any subscribers to the valueChanges observable receive the new value.</li><li>The control value accessor updates the form input element in the view with the latest favoriteColor value.</li></ul>"
            },
            {
                "name": "In Which form of approach data model is immutable?",
                "description": "<p>Reactive forms provide synchronous access to the data model, immutability with observable operators, and change tracking through observable streams.</p>"
            },
            {
                "name": "Differences between Template driven and Reactive Forms",
                "description": "<ol><li>Template driven forms make use of the \"FormsModule\", while reactive forms are based on \"ReactiveFormsModule\".</li><li>Template driven forms are asynchronous in nature, whereas Reactive forms are mostly synchronous.</li><li>In a Template driven approach, most of the logic is driven from the template, whereas in reactive driven approach, the logic resides mainly in the component or typescript code.</li></ol>"
            },
            {
                "name": "What are the different ways to group form controls?",
                "description": "<ol><li><strong>FormGroup</strong>: It defines a form with a fixed set of controls those can be managed together in an one object. It has same properties and methods similar to a FormControl instance. This FormGroup can be nested to create complex forms as below.</li><li><strong>FormArray:</strong> It defines a dynamic form in an array format, where you can add and remove controls at run time. This is useful for dynamic forms when you don’t know how many controls will be present within the group.</li></ol>"
            },
            {
                "name": "What is use of remove Control?",
                "description": "<p>The <code>removeControl</code> removes the control from the <code>FormGroup</code> at runtime by given control name.<br><br>Example <br><code>removeControl(name: string): void <br></code><br><br>The name is name of control to remove from FormGroup. Find the code to use it. <br><code>this.personForm.removeControl('nationality'); </code></p>"
            },
            {
                "name": "How do you update specific properties of a form model? (patch value / set value)",
                "description": "<p>You can use <code>patchValue()</code> method to update specific properties defined in the form model. For example,you can update the name and street of certain profile on click of the update button.<br><img src='./assets/angular/patchvalue.png'><br><img src='./assets/angular/patchvalue1.png'><br><br>You can also use <strong>setValue</strong> method to update properties. But with this method one has to update all the properties of the control and cant skip any one value</p>"
            },
            {
                "name": "What is the purpose of FormBuilder?",
                "description": "<p>FormBuilder is used as syntactic sugar for easily creating instances of a FormControl, FormGroup, or FormArray. This is helpful to reduce the amount of boilerplate needed to build complex reactive forms. It is available as an injectable helper class of the <code>@angular/forms</code> package.<br><img src='./assets/angular/formbuilder.png'></p>"
            },
            {
                "name": "What are the types of validator functions? (sync / async)",
                "description": "<p>In reactive forms, the validators can be either synchronous or asynchronous functions,</p><ol><li><strong>Sync validators:</strong> These are the synchronous functions which take a control instance and immediately return either a set of validation errors or null. Also, these functions passed as second argument while instantiating the form control. The main use cases are simple checks like whether a field is empty, whether it exceeds a maximum length etc.</li><li><strong>Async validators:</strong> These are the asynchronous functions which take a control instance and return a Promise or Observable that later emits a set of validation errors or null. Also, these functions passed as second argument while instantiating the form control. The main use cases are complex validations like hitting a server to check the availability of a username or email.</li></ol><br><br><img src='./assets/angular/validatortype.png'><br>"
            },
            {
                "name": "How to put custom validation in template driven forms?",
                "description": "<p><strong>Validator Interface</strong> - Building a Validator in Template driven forms is similar to building an Angular directive. The directive must implement the Validator interface <br><img src='./assets/expertAngular/validatorInterface.png'><br><br>The directive must implement the <code>validate</code> function. Notice that the <code>validate</code> function has the same signature as the ValidatorFn Interface. Whenever the <code>Validator</code> directive is invoked angular looks for the <code>validate</code> method and invokes it.<br><br><strong>Validate Function</strong><br><br>A <code>Validator</code> is just a function, which must implement ValidatorFn Interface.<br><img src='./assets/expertAngular/validatorInterfaceFn.png'><br><br>The function takes the <strong>AbstractControl</strong>. This is the base class for <strong>FormControl, FormGroup, and FormArray</strong>. The validator function must return a list of errors i.e <strong>ValidationErrors</strong> or <strong>null</strong> if the validation has passed</p>"
            },
            {
                "name": "How to put custom validation in reactive forms ?",
                "description": "<p><strong>Create the validation service</strong> By using the validatorFn and AbstractControl Class of the angular forms module <br><img src='./assets/expertAngular/customValidatorService.png'><br><img src='./assets/expertAngular/customValidatorService1.png'><br><img src='./assets/expertAngular/customValidatorService2.png'><br><br>Then Create reactive form template which will import the custom validation service and bind the validator functions with the formControlName <br><img src='./assets/expertAngular/customValidatorService3.png'></p>"
            },
            {
                "name": "What is cross field validation / validation for confirm password?",
                "description": "<p>It is validating one form control based on the value of another<br><br>First of all, I will create and export an arrow function that accepts a <code>FormGroup</code> parameter and returns a <code>ValidatorFn</code>. <br>With this parameter we are now able to validate more than one controls and, of course, compare their values. <br><img src='./assets/expertAngular/passwordMatch.png'><br><br>The function takes a <code>FormGroup</code> parameter and returns: <br>#1. a {[key]: [value]} expression, if an error exists <br>#2 null if it's valid<br><br><strong>Apply errors to each control</strong> - If we want to show the error to the two fields, we also need to apply it to both form controls. <br><img src='./assets/expertAngular/passwordMatch1.png'><br><br><strong>Using the custom Validator</strong> - Our validator is ready for use! The only thing left is to call it in our form like follows:<br><img src='./assets/expertAngular/passwordMatch2.png'></p>"
            },
            {
                "name": "Implement async validator for template driven form?",
                "description": "<p>Creating a Async Validator requires some basic rules to be followed</p><ol><li>The function must implement the&nbsp;<code>AsyncValidatorFn</code>&nbsp;Interface, which defines the signature of the validator function.</li><li>The function must return either an <code>observable</code>or a <code>promise</code></li><li>Return&nbsp;<code>null</code>&nbsp;for valid, or an&nbsp;<code>ValidationErrors</code>&nbsp;if the input is invalid</li></ol>"
            },
            {
                "name": "Difference between pristine, dirty and touched ?",
                "description": "<p><strong>pristine:</strong> The pristine class tells that the form has not been modified by the user. This returns true if the form has not been modified by the user. <strong>Return Boolean True</strong> if the form/input field is not modified by the user else it returns False. <br><br><strong>dirty:</strong> The dirty class tells that the form has been made dirty (modified ) by the user. It returns true if the user has modified the form. <strong>Return Boolean True</strong> if the form/input field is modified by the user else it returns False. <br><br><strong>touched:</strong> A controls is said to be touched if the the user focused on the control and then focused on something else. For example by clicking into the control and then pressing tab or clicking on another control in the form. <strong>Return Boolean True</strong> if the input field has been touched by the user, otherwise it's false.<br><br><br>The difference between touched and dirty is that with touched the user doesn't need to actually change the value of the input control.</p>"
            },
            {
                "name": "How do you optimize the performance of async validators?",
                "description": "<p>Since all validators run after every form value change, it creates a major impact on performance with async validators by hitting the external API on each keystroke. This situation can be avoided by delaying the form validity by changing the updateOn property from change (default) to submit or blur. The usage would be different based on form types,</p><ol><li><strong>Template driven forms:</strong> Set the property on <code>ngModelOptions</code> directive <br><img src='./assets/angular/updateon.png'></li><li><strong>Reactive-forms:</strong> Set the property on FormControl instance<br><img src='./assets/angular/updateon1.png'></li></ol>"
            },
            {
                "name": "What is RxJS",
                "description": "<p>The <strong>RxJS</strong> (Reactive Extensions Library for JavaScript) is a javascript library, that allows us to work with asynchronous data streams<br><br>The Angular uses the RxJS library heavily in its framework to implement Reactive Programming. Some of the examples where reactive programming used are</p><ul><li>Reacting to an <code>HTTP request in Angular</code></li><li><code>Value changes</code> / <code>Status Changes</code> in Angular Reactive Forms</li><li>The Router and Forms modules use observables to listen for and respond to user-input events.</li><li>You can define custom events that send observable output data from a child to a parent component.</li><li>The HTTP module uses observables to handle AJAX requests and responses.</li></ul><p>The RxJs has two main players <br>#1. Observable <br>#2. Observers ( Subscribers)</p>"
            },
            {
                "name": "What are Promises?",
                "description": "<p><strong>Promise </strong>is an object that may produce a single value some time in the future, either a resolved value or a reason that it’s not resolved(e.g. may be due to a network error) or in a pending state.<br><br>A Promise in programming produces either result which can be:</p><ol><li><strong>Fulfilled</strong>, which means you get a <em>result value.</em></li><li><strong>Rejected</strong>, which means the result you get is an <em>error</em>.</li><li><strong>Pending</strong>, which means that it works but the result is <em>undefined</em>.</li></ol>"
            },
            {
                "name": "What are observables?",
                "description": "<p>Observables belongs to RxJS library, to perform asynchronous programming in Angular application we can use either Observable or Promise. When we send and receive data over HTTP, we need to deal it asynchronously because fetching data over HTTP may take time. Observable is subscribed by using async pipe or by using subscribe method<br><br>Some methods of Observable class are subscribe, map, mergeMap, switchMap, exhaustMap, debounceTime, of, retry, catch, throw etc<br><br><strong>To understand observable in simple words</strong> - Observables are declarative statement — that is, you define a function for publishing values, but it is not executed until a consumer subscribes to it. The subscribed consumer then receives notifications(using async pipe or subscribe method) until the function completes, or until they unsubscribe. <br><br>Example. consider observables as newsletters and a subscriber. For each subscriber a new newsletter is created. They are then only send to those subscribed people who have subscibed to that newletter, and not to anyone else on the network.</p>"
            },
            {
                "name": "How to create observable?",
                "description": "<p>First of all, we need to import Observable from rxjs.<br><br>Then, we create an Observable by calling the new Observable constructor that takes one argument. In the following example, we create an Observable that emits a number every second to a subscriber.<br><img src='./assets/expertAngular/observable.png'><br><br>As it is, nothing will happen because we need to subscribe to an Observable to consume its values.<br><br><strong>Subscribing to the Observable</strong> - Remember that an Observable delivers three types of notifications to the Observer:</p><ul><li><strong>next</strong>: sends data (i.e. Numbers, Strings, Objects, etc.)</li><li><strong>error</strong>: sends a JavaScript Error or exception. Nothing else will be delivered afterwards.</li><li><strong>complete</strong>: does not send a value. Nothing else will be delivered afterwards. We will start by subscribing to the Observable.</li></ul><p>Every time we call observable.subscribe, the call triggers an execution that is independent and unique to that given subscriber.<br><img src='./assets/expertAngular/observablesubscribe.png'></p>"
            },
            {
                "name": "What are observable creation functions?",
                "description": "<p> RxJS provides creation functions for the process of creating observables from things such as promises, events, timers and Ajax requests. Let us explain each of them with an example,</p><br><img src='./assets/angular/observablecreation.png'><br><img src='./assets/angular/observablecreation1.png'>"
            },
            {
                "name": "What is subscribing / Observer?",
                "description": "<p>An Observable instance begins publishing values only when someone subscribes to it. So you need to subscribe it by calling the <strong>subscribe()</strong> method of the instance, passing an observer object to receive the notifications.<br><br><strong>If you do not supply handler for observer</strong> - Normally an observer object can define any combination of next, error and complete notification type handlers. If you don't supply a handler for a notification type, <strong>the observer just ignores notifications of that type.</strong><br><br>Let's take an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console.<br><br><img src='./assets/angular/subscribing.png'></p>"
            },
            {
                "name": "What is next, error and complete?",
                "description": "<p>An observable can send three types of notifications: <code>Next</code>, <code>Error</code>, <code>Complete</code>.</p><ul><li><code>Next</code> notification sends a value such as a <em>Number</em>, a <em>String</em>, an <em>Object</em>, etc.</li><li><code>Error</code> notification sends a JavaScript Error or exception. Nothing else will be delivered afterwards.</li><li><code>Complete</code> notification does not send a value. Nothing else will be delivered afterwards. We will start by subscribing to the Observable.</li></ul>"
            },
            {
                "name": "What is multicasting?",
                "description": "<p>Multi-casting is the practice of broadcasting to a list of multiple subscribers in a single execution.<br><br><img src='./assets/angular/multicasting.png'></p>"
            },
            {
                "name": "How do you perform error handling in observables?",
                "description": "<p>You can handle errors by specifying an error callback on the observer instead of relying on try/catch which are ineffective in asynchronous environment.<br><br><img src='./assets/angular/errorhandling.png'></p>"
            },
            {
                "name": "Difference between Promise and Observables?",
                "description": "<ul><li><strong>Eager vs Lazy</strong><br><strong>#1. Promise:</strong> It is eager — It starts executing immediately once it is defined, It doesn’t matter whether we are calling the then()/catch() method. <br><strong>#2. Observable:</strong> It is lazy — It won't start executing until we subscribe to it.</li><li><strong>Async vs Sync</strong><br><strong>#1. Promise:</strong> It is always Async, Once the value is resolved/rejected, the respective callback function will go to the micro task queue and gets executed once the call stack is empty. <br><strong>#2. Observable:</strong> It can be either Sync or Async — If we are emitting a value synchronously, then it will behave synchronously and if we are emitting the value asynchronously it will behave asynchronously.</li><li><strong>Single value vs Multiple values</strong><br><strong>#1. Promise:</strong> It can return only one value, it can either resolve one value or reject one value, once resolved/rejected, that’s the end, we can't return anything. <br><strong>#2. Observable:</strong> It can emit multiple streams of values, once the observable is subscribed, a stream will be open and all the emitted values will be captured and the stream gets close once unsubscribed</li><li><strong>Cancellable vs Non-Cancellable</strong> <br><strong>#1.</strong> Since promises are eager and return only one value, they will be executed immediately once it is defined, so there is no way to cancel them once it is defined. <br><strong>#2.</strong> But Observable can be canceled (stream will be closed) by unsubscribing to it.</li><li><strong>Unicast vs Multicast</strong><br><strong>#1. Promises:</strong> are unicast, which means promises will be executed only once, even if we call then() multiple times. <br><strong>#2 Observables:</strong> are multicast, which means every time we subscribe to the observable, it will be executed again and again ( observables can be multicasted to multiple subscriptions ).</li></ul><br><img src='./assets/angular/promise-observables.png'>"
            },
            {
                "name": "What is Hot and Cold observable?",
                "description": "<p>When the data is produced by the Observable itself, we call it a cold Observable. For example, observables created using the <code>of, from, range, interval and timer</code> operators will be cold. The data is created from within the observable itself, and there truly is not data being produced until the observable is subscribed to.<br><br> When the data is produced outside the Observable, we call it a hot Observable. For example, observables created with the <code>fromEvent</code> operator for either user events (clicks, mouse moves,…) or WebSocket events are hot observables. The data is being produced regardless of if there's a subscriber or not. If there's no subscriber when the data is being produced, the data is simply lost.</p>"
            },
            {
                "name": "What is share operator?",
                "description": "<p>The share operator is known as a multicast operator. Share also manages the underlining subscriptions and disconnects when all the subscribers stop listening. It then restart the stream if a new subscriber subscribes again.</p>"
            },
            {
                "name": "Debouncing in Angular?",
                "description": "<p>Debouncing in JavaScript is a practice used to improve browser performance. It is used to ensure that time-consuming tasks do not fire so often, that it stalls the performance of the web page. In other words, it limits the rate at which a function gets invoked.<br>Example on click event when pressed continously. it may hang the processing of the function logic or subscription of the data over the api. So to avoid this add debounce so that the next request is only triggered when the debounced interval is reached and then subscribe the data</p>"
            },
            {
                "name": "Difference between of and from?",
                "description": "<p><em><strong>of</strong></em> will emit all values at once<br><br><em><strong>from</strong></em> will emit all values one by one<br><br><em><strong>of</strong></em> with <em><strong>spread</strong></em> operator = <em><strong>from</strong></em> operator<br><img src='./assets/expertAngular/offrom.png'><br><br>Based on Simple observation you can realize that in case of <strong>from</strong> it actually processes the input that you have passed to this function, where as in case of <strong>off</strong> there is no such processing it will just return the value as it is. Like wise in case of <strong>from</strong> if you pass a promise it will wait for that promise to completed and only then it will return the value of it and here the <strong>off</strong> operator will not do that.</p>"
            },
            {
                "name": "Observable operators",
                "description": "<p><strong>pipe:</strong> RxJS pipe is used to combine functional operators into a chain. pipe is an instance method of Observable as well as a standalone RxJS function. pipe can be used as Observable.pipe or we can use standalone pipe to combine functional operators.<br><br><strong>tap:</strong> It is used for side effects inside a stream. So this operator can be used to do something inside a stream and returning the same observable as it was used on. tap is the pipeable operator and it is the changed name of the RxJS do operator.<br><br><strong>map:</strong> The map is a pipeable operator. It is used to to transform the each value emitted by the source observable. simply it creates new observable after manipulating the each items of source observable..<br><br><strong>switchMap:</strong> RxJS switchMap emits Observable after applying the given function to each item emitted by source Observable. The Observable emitted by given function that is also called inner Observable, is returned by switchMap operator. switchMap starts emitting items emitted by inner Observable. When a new inner Observable is emitted, the switchMap stops emitting items from previous inner Observable and starts emitting items from latest inner Observable. It continues to do in the same way for all subsequent inner Observable. switchMap is a RxJS pipeable operator and it is used within pipe function of Observable<br><br><strong>mergeMap:</strong> Merge map operator is often get used when the requirement is to merge response from two observables. This rxjs operator return an observable after merging the response from two observables, things to notice here is that second observable does not execute until merged observable emits some response.<br><strong>Example</strong>Suppose source Observable is emitting 3 elements consecutively to mergeMap and every element is processed by an inner Observable inside mergeMap. Now suppose all the three elements from source Observable has entered into mergeMap before inner Observable for first element is not completed. Then mergeMap will wait to complete the inner Observable for all the three elements and then their Observable responses will be merged into one Observable response and returned it by mergeMap as output.<br><br><strong>filter:</strong> RxJS filter filters values emitted by source Observable. We need to pass a predicate to filter as an argument and if predicate returns true, only when filter will emit value. The values of source Observable for which predicate returns false , will not be emitted by filter. Angular 6 integrates RxJS 6 which has been shipped with pipeable operators that is used independent of Observable. RxJS pipeable operators are used independent of Observable within the pipe method of Observable.<br><br><strong>debounceTime:</strong> debounceTime is a RxJS operator that emits latest value from the source Observable after a given time span has passed without another source emission. It behaves same as RxJS delay but emits only the latest value. debounceTime delays the values emitted by source Observable for the given due time and within this time if a new value arrives, the previous pending value is dropped. In this way debounceTime keeps track of most recent value and emits that most recent value when the given due time is passed.<br><br><strong>retry:</strong> retry operator returns source Observable with the exception of an error. When source Observable calls error then retry operator resubscribe it for the maximum of given number of time. If Observable starts emitting elements and suppose at any point it calls error before completion, then retry operator will resubscribe the source Observable and starts emitting from start again. Suppose we have used retry(3) in our code, it means for any error in source Observable, it will be resubscribed up to 3 times. If in first attempt of resubscribe by retry(3), it completes normally then no other attempt to resubscribe will be made.<br><br><strong>forkJoin</strong> - This operator is best when you have such scenarios where you want to get the only last value while having group of observable execution. This is not a best choice to used for multiple API calls because there if we have error in any of the API’s then if the error is not handle properly it might get you in trouble so it is not considered as a best approach,<br><br><strong>combineLatest</strong> - operator is used to execute multiple observable at once , it only emits the latest value from each source observable. To run combinelatest operator we must have value in observable and combinelatest operator will not execute until each of source observable emits at least one value.<br><img src='./assets/expertAngular/combinelatest.png'><br><img src='./assets/expertAngular/combinelatest1.png'><br><br><strong>map & pluck</strong> - Map and Pluck are most used and very useful operators. Map operator in RxJS works similar to JS map. Pluck is used when we just need to pass single field value to the subscription instead of sending entire JSON object.<br><img src='./assets/expertAngular/mappluck.png'><br><br><strong>zip</strong> - Zip operator will wait for all observable to emit and then it zips those values into an array as an output.<br><img src='./assets/expertAngular/zip.png'><br><img src='./assets/expertAngular/zip1.png'><br><br><strong>bufferTime</strong> - It is used to buffer the emitted data of the originating Observable for a specific time period and collects values from the past as an array, and emits those arrays periodically in time.</p>"
            },
            {
                "name": "What are the utility functions / method provided by RxJS?",
                "description": "<p>The utility functions provided by Angular are:</p><ul><li><strong>map()</strong> : Used to map values of different data types</li><li><strong>filter()</strong> : Used for filtering streams</li><li><strong>concat()</strong> : Used to concatenate multiple strings</li><li><strong>merge()</strong>: Used to recursively descend into object properties in the source copy, while forming a deep copy of the same.</li></ul>"
            },
            {
                "name": "What is Subject?",
                "description": "<p>A Subject is a special type of Observable that allows values to be multicasted to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners. Every Subject behaves like an observer and observable. You can subscribe to a Subject, and you can call next() method to feed values as well as error() and complete() methods.<br><br><img src='./assets/angular/subject.png'></p>"
            },
            {
                "name": "What is BehaviorSubject",
                "description": "<p>BehaviorSubject is a variant of a Subject which has a current value that it stores and emits to all new subscriptions. This current value is either the item which is most recently emitted by the source observable or a default value if none has yet been emitted.</p>"
            },
            {
                "name": "Difference between Subject and BehaviorSubject?",
                "description": "<p>Both <strong>Subject</strong> and <strong>BehaviorSubject</strong> are Observables. but with few key differences relating to eachother such as  <br><br><strong>Values they hold</strong>: If you subscribe to a <strong>Subject</strong>, we wont get <strong>current value or initial value</strong>. But when you subscirbe to a <strong>BehaviorSubject</strong>, you will get the <strong>current value or initial value</strong>. <br><br><br><strong>Initial Value</strong>: For <strong>Subject</strong>, we don't need to initial a value. But whenever we declare <strong>BehaviorSubject</strong> we need to initialize a default value.<br><br><br><strong>Subscribers</strong>: In <strong>Subject</strong>, the subscribers will only receive the upcoming value. Where as In <strong>BehaviorSubject</strong>, the subscribers will receive the previous value and also upcoming value.</p>"
            },
            {
                "name": "Difference between BehaviorSubject and ReplaySubject?",
                "description": "<p><strong>BehaviorSubject: </strong>A variant of Subject that requires an initial value and emits its current value whenever it is subscribed to. <br><br><strong>ReplaySubject: </strong>A variant of Subject that “replays” or emits old values to new subscribers. It buffers a set number of values and will emit those values immediately to any new subscribers in addition to emitting new values to existing subscribers. <br><br><br><strong>Conclusion:</strong> If you want to provide an initial value at subscription time, even if nothing has been pushed to a Subject so far, use the BehaviorSubject. If you want to have the last value replayed to an observer, even if a Subject is already closed, use the ReplaySubject(1).</p>"
            },
            {
                "name": "Difference between BehaviorSubject vs Observable?",
                "description": "<p><strong>Observable</strong> is a Generic class a function that creates an observer and attaches it to the source where values are expected from, and <strong>BehaviorSubject</strong> is technically a sub-type of <strong>Observable</strong> and a variant of a Subject which has a current value that it stores and emits to all new subscriptions. This current value is either the item which is most recently emitted by the source observable or a default value if none has yet been emitted.</p>"
            },
            {
                "name": "What are custom elements?",
                "description": "<p>Custom elements (or Web Components) are a Web Platform feature which extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code. The browser maintains a CustomElementRegistry of defined custom elements, which maps an instantiable JavaScript class to an HTML tag. Currently this feature is supported by Chrome, Firefox, Opera, and Safari, and available in other browsers through polyfills.</p>"
            },
            {
                "name": "Explain how custom elements works internally?",
                "description": "<ul><li><strong>App registers custom element with browser:</strong> Use the <code>createCustomElement()</code> function to convert a component into a class that can be registered with the browser as a custom element.</li><li><strong>App adds custom element to DOM:</strong>  Add custom element just like a built-in HTML element directly into the DOM.</li><li><strong>Browser instantiate component based class:</strong> Browser creates an instance of the registered class and adds it to the DOM.</li><li><strong>Instance provides content with data binding and change detection:</strong> The content with in template is rendered using the component and DOM data. The flow chart of the custom elements functionality would be as follows <br><img src='./assets/angular/customElementFlow.png'></li></ul>"
            },
            {
                "name": "What are the mapping rules between Angular component and custom element?",
                "description": "<p>The Component properties and logic maps directly into HTML attributes and the browser's event system. Let us describe them in two steps,</p><ol><li>The <code><strong>createCustomElement()</strong></code> API parses the component input properties with corresponding attributes for the custom element. For example, component <code><strong>@Input('myInputProp')</strong></code> converted as custom element attribute <code><strong>my-input-prop</strong></code>.</li><li>The Component outputs are dispatched as HTML Custom Events, with the name of the custom event matching the output name. For example, component <code><strong>@Output() valueChanged = new EventEmitter()</strong></code> converted as custom element with dispatch event as 'valueChanged'.</li></ol>"
            },
            {
                "name": "Define typings for custom elements?",
                "description": "<p>You can use the <code>NgElement</code> and <code>WithProperties</code> types exported from @angular/elements.<br><br><pre>const container = document.createElement('my-container') as NgElement & WithProperties<{message: string}> <br>container.message = 'Welcome to Angular elements!'; <br>container.message = true;  // <-- ERROR: TypeScript knows this should be a string. <br>container.greet = 'News';  // <-- ERROR: TypeScript knows there is no `greet` property on `container`.</pre></p>"
            },
            {
                "name": "What is basehref tag ? where we need to put it?",
                "description": "<p>Base Href is used to set a base path for all your requests made relatively. <br><br>During navigation, the base href tag is used by the Angular router as a base path to the component, template, and module files.<br><br>It is passed in the head section of the index.html file of your angular application</p>"
            },
            {
                "name": "Angular Router/Routing?",
                "description": "<p><strong>THE ROUTER-OUTLET</strong> works as a placeholder which is used to load the different components based on the activated component or current route state. Navigation can be done using router-outlet directive and the activated component will take place inside the router-outlet to load its content. Here only the part marked by the router outlet will be changed between the views.<br><br><strong>ROUTES AND PATHS</strong>: Routes are definitions (objects) comprised from at least a path and a component (or a redirectTo path) attributes. The path refers to the part of the URL that determines a unique view that should be displayed, and component refers to the Angular component that needs to be associated with a path.<br> Each Route maps a URL path to a component.<br>The path can be empty which denotes the default path of an application and it's usually the start of the application.<br>The path can take a wildcard string (). The router will select this route if the requested URL doesn't match any paths for the defined routes. This can be used for displaying a “Not Found” view or redirecting to a specific view if no match is found.<br><br><strong>ROUTE PARAMS</strong>: Angular Router allows you to access parameters in different ways: #Using the ActivatedRoute service and #Using the ParamMap observable. You can create a route parameter using the colon syntax Ex. <code>{ path:  'contacts/:id', component:  ContactDetailComponent}</code><br><br><strong>ROUTE GUARDS</strong>: A route guard is a feature of the Angular Router that allows developers to run some logic when a route is requested, and based on that logic, it allows or denies the user access to the route. It's commonly used to check if a user is logged in and has the authorization before he can access a page. <b>You can add a route guard by implementing the CanActivate interface available from the @angular/router package and extends the canActivate() method which holds the logic to allow or deny access to the route.</b> Ex. <code>{ path:  'contacts/:id, canActivate:[MyGuard], component:  ContactDetailComponent}</code><br><br><strong>ROUTER LINKS / NAVIGATION DIRECTIVE</strong>: The RouterLink is a directive on the anchor tags give the router control over those elements. Since the navigation paths are fixed, you can assign string values to router-link directive. Ex. <code>&lt;a routerLink='/contacts'&gt;Contacts&lt;/a&gt;</code><br><br><strong>ACTIVE ROUTER LINKS</strong> - RouterLinkActive is a directive that toggles css classes for active RouterLink bindings based on the current RouterState. i.e, The Router will add CSS classes when this link is active and remove when the link is inactive. Ex. <code>&lt;a routerLink='/contacts routerLinkActive='active' '&gt;Contacts&lt;/a&gt;</code></p><br><img src='./assets/angular/defineroutes.png'><br><br>"
            },
            {
                "name": "What is Router/Routing Guard in Angular? protect a component",
                "description": "<p><strong>ROUTE GUARDS</strong>: A route guard is a feature of the Angular Router that allows developers to run some logic when a route is requested, and based on that logic, it allows or denies the user access to the route. It's commonly used to check if a user is logged in and has the authorization before he can access a page. <b>You can add a route guard by implementing the CanActivate interface available from the @angular/router package and extends the canActivate() method which holds the logic to allow or deny access to the route.</b> Ex. <code>{ path:  'contacts/:id, canActivate:[MyGuard], component:  ContactDetailComponent}</p><br><br><p><strong>To protect a component being activated through the router?</strong></p><ul><li>Create a guard service: <code>ng g guard auth</code></li><li>Create <code>canActivate()</code> or <code>canActivateChild()</code> methods</li><li>Use the guard when defining routes</li></ul><p><img src='./assets/angular/authguard.png' /></p>"
            },
            {
                "name": "Route Guard Types",
                "description": "<p>Guards are processed in the following order:</p><ul><li>canDeactivate</li><li>canLoad</li><li>canActivateChild</li><li>canActivate</li><li>resolve</li></ul><br><p><strong>CanActivate</strong> - decides, if a route can be activated ( or component gets rendered). We use this guard, when we want to check on some condition, before activating the component or showing it to the user. This allows us to cancel the navigation. <br>Use cases for the CanActivate Guard <ul><li>Checking if a user has logged in</li><li>Checking if a user has permission</li></ul></p><br><p><strong>CanDeactivate</strong> - is called, whenever we navigate away from the route before the current component gets deactivated. The best use case for <code>CanDectivate</code> guard is the data entry component. The user may have filled the data entry and tries to leave that component without saving his work. The <code>CanDeactivate</code> guard gives us a chance to warn the user that he has not saved his work and give him a chance to cancel the navigation.</p><br><p><strong>Resolve</strong> - This guard delays the activation of the route until some tasks or processes are complete. You can use this guard to pre-fetch the data from the backend API, before activating the route. The best use case for <code>Resolve</code> guard is the whenever a component is called and that component needs to show a HTTP response, then due to the request and response time delay the component looks blank, so to avoid this blank screen user can use the resolve service to load the data first and then show it directly on the component instead of blank page or a loader.</p><br><p><strong>CanLoad</strong> - Guard prevents the loading of the Lazy Loaded Module. We generally use this guard when we do not want to unauthorized user to navigate to any of the routes of the module and also stop them even to see the source code of the module. <br>The Angular provides <strong>canActivate</strong> Guard, which prevents unauthorized user from accessing the route. But there is a drawback associated with this guard that it does not stop the module from being downloaded. The user can still use the chrome developer console to see the source code. The <strong>CanLoad</strong> Guard prevents the module from being downloaded.</p><br><p><strong>CanActivateChild</strong> - guard runs before we navigate to a child route. The <code>CanActivatechild</code> guard is very similar to <code>CanActivateGuard</code>. We apply this guard to the parent route. The Angular invokes this guard whenever the user tris to navigate to any of its child route. This allows us check some condition and decide whether to proceed with the navigation or cancel it.</p>"
            },
            {
                "name": "What is canResolve router guard?",
                "description": "<p><strong>Building a Resolver</strong> - First, we need to create a Angular Service, which implements the <code>Resolve</code> Interface <br>The service must implement the <code>resolve</code> method. A resolve method must return either a <code>Observable<any></code>, <code>Promise<any></code> or just data.<br><br>Inside the <code>Resolve</code> method, we will get the access to the <code>ActivatedRouteSnapshot</code> & <code>RouterStateSnapshot</code>, which can be used to get the values of router parameter, query parameters etc. <br><img src='./assets/expertAngular/resolveSerice.png'></p><br><p>Once the resolver is created, we need to update the route definition and add resolve property <br><img src='./assets/expertAngular/resolveRoute.png'><br>Here, <code>products</code> is the key and <code>ProductListResolveService</code> is the resolver. The return value of the <code>ProductListResolveService</code> is assigned to the key i.e <code>products</code> and made available to the component via <strong>route data</strong><br><br>When the user navigates to the route <code>product</code>, the angular looks for the <code>resolve</code> property of the route. <strong>For each key value pair of resolvers</strong>, the angular calls the <code>resolve</code> method. If the return value of the resolver is a <code>observable</code> or a <code>promise</code>, the router will wait for that to complete. The returned value is assigned to the key <code>products</code> and added to the route data collection.<br><br>The component can just read the <strong>products</strong> from the route data from the <code>ActivatedRoute</code> within the component init cycle.<br><img src='./assets/expertAngular/resolveSnapshot.png'></p>"
            },
            {
                "name": "What is the difference between canLoad and canActivate?",
                "description": "<ul><li><strong>CanActivate</strong> - Decides if a route can be activated, this guard may not be the best way for feature modules that are lazy loaded, as this guard will always load the module in memory, even if the guard returned false which means user not authorized to access the route.</li><li><strong>CanLoad</strong> - Decides if a module can be loaded lazily, Controls if a route can even be loaded. This becomes useful for feature modules that are lazy loaded. They won’t even load if the guard returns false.</li></ul><p><strong>Conclusion:</strong> CanLoad Guard never load the module data if user is not authorized and that gives you more performance as the load time decreased almost 1 second and that is huge time in loading web pages, no doubt it depends on the module size.</p>"
            },
            {
                "name": "What is the router outlet and how to use it?",
                "description": "<p>Router-outlet in Angular works as a placeholder which is used to load the different components based on the activated component or current route state. Navigation can be done using router-outlet directive and the activated component will take place inside the router-outlet to load its content. Here only the part marked by the router outlet will be changed between the views.<br><br><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></p>"
            },
            {
                "name": "Activated route?",
                "description": "<p><strong>ActivatedRoute</strong> Contains the information about a route associated with a component loaded in an outlet. It can also be used to pass data from one component to another component using  router state tree, such as Id, flag, state etc<br><br>The ActivatedRoute will be injected as a router service to access the information<br><br><img src='./assets/angular/activatedroute.png' /><br><br><code>let pathId = this.activatedRoute.snapshot.params['id'];</code><br><br>Below are the properties of the activated route</p><ol><li>params: Observable</li><li>paramMap: Observable</li><li>queryParams: Observable</li><li>queryParamMap: Observable</li><li>fragment: Observable</li><li>snapshot: ActivatedRouteSnapshot</li><li>data: Observable</li><li>url: Observable</li><li>outlet: string</li><li>title: Observable</li><li>component: Type | null</li><li>root: ActivatedRoute</li><li>parent: ActivatedRoute | null</li><li>firstChild: ActivatedRoute | null</li><li>children: ActivatedRoute[]</li><li>pathFromRoot: ActivatedRoute[]</li></ol>"
            },
            {
                "name": "What is router state?",
                "description": "<p>The <strong>RouterState</strong> is an interface which represents the state of the router as a tree of activated routes.<br><br>You can access the current RouterState from anywhere in the Angular app using the <code>Router service</code> and the <code>routerState</code> property.<br><br><code>let pathId = this.activatedRoute.snapshot.params['id'];</code></p>"
            },
            {
                "name": "What does pathMatch signifies?",
                "description": "<p>The pathMatch strategy, consist of 'prefix' or 'full' value. Where in, Default is 'prefix'.<br><br>By default, the router checks URL elements from the left to see if the URL matches a given path, and stops when there is a match. For example, '/team/11/user' matches 'team/:id'.<br><br>The path-match strategy 'full' matches against the entire URL. It is important to do this when redirecting empty-path routes. Otherwise, because an empty path is a prefix of any URL, the router would apply the redirect even when navigating to the redirect destination, creating an endless loop.</p>"
            },
            {
                "name": "What are auxiliary routes?",
                "description": "<p>Angular supports the concept of auxiliary routes, which allow you to set up and navigate multiple independent routes in a single app. Auxiliary routes allow the user to access or toggle portions of the page, such as a side-bar or dialog, using the URL.<br><br>Each component has one primary route and zero or more auxiliary outlets. Auxiliary outlets must have unique name within a component.<br><br>To define the auxiliary route we must first add a named router outlet where contents for the auxiliary route are to be rendered. <br><img src='./assets/expertAngular/auxroute.png'></p>"
            },
            {
                "name": "What is the location strategy?",
                "description": "<p>The Location Strategy defines how our URL/Request is resolved. It also determines how your URL will look like<br><br>Angular implements both Hashstyle (i.e - uses the anchor tags technique) & HTML5 Routing. HashLocationstrategy implements the Hashstyle routing & Pathlocationstrategy implements the HTML5 style routing</p><br><p><strong>PathLocationStrategy</strong> - The <code>PathLocationStrategy</code> is the default strategy in the Angular application. <br>To Configure the strategy, we need to add <code>&lt;base href&gt;</code> in the <code>&lt;head&gt;</code> section of the root page (index.html) of our application. <br>The Browser uses this element to construct the relative URLs for static resources (images, CSS, scripts) contained in the document.<br><br><strong>Pros:</strong></p><ul><li>Produces a clear URL like http://example.com/foo</li><li>Supports Server-Side Rendering</li></ul><p>Cons:</p><ul><li>Older browser does not support</li><li>Server Support needed for this to work</li></ul><br><p><strong>HashLocationStrategy</strong> - You can use the HashLocationStrategy by providing the useHash: true in an object as the second argument of the RouterModule.forRoot in the AppModule.<br><br><strong>Pros:</strong></p><ul><li>Supported by all browsers</li></ul><p><strong>Cons:</strong></p><ul><li>Produces a URL like http://example.com/#foo</li><li>Will not Support Server-Side Rendering</li></ul><br><img src='./assets/expertAngular/routerHash.png'><br><p><strong>Which Location Strategy to Use</strong><br><br>We recommend you use the HTML 5 style (<code>PathLocationStrategy</code> ) as your location strategy. Because</p><ul><li>It produces clean and SEO Friendly URLs that are easier for users to understand and remember.</li><li>You can take advantage of the server-side rendering, which will make our application load faster, by rendering the pages in the server first before delivering them the client</li></ul>"
            },
            {
                "name": "What is a router event? name the any of ?",
                "description": "<p>The Angular Router raises events when it navigates from one route to another route. It raises several events such as <code>NavigationStart</code>, <code>NavigationEnd</code>, <code>NavigationCancel</code>, <code>NavigationError</code>, <code>ResolveStart</code>, etc. You can listen to these events and find out when the state of the route changes. Some of the useful events are route change start ( <code>NavigationStart</code> ) and route change end ( <code>NavigationEnd</code>). In this tutorial, we learn what is router events are and how to listen to them using Example code.</p><table><thead><tr><th>Router Event</th><th>The Event triggered when</th></tr></thead><tbody><tr><td>NavigationStart</td><td>the Angular router stats the navigation.</td></tr><tr><td>RouteConfigLoadStart</td><td>the Router lazy loads a route configuration.</td></tr><tr><td>RouteConfigLoadEnd</td><td>after a route has been lazy-loaded.</td></tr><tr><td>RoutesRecognized</td><td>the Router parses the URL and the routes are recognized.</td></tr><tr><td>GuardsCheckStart</td><td>the Router begins the Guards phase of routing.</td></tr><tr><td>ChildActivationStart</td><td>the Router begins activating a route's children.</td></tr><tr><td>ActivationStart</td><td>the Router begins activating a route.</td></tr><tr><td>GuardsCheckEnd</td><td>the Router finishes the Guards phase of routing successfully.</td></tr><tr><td>ResolveStart</td><td>the Router begins the Resolve phase of routing.</td></tr><tr><td>ResolveEnd</td><td>the Router finishes the Resolve phase of routing successfully.</td></tr><tr><td>ChildActivationEnd</td><td>the Router finishes activating a route's children.</td></tr><tr><td>ActivationEnd</td><td>the Router finishes activating a route.</td></tr><tr><td>NavigationEnd</td><td>navigation ends successfully.</td></tr><tr><td>NavigationCancel</td><td>navigation is canceled. This is due to a Route Guard returning false during navigation.</td></tr><tr><td>NavigationError</td><td>navigation fails due to an unexpected error.</td></tr><tr><td>Scroll</td><td>An event that represents a scrolling event.</td></tr></tbody></table><br><img src='./assets/expertAngular/routerEvent.png'>"
            },
            {
                "name": "What is wildcard route in angular?",
                "description": "<p>A wildcard route has a path consisting of two asterisks. It matches every URL and hence it is always recommended to be places as the last routing path in the routing configuration. The router will select this route if it can't match a route earlier in the configuration. We use the wildcard path to catch any non existing routes and we use the redirectTo property to redirect url to the /404 path which maps to the not found component.<br><img src='./assets/expertAngular/wildRoute.png'></p>"
            },
            {
                "name": "Do I need a Router/Routing Module always?",
                "description": "<p>No, the <strong>Routing Module</strong> is a design choice. You can skip routing Module (for example, AppRoutingModule) when the configuration is simple and merge the routing configuration directly into the companion module (for example, AppModule). But it is recommended when the configuration is complex and includes specialized guard and resolver services.</p>"
            },
            {
                "name": "How to detect a router change in Angular?",
                "description": "<p>In Angular you can <code>subscribe</code> (Rx event) to a Router instance. So you can do things like: <code>this.router.events.subscribe((event: Event) => {})</code><br><br><img src='./assets/angular/routedetect.png' /><br><br><strong>Method 2 which is latest syntax</strong><br><pre>constructor(private router: Router) {<br><br>this.router.events.subscribe((event: Event) => {<br> if (event instanceof NavigationStart) {<br> // Show loading indicator and perform an action<br> }<br><br> if (event instanceof NavigationEnd) {<br> // Hide loading indicator and perform an action<br> }<br><br> if (event instanceof NavigationError) {<br> // Hide loading indicator and perform an action<br> console.log(event.error); // It logs an error for debugging<br> }<br> });<br> }</pre></p>"
            },
            {
                "name": "Name the navigation event trigger when loading lazy load routes?",
                "description": "<p><strong>RouteConfigLoadStart</strong> - An event triggered before the Router lazy loads a route configuration.<br><br><strong>RouteConfigLoadEnd</strong> - An event triggered after a route has been lazy loaded.<br><br>Let's say you have the following lazy route:<br><img src='./assets/expertAngular/lazyLoad.png'><br><br>And here's how you can hook to loading process of this module:<br><img src='./assets/expertAngular/lazyLoad1.png'></p>"
            },
            {
                "name": "What is SSR / Server Side Rendering / Angular Universal",
                "description": "<p>Angular Universal is the process of server-side rendering (SSR) your application to HTML on the Server (ie: Node.js). Technically the package is now found under <code>@angular/platform-server</code>.<br><br>Step 1 - use ng add to install the Universal schematics to our application.<br><img src='./assets/expertAngular/ssr.png'><br><strong>Example</strong><br><img src='./assets/expertAngular/ssr1.png'><br><br>Step 2 - Run the SSR project <br><br><img src='./assets/expertAngular/ssr2.png'><br>This will compile your application and <em>spin up a Node Express server </em>to serve your Universal application on <code><strong>http://localhost:4000</strong></code><br><br><img src='./assets/expertAngular/ssr3.png'><br>This script compiles your application and <em>pre-renders your applications files</em>, spinning up a demo http-server so you can view it on <code><strong>http://localhost:8080</strong></code></p>"
            },
            {
                "name": "Just-in-Time (JiT) vs Ahead-of-Time (AoT) compilation. Explain the difference.",
                "description": "<p><strong> JiT (Just in Time) Compilation</strong><br> #The name itself describes the working, It compiles the code just in the time of loading the page in browser. The browser will download the compiler and build the application code and renders it.<br> #It will be good for development environment.<br> #JIT compilation is the default when you run the <code>ng build</code> (build only) or <code>ng serve</code> (build and serve locally) CLI commands.<br><br><strong> AoT (Ahead of Time) Compilation</strong><br> #It compiles all the code at the time of building the application. Here, the browser doesn't want to download the compiler and compile the code instead it render the application by just loading the already compiled code.<br> #Can be used in the production environment<br> #For AOT compilation, include the --aot flag with the ng build or ng serve command such as <br><code>ng build --aot <br> ng serve --aot</code></p>"
            },
            {
                "name": "Benifits of AoT compilation?",
                "description": "<ul><li><strong>Faster rendering:</strong> The browser downloads a pre-compiled version of the application. So it can render the application immediately without compiling the app.</li><li><strong>Fewer asynchronous requests:</strong> It inlines external HTML templates and CSS style sheets within the application javascript which eliminates separate ajax requests.</li><li><strong>Smaller Angular framework download size:</strong> Doesn't require downloading the Angular compiler. Hence it dramatically reduces the application payload.</li><li><strong>Better security:</strong> It compiles HTML templates and components into JavaScript. So there won't be any injection attacks.</li><li>Helps in finding the template errors during the build process itself.</li></ul>"
            },
            {
                "name": "What are the 3 phases of AOT in compilation process?",
                "description": "<p><strong>The 3 phases of AOT are: Code Analysis, Code Generation, Template Type Checking</strong></p><ul><li><strong>Code Analysis</strong> - In this phase, the AOT collector analyses the metadata and then represents it in the best possible manner. All analysed information is recorded in the&nbsp;<strong><em>.metadata.json</em></strong>&nbsp;file. Any error found in the metadata syntax is recorded and an error is thrown to the ‘<strong><em>.metadata.json’</em></strong>&nbsp;file.</li><li><strong>Code Generation</strong> - In this phase, the metadata collected from the Code Analysis phase will be interpreted by the compiler’s&nbsp;<em>StaticReflector</em>. During this phase, a check for metadata is done once again. If any violations in metadata syntax are found, then an error is thrown.</li><li><strong>Template Type Checking</strong> - In this phase, the Angular template compiler uses a typescript compiler to check the validation of binding expressions in templates. For this phase to happen,&nbsp;<em>“fullTemplateTypeCheck”</em>&nbsp;is set to&nbsp;<em>true</em>&nbsp;in&nbsp;<em>“angularCompilerOptions”</em>&nbsp;in the&nbsp;<strong><em>tsconfig.base.json</em></strong></li></ul>"
            },
            {
                "name": "What is the purpose of metadata json files?",
                "description": "<p>The metadata.json file can be treated as a diagram of the overall structure of a decorator's metadata, represented as an abstract syntax tree(AST). During the analysis phase, the AOT collector scan the metadata recorded in the Angular decorators and outputs metadata information in .metadata.json files, one per .d.ts file.</p>"
            },
            {
                "name": "Give an example of few metadata errors?",
                "description": "<p>#1. Expression form not supported <br>#2. Reference to a local (non-exported) symbol: <br>#3. Function calls are not supported <br>#4. Destructured variable or constant not supported</p>"
            },
            {
                "name": "What is metadata rewriting?",
                "description": "<p>Metadata rewriting is the process in which the compiler converts the expression initializing the fields such as useClass, useValue, useFactory, and data into an exported variable, which replaces the expression. Remember that the compiler does this rewriting during the emit of the .js file but not in definition files( .d.ts file).</p>"
            },
            {
                "name": "How angular compile typescript to javascript?",
                "description": "<p>TypeScript is a primary language for Angular application development. It is a superset of JavaScript with design-time support for type safety and tooling.<br>Browsers can't execute TypeScript directly. Typescript must be 'transpiled' into JavaScript using the tsc compiler, which requires some configuration.<br>This page covers some aspects of TypeScript configuration and the TypeScript environment that are important to Angular developers, including details about the following files:</p><ul><li><strong>tsconfig.json</strong>—TypeScript compiler configuration.</li><li><strong>typings</strong>—TypesScript declaration files.</li></ul>"
            },
            {
                "name": "Angular template compiler options",
                "description": "<p>When a developer use's ahead-of-time compilation (AOT), he/she have control over how the application is compiled by specifying template compiler options in the TypeScript configuration file. <br>The template options object, <code><strong>angularCompilerOptions</strong></code>, is a sibling to the <code><strong>compilerOptions</strong></code> object that supplies standard options to the TypeScript compiler.<br><br><img src='./assets/expertAngular/compilerOptions.png'></p>"
            },
            {
                "name": "What is non null type assertion operator?",
                "description": "<p>The Angular non-null assertion operator causes the TypeScript type checker to suspend strict <code>null</code> and <code>undefined</code> checks for a specific property expression.<br> Ex. {{item.color!.toUpperCase()}}<br><br>It’s important to note that at the time of writing, non-null assertions are still a feature of TypeScript, and optional chaining has limited browser support.<br><img src='./assets/expertAngular/nonnull.png'></p>"
            },
            {
                "name": "How do you describe various dependencies in angular application?",
                "description": "<p>The dependencies section of package.json with in an angular application can be divided as follow,</p><ol><li><strong>Angular packages:</strong> Angular core and optional modules; their package names begin @angular/.</li><li><strong>Support packages:</strong> Third-party libraries that must be present for Angular apps to run.</li><li><strong>Polyfill packages:</strong> Polyfills plug gaps in a browser's JavaScript implementation.</li></ol>"
            },
            {
                "name": "What is NgZone?",
                "description": "<p>Angular provides a service called NgZone which creates a zone named angular to automatically trigger change detection when the following conditions are satisfied. say When a sync or async function is executed.<br><br>The most common use of this service is to optimize performance when starting a work consisting of one or more asynchronous tasks that don't require UI updates or error handling to be handled by Angular. Such tasks can be kicked off via runOutsideAngular and if needed, these tasks can reenter the Angular zone via run.</p>"
            },
            {
                "name": "What are the lifecycle hooks of a zone?",
                "description": "<p>There are four lifecycle hooks for asynchronous operations from zone.js.</p><ol><li><strong>onScheduleTask:</strong> This hook triggers when a new asynchronous task is scheduled. For example, when you call setTimeout()<br><img src='./assets/angular/zonecycle1.png'></li><li><strong>onInvokeTask:</strong> This hook triggers when an asynchronous task is about to execute. For example, when the callback of setTimeout() is about to execute.<br><img src='./assets/angular/zonecycle.png'></li><li><strong>onHasTask:</strong> This hook triggers when the status of one kind of task inside a zone changes from stable(no tasks in the zone) to unstable(a new task is scheduled in the zone) or from unstable to stable.<br><img src='./assets/angular/zonecycle2.png'></li><li><strong>onInvoke:</strong> This hook triggers when a synchronous function is going to execute in the zone.<br><img src='./assets/angular/zonecycle3.png'></li></ol>"
            },
            {
                "name": "Could you provide some particular examples of using ngZone?",
                "description": "<p>There would be a lot of cases when you want to use <code>NgZone</code>, I can name two :<br>1. When you want something to run outside of Angular's change detection. Lets say we want to do some calculation when user is scrolling and don't want you to run change detection, in this case, you'd use NgZone:<br><br><img src='./assets/angular/ngzone.png' /><br><br>2. The exact opposite of above, where you have a function that is somehow outside of Angular's zone and you want it to be inside, like when a third party library is doing some stuff for you and you want it to be bound to your Angular cycle.<br><br><img src='./assets/angular/ngzone1.png' /></p>"
            },
            {
                "name": "What are the methods of NgZone used to control change detection?",
                "description": "<p>NgZone service provides a <code>run()</code> method that allows you to execute a function inside the angular zone. This function is used to execute third party APIs which are not handled by Zone and trigger change detection automatically at the correct time.<br><img src='./assets/angular/ngzone2.png'><br><br>Whereas <code>runOutsideAngular()</code> method is used when you don't want to trigger change detection.<br><img src='./assets/angular/ngzone3.png'></p>"
            },
            {
                "name": "What is codelyzer?",
                "description": "<p>Codelyzer provides set of tslint rules for static code analysis of Angular TypeScript projects. ou can run the static code analyzer over web apps, NativeScript, Ionic etc. Angular CLI has support for this concept <br><code>ng new codelyzer <br>ng lint</code></p>"
            },
            {
                "name": "How we can audit an angular app? (codelyzer)",
                "description": "<p>We can add codelyzer's accessibility checks to the build process for an Angular app.<br><br>By Default, all the accessibility rules are experimental and disabled. One can enable them by adding them to the TSLint configuration file (tslint.json):<br><img src='./assets/expertAngular/tslintrules.png'><br><br>Now, With codelyzer's accessibility checks set up, you get a popup showing accessibility errors in TypeScript files or inline templates as you code:<br><br>To perform linting over the entire project (including external templates), use the <strong>ng lint</strong> command:</p>"
            },
            {
                "name": "What is Linting and name some linting tools",
                "description": "<p>Linting, lint or linter is a tool that analyzes source code to raise any programming errors, bugs, stylistic errors, and suspicious constructs.Below are the linting tools</p><ul><li><strong>ESLint</strong> is a popular JavaScript linter. There are plugins available that analyse specific code styles. One of the most common for React is an npm package called <strong>eslint-plugin-react</strong> and <strong>eslint-plugin-jsx-a11y</strong></li><li><strong>JSLint</strong></li><li><strong>JSHint</strong></li><li><strong>JSCS JavaScript Linter</strong></li><li><strong>Standard JS</strong> - Standard is a popular JavaScript code style guide built on top of ESLint. The tool can be used as a JavaScript style guide, linter, and formatter. It automatically formats code and catches style and programmer errors during the early development period. Developers can use Standard the VSCode extension to integrate JavaScript Standard Style into their VSCode editor</li></ul>"
            },
            {
                "name": "How to support accessibility ?",
                "description": "<ol><li>Learn the tools for testing accessibility like codealyzer and eslint.</li><li>Define unique page titles by using Angular Title service.</li><li>Ensure you meet the Web Content Accessibility Guidelines (WCAG 2.0) color contrast ratio guidelines.</li><li>Use Semantic HTML instead of div</li><li>Provide control labels with ARIA</li></ol>"
            },
            {
                "name": "What will happens if you use script tag inside template?",
                "description": "<p>Angular recognizes the value as unsafe and automatically sanitizes it, which removes the <code>&lt;script&gt;</code> tag but keeps safe content such as the text content of the <code>&lt;script&gt;</code> tag. This way it eliminates the risk of script injection attacks. If you still use it then it will be ignored and a warning appears in the browser console. Let's take an example of innerHtml property binding which causes XSS vulnerability,<br><br><img src='./assets/angular/scripttagintemplate.png'></p>"
            },
            {
                "name": "How to inject the dynamic script in angular?",
                "description": "<p>Using DomSanitizer we can inject the dynamic Html,Style,Script,Url.<br><img src='./assets/angular/sanitize.png'></p>"
            },
            {
                "name": "What is a service worker?",
                "description": "<p>In Angular <strong>ngsw-config.json file contain service worker configuration</strong><br><br>A service worker is a script that runs in the web browser and manages caching for an application. Starting from 5.0.0 version, Angular ships with a service worker implementation. Angular service worker is designed to optimize the end user experience of using an application over a slow or unreliable network connection, while also minimizing the risks of serving outdated content.<br><br><strong>Benefits / design goals of Angular's service workers</strong></p><ol><li>It caches an application just like installing a native application</li><li>A running application continues to run with the same version of all files without any incompatible files</li><li>When you refresh the application, it loads the latest fully cached version</li><li>When changes are published then it immediately updates in the background</li><li>Service workers saves the bandwidth by downloading the resources only when they changed.</li></ol>"
            },
            {
                "name": "Differences between AngularJS and Angular with respect to dependency injection?",
                "description": "<p>Dependency injection is a common component in both AngularJS and Angular, but there are some key differences between the two frameworks in how it actually works.</p><table><thead><tr><th>AngularJS</th><th>Angular</th></tr></thead><tbody><tr><td>Dependency injection tokens are always strings</td><td>Tokens can have different types. They are often classes and sometimes can be strings.</td></tr><tr><td>There is exactly one injector even though it is a multi-module applications</td><td>There is a tree hierarchy of injectors, with a root injector and an additional injector for each component.</td></tr></tbody></table>"
            },
            {
                "name": "What is a View Engine ?",
                "description": "<p>View Engine is responsible for compiling the components so that they can be consumed by the browser. In Angular, we write our components using TypeScript and it cannot be run directly in browsers and for this purpose we require View Engines which would convert TS into JS and HTML.<br><br><strong>Responsibilities of View Engine</strong></p><ol><li>Template Parsing - The template HTML is then converted into JavaScript instructions that are then used by the Angular Interpreter to understand how to display them in the DOM.</li><li>Tree-Shaking - Tree Shaking is a process to remove dead code from the bundle.</li><li>Compilation - Renderer2 offers two variants of code compilation: Ahead Of Time Compilation (AOT) and Just In Time Compilation (JIT)</li></ol>"
            },
            {
                "name": "What is Angular Ivy?",
                "description": "<p>Ivy is the code name for Angular’s compilation and rendering pipeline. Applications developed in Angular 9 are Ivy compiled by default. These applications are compiled&nbsp;<strong>Ahead of Time (AOT)</strong>&nbsp;i.e. before the browser downloads and runs it, which makes the application faster and more efficient.<br><br><strong>Features included in ivy preview</strong></p><ol><li>Generated code that is easier to read and debug at runtime</li><li>Faster re-build time</li><li>Improved payload size</li><li>Improved template type checking</li></ol><ul><li>You can enable ivy in a new project by using the --enable-ivy flag with the ng new command. Ex. - <code>ng new ivy-demo-app --enable-ivy</code></li><li>You can add it to an existing project by adding <code>enableIvy</code> option in the <code>angularCompilerOptions</code> in your project's <code>tsconfig.app.json</code>.<br><img src='./assets/angular/ivy.png'></li></ul><br><br><p>Before Ivy,&nbsp;<em>View Engine&nbsp;</em>was the default compiler in Angular. Ivy uses the <em>Ahead Of Time </em>compilation technique instead of Just In Time (JIT) which was used in the previous Angular versions.</p>"
            },
            {
                "name": "What is ngcc in Angular Ivy",
                "description": "<p>The <code>ngcc</code> (Angular Compatibility Compiler) is a tool used to compile Angular libraries to a format that is compatible with Ivy. which were however in the past not compatible with the Angular Ivy runtime,</p>"
            },
            {
                "name": "What is Angular Language Service?",
                "description": "<p>The Angular Language Service is a way to get completions, errors, hints, and navigation inside your Angular templates whether they are external in an HTML file or embedded in annotations/decorators in a string. It has the ability to autodetect that you are opening an Angular file, reads your <code>tsconfig.json</code> file, finds all the templates you have in your application, and then provides all the language services.</p><br><br><p><strong> install angular language service in the project</strong><br>Use <strong>npm</strong> command, - <code>npm install --save-dev @angular/language-service</code><br><br>After that add the following to the \"compilerOptions\" section of your project's tsconfig.json <br><code>\"plugins\": [ <br>{\"name\": \"@angular/language-service\"} <br>]</code></p><br><br><p><strong>there are 3 main features provided by Angular Language Service</strong></p><ul><li><strong>Autocompletion:</strong> Autocompletion can speed up your development time by providing you with contextual possibilities and hints as you type with in an interpolation and elements.</li><li><strong>Error checking:</strong> It can also warn you of mistakes in your code.</li><li><strong>Navigation:</strong> Navigation allows you to hover a component, directive, module and then click and press F12 to go directly to its definition.</li></ul>"
            },
            {
                "name": "What is web worker?",
                "description": "<p>Web workers are used for running any script in the background threads, without interfering with the user’s interface. So if you have heavy computations on your user side, you can use web workers to do the heavy tasks while allowing the browser to give your users a smooth and better experience.<br><br>For example, If the file that contains your expensive computation is <code>src/app/app.component.ts</code>, you can add a <code>Web Worker</code> using <code>ng generate web-worker</code> app command which will create <code>src/app/app.worker.ts</code> web worker file. </p>"
            },
            {
                "name": "What is Bazel tool?",
                "description": "<p><b>Bazel</b> is an advanced build and test tool. It supports lot of features suitable for large projects.<br><br>Some of the features of <b>Bazel</b> are as follows:</p><ul><li>Support multiple languages.</li><li>Support multiple platforms.</li><li>Support multiple repository.</li><li>Support high-level build language.</li><li>Fast and reliable.</li></ul><p>Angular supports building the application using bazel. <br><strong>First, install @angular/bazel package.</strong><br>npm install -g @angular/bazel <br><br><strong>For existing application, Add @angular/bazel</strong><br>ng add @angular/bazel <br><br><strong>For new application,</strong><br>ng new --collection=@angular/bazel <br><br><strong>To build an application using bazel,</strong><br>ng build --leaveBazelFilesOnDisk <br><strong>leaveBazelFilesOnDisk</strong> option will leave the bazel files created during build process, which we can use to build the application directly using bazel.</p>"
            },
            {
                "name": "What is platform in Angular?",
                "description": "<p>A platform is the context in which an Angular application runs. The most common platform for Angular applications is a web browser, but it can also be an operating system for a mobile device, or a web server. The runtime-platform is provided by the @angular/platform-* packages and these packages allow applications that make use of <code>@angular/core</code> and <code>@angular/common</code> to execute in different environments. i.e, Angular can be used as platform-independent framework in different environments, For example,</p><ol><li>While running in the browser, it uses <code>platform-browser</code> package.</li><li>When SSR(server-side rendering ) is used, it uses <code>platform-server</code> package for providing web server implementation.</li></ol>"
            },
            {
                "name": "What happens if I import the same module twice?",
                "description": "<p>If multiple modules imports the same module then angular evaluates it only once (When it encounters the module first time). It follows this condition even the module appears at any level in a hierarchy of imported NgModules.</p>"
            },
            {
                "name": "How do you select an element with in a component template?",
                "description": "<p>You can use <code>@ViewChild</code> directive to access elements in the view directly. Let's take input element with a reference,<br><code><input #uname></code><br>and define view child directive and access it in ngAfterViewInit lifecycle hook <code>@ViewChild('uname') input;<br><br>ngAfterViewInit() {<br>console.log(this.input.nativeElement.value);<br>}</code></p>"
            },
            {
                "name": "How do you select an element in component template?",
                "description": "<p>You can get a handler to the DOM element via ElementRef by injecting it into your component's constructor:</p><code>constructor(myElement: ElementRef) { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;el.nativeElement.style.backgroundColor = 'yellow';<br> }</code>"
            },
            {
                "name": "How to configure differential loading?",
                "description": "<p><strong>Differential Loading</strong> is a mechanism of choosing the browser between modern or legacy JavaScript based on its own capabilities. Currently taking advantage of this by default by performing a modern build and a legacy build of the application. When users load the application, they’ll automatically get the bundle they need.<br><br>The CLI can understand browsers which the app needs to support and can make different bundles for both ES5 browsers and not.</p><ul><li>Produce ES5 modules for newer browsers</li><li>Do not downgrade modern level features</li><li>Do not send polyfills for the modern browsers</li></ul><p>That means above flow guarantees the smaller payload and faster execution.</p><br><br><p>How to use it - To enable differential loading, the app must have browserslist configuration. It can be placed in package.json or browserslist file</p><ul><li>Set the target to es2015 in <em>tsconfig.js</em></li><li>Set the minimum supported browsers in <em>browserlist</em></li></ul><p><strong>Angular CLI knows how to handle this</strong>. The CLI judges whether the app has to support ES5 browsers, and check the current tsconfig's target can support them.<br><br>If they are mismatched, all bundles are separated as like&nbsp;app-es5.js and&nbsp;app-es2015.js.<br><br>The browser follows the 3-step process in order to run the application with differential loading capability.<br><br>#1. Load HTML <br>#2. Look at script tags <br>#3. Download the correct version<br><br>This ensures on modern browsers,&nbsp;users will load bundles in a smaller size&nbsp;just that the browser needs. It can improve loading performance.</p>"
            },
            {
                "name": "Dynamic Imports",
                "description": "<p>Yes, Angular 8 supports dynamic imports in router configuration. i.e, You can use the import statement for lazy loading the module using <code>loadChildren</code> method and it will be understood by the IDEs(VSCode and WebStorm), webpack, etc. <br><br>Previously, you have been written as below to lazily load the feature module. By mistake, if you have typo in the module name it still accepts the string and throws an error during build time.<br><code>{path: ‘user’, loadChildren: ‘./users/user.module#UserModulee’},</code><br><br>This problem is resolved by using dynamic imports and IDEs are able to find it during compile time itself. <br><code>{path: ‘user’, loadChildren: () => import(‘./users/user.module’).then(m => m.UserModule)};</code></p>"
            },
            {
                "name": "Lazy loading in angular modules?",
                "description": "<ul><li><strong>Answer #1</strong> - Lazy loading is one of the most useful concepts of Angular Routing. It helps us to download the web pages in chunks instead of downloading everything in a big bundle. It is used for lazy loading by asynchronously loading the feature module for routing whenever required using the property <code>loadChildren</code></li><li><strong>Answer #2</strong> - If the application size is growing and there are many feature modules then loading all feature modules eagerly will make application slow. What we can do, is we can load a feature module on demand when it is required. Such type of module loading concept is called lazy loading.</li></ul><br><p><code>loadChildren: () => import('./items/items.module').then(m => m.ItemsModule)<br> //or <br>loadChildren: () => import('./items/items.module#ItemsModule')</code></p>"
            },
            {
                "name": "Pre Loading in angular?",
                "description": "<ul><li>In preloading, feature modules are loaded in background asynchronously. In preloading, modules start loading just after application starts.</li><li>When we hit the application, first AppModule and modules imported by it, will be loaded eagerly. Just after that modules configured for preloading is loaded asynchronously.</li><li>Preloading is useful to load those features which are in high probability to be visited by user just after loading the application.</li> <li>To configure preloading, angular provides preloadingStrategy property which is used with RouterModule.forRoot in routing module<br><img src='./assets/angular/preload.png'></li><li><strong>Creating a Custom Preload Strategy</strong><br><img src='./assets/angular/preload1.png'></li></ul>"
            },
            {
                "name": "Eager Loading in angular?",
                "description": "<ul><li>In eager loading module, feature modules are loaded before application start on the first hit. To load a feature module eagerly, we need to <code>import</code> that module in application module i.e. <code>AppModule</code> using imports metadata of <code>@NgModule</code> decorator. </li><li>When a module is loaded, it loads all the imported modules, configured components, services, custom pipes etc.</li><li>Modules are loaded in the order they are configured in <code>imports</code> metadata.</li><li>Eager loading is good for small applications because at the first hit of the application all the modules are loaded and all the required dependencies are resolved. Now the subsequent access to the application will be faster.</li></ul>"
            },
            {
                "name": "What is NgUpgrade?",
                "description": "<p>NgUpgrade is a library put together by the Angular team, which you can use in your applications to mix and match AngularJS and Angular components and bridge the AngularJS and Angular dependency injection systems.</p>"
            },
            {
                "name": "How do you upgrade angular version?",
                "description": "<p>ng update @angular/cli @angular/core</p>"
            },
            {
                "name": "How To Use Change Detection Strategy in Angular?",
                "description": "<p>By default, Angular 2+ performs change detection on all components (from top to bottom) every time something changes in your app. <br><br>but as an app gets more complex and the amount of components grows, change detection will have to perform more and more work  which makes app slower.<br><br>One solution is to use the OnPush change detection strategy for specific components. This will instruct Angular to run change detection on these components and their sub-tree only when new references are passed to them versus when data is mutated.<br><br><strong>Exploring a <code> ChangeDetectionStrategy</code></strong> Example - Let's examine a simple parent component with a child component that displays a list of aquatic creatures and allows users to add new creatures to the list: <br><br> After compiling and visiting the application in a browser, we must see an unordered list containing shark, dolphin, and octopus. <br><br>Typing an aquatic creature to the input field and clicking the Add creature button will append the new creature to the list. <br><br>The child component is updated when Angular detects the data has changed in the parent component.<br><img src='./assets/expertAngular/appComponent.png'><br><img src='./assets/expertAngular/appComponentHTML.png'><br><img src='./assets/expertAngular/childComponent.png'><br><img src='./assets/expertAngular/childComponentHTML.png'><br><br>Now, let's set the change detection strategy in the child component to <strong>OnPush</strong>: <br><img src='./assets/expertAngular/OnPush.png'><br><br>To pass a new reference to the data input, you can replace <strong>Array.push</strong> with the <strong>spread syntax (...)</strong> in addAquaticCreature:<br><img src='./assets/expertAngular/appComponent1.png'><br>With this variation, you are no longer mutating the aquaticCreatures array. You are returning a completely new array.<br><br>After recompiling, you should observe that the application behaves as before. Angular detected a new reference to <strong>data</strong>, so it ran its change detection on the child component.<br><br><strong>Exploring <code>ChangeDetectorRef</code> Examples</strong> - When using a change detection strategy of OnPush, other than making sure to pass new references every time something should change, you can also make use of the ChangeDetectorRef for complete control. <br><code><strong>ChangeDetectorRef.detectChanges()</strong></code><br><br>You could for example keep mutating your data, and then have a button in the child component with a <strong>Refresh</strong> button.<br><br>And add a button element that triggers refresh():<br><img src='./assets/expertAngular/childComponentHTML1.png'><br>Then, modify the child component to use ChangeDetectorRef:<br><img src='./assets/expertAngular/childComponent1.png'><br><br><strong>Exploring <code>ChangeDetectorRef with markForCheck()</code> Examples</strong>: Let's say your data input is actually an observable. This example will use the RxJS <code>BehaviorSubject</code>:<br><img src='./assets/expertAngular/appComponent2.png'><br>And you subscribe to it in the OnInit hook in the child component. You will add the aquatic creatures to a aquaticCreatures array here:<br><img src='./assets/expertAngular/childComponent2.png'><br><code><strong>markForCheck</strong></code> instructs Angular that this particular input should trigger change detection when mutated.<br><img src='./assets/expertAngular/childComponent3.png'></p>"
            },
            {
                "name": "What are the differences of various versions of Angular?",
                "description": "<ol><li><strong>Angular 1:</strong><ul><li>Angular 1 (AngularJS) is the first angular framework released in the year 2010.</li><li>AngularJS is not built for mobile devices.</li><li>It is based on controllers with MVC architecture.</li></ul></li><li><strong>Angular 2:</strong><ul><li>Angular 2 was released in the year 2016. Angular 2 is a complete rewrite of Angular1 version.</li><li>The performance issues that Angular 1 version had has been addressed in Angular 2 version.</li><li>Angular 2 is built from scratch for mobile devices unlike Angular 1 version.</li><li>Angular 2 is components based.</li></ul></li><li><strong>Angular 3:</strong><ul><li>The following are the different package versions in Angular 2:<ul><li>@angular/core v2.3.0</li><li>@angular/compiler v2.3.0</li><li>@angular/http v2.3.0</li><li>@angular/router v3.3.0</li></ul></li><li>The router package is already versioned 3 so to avoid confusion switched to Angular 4 version and skipped 3 version.</li></ul></li><li><strong>Angular 4:</strong><ul><li>The compiler generated code file size in AOT mode is very much reduced.</li><li>With Angular 4 the production bundles size is reduced by hundreds of KB’s.</li><li>Animation features are removed from angular/core and formed as a separate package.</li><li>Supports Typescript 2.1 and 2.2.</li><li>Angular Universal</li><li>New HttpClient</li></ul></li><li><strong>Angular 5:</strong><ul><li>Angular 5 makes angular faster. It improved the loading time and execution time.</li><li>Shipped with new build optimizer.</li><li>Supports Typescript 2.5.</li><li>Service Worker</li></ul></li><li><strong>Angular 6:</strong><ul><li>It is released in May 2018.</li><li>Includes Angular Command Line Interface (CLI), Component Development KIT (CDK), Angular Material Package, Angular Elements.</li><li>Service Worker bug fixes.</li><li>i18n</li><li>Experimental mode for Ivy.</li><li>RxJS 6.0</li><li>Tree Shaking</li></ul></li><li><strong>Angular 7:</strong><ul><li><p>Angular Elements - now supports content projection using <strong>web standards for custom elements</strong>.</p></li><li><p>Angular 7.0 applications will use the Bundle Budget feature of Angular CLI. This will warn developers if the application bundle size exceeds the predefined limit. </p></li><li><p>The Component Dev Kit (CDK) of Angular Material also receives some new features </p></li><li>Virtual Scrolling</li><li>Drag and Drop</li></ul></li><li><strong>Angular 8:</strong><ul><li><strong>Differential loading</strong> - with differential loading, two bundles are created when building for production: a bundle for modern browsers that support ES2015+ and a bundle for older browsers that only support the ES5 version of JavaScript</li><li><strong>TypeScript 3.4</strong> support</li><li><strong>Ivy</strong> - it is the new compiler/runtime of Angular. It will enable very cool features in the future, but it is currently focused on not breaking existing applications.</li><li><strong>Bazel</strong> support - it is a build tool developed and massively used by Google, as it can build pretty much any language.</li><li><p><strong>Lazy-loading with import()</strong> syntax</p></li></ul></li><li><strong>Angular 9:</strong><ul><li>JavaScript Bundles and Performance - A production build with Angular 8.2.7 resulted in a main.js of 246KB for ES2015 browsers. A build with Angular 9.0.0-next.5 yielded a slightly small main.js file at 214KB. That's a 13 percent improvement from Angular 8.</li><li>Ivy Compiler - Ivy yields much smaller JavaScript bundles, so Ivy solves Angular's bundle weaknesses.</li><li>Selector-less Bindings - Angular ViewEngine already supports this pattern. Still, it was missing in Ivy's initial release</li><li>Internationalization - You can use the Angular CLI to generate most of the standard code necessary to create files for translators. After you have configured your app to use i18n, you can run the xi18n command to extract the localizable text into a file.</li></ul></li></ol>"
            },
            {
                "name": "What are the security principles in angular?",
                "description": "<p>Below are the list of security principles in angular,</p><ol><li>You should avoid direct use of the DOM APIs.</li><li>You should enable Content Security Policy (CSP) and configure your web server to return appropriate CSP HTTP headers.</li><li>You should Use the offline template compiler.</li><li>You should Use Server Side XSS protection.</li><li>You should Use DOM Sanitizer.</li><li>You should Preventing CSRF or XSRF attacks.</li></ol>"
            },
            {
                "name": "How to prevent cross site scripting / XSS attack?",
                "description": "<p>One way is we can use the <code>DomSanitzer</code> class in <code>@angular/platform-browser</code>, to mark values as safe. The DomSanitizer class has built-in sanitization methods for contexts such as HTMl, Style, URl, and Resource Url<br><br>To mark the value as trusted and safe to use, you can inject <code>DomSanitizer</code> and use one of the following methods appropriate for the security context to return a value marked as safe.</p><ol><li><code>bypassSecurityHTML</code></li><li><code>bypassSecurityScript</code></li><li><code>bypassSecurityTrustStyle</code></li><li><code>bypassSecurityTrustUrl</code></li><li><code>bypassSecurityTrustResourceUrl</code></li></ol><br><br>Another way is Use ahead-of-time (AOT) compilation for extra security<br><br>Angular’s AOT compilation has extra security measures for injection attacks like XSS. AOT compilation is highly recommended for production code and has been the default compilation method since Angular v9. Not only is it more secure, but it also improves performance.</p>"
            },
            {
                "name": "What is CSP Content security policy?",
                "description": "<p>Angular CSP is a security feature that makes your site less vulnerable to attacks like XSS. You can use this feature to specify whether your site should allow in-line JavaScript or not. In addition, you can specify policies for other content like AJAX, CSS, and iframe.<br><br>Content Security Policy is sent to the browser using a Content-Security-Policy HTTP header. <br><strong><code>Content-Security-Policy: default-src 'self'; img-src https://*; child-src 'none';</code></strong><br><br>There are multiple ways to enable CSP on your website. One is on a global level using server configuration. The process for enabling CSP at the server level varies, depending on the type of service or operating system hosting your website. #2. Another method is by using a server-side rendering tool like Angular Universal. #3. The third method is by using a meta tag with http-equiv set to Content-Security-Policy. You can add the meta tag to your Angular project's index.html. <br><code><meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src https://*;\"></code></p>"
            },
            {
                "name": "What is CORS?",
                "description": "<p>Cross-Origin Resource Sharing (CORS) is a mechanism that uses additional HTTP headers to tell browsers to give a web application running at one origin, access to selected resources from a different origin. ... The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers</p><ul><li>Step 1 = create src/proxy.conf.json file and add the following content:<br><img src='./assets/angular/cors.png'></li><li>Step 2 = Add a proxyConfig key to angular.json<br><img src='./assets/angular/cors1.png'></li></ul>"
            },
            {
                "name": "What is Sanitization?",
                "description": "<p>Angular treats all values as untrusted by default. When a value is inserted into the DOM from a template, via property, attribute, style, class binding, or interpolation, Angular sanitizes and escapes untrusted values. Sanitization modifies the input, turning it into a value that is safe to insert into the DOM.<br><br><img src='./assets/angular/sanitization.png'></p>"
            },
            {
                "name": "What is innerHtml?",
                "description": "<p>The innerHtml is a property of HTML-Elements, which allows you to set it's html-content programmatically</p>"
            },
            {
                "name": "How does Angular simplifies Internationalization or i18n?",
                "description": "<p>Angular simplifies the below areas of internationalization,</p><ol><li>Displaying dates, number, percentages, and currencies in a local format.</li><li>Preparing text in component templates for translation.</li><li>Handling plural forms of words.</li><li>Handling alternative text.</li></ol>"
            },
            {
                "name": "In which file we put i18n / localize configuration ?",
                "description": "<p><img src='./assets/expertAngular/localize.png'></p>"
            },
            {
                "name": "How do you manually register locale data in i18n?",
                "description": "<p>For this you must import locale data for that new locale, After that you can register using <code>registerLocaleData</code><br><br><strong>Syntax:</strong>registerLocaleData(data: any, localeId?: any, extraData?: any): void<br><br>For example, let us import German locale and register it in the application <br><br>import { registerLocaleData } from '@angular/common'; <br>import localeDe from '@angular/common/locales/de';<br><br>registerLocaleData(localeDe, 'de');</p>"
            },
            {
                "name": "What are phases of template translation in i18n?",
                "description": "<p>The i18n template translation process has four phases:</p><ol><li><strong>Mark static text messages in your component templates for translation:</strong> You can place i18n on every element tag whose fixed text is to be translated. For example <br><pre>&lt;h1 i18n&gt;Hello i18n!&lt;/h1&gt;</pre></li><li><strong>Create a translation file:</strong> Use the Angular CLI xi18n command to extract the marked text into an industry-standard translation source file. i.e, Open terminal window at the root of the app project and run the CLI command i.e. ng xi18n. The above command creates a file named <code>messages.xlf</code> in your project's root directory.</li><li><strong>Edit the generated translation file:</strong> Translate the extracted text into the target language. In this step, create a localization folder (such as <code>locale</code>)under root directory(src) and then create target language translation file by copying and renaming the default messages.xlf file. You need to copy source text node and provide the translation under target tag. For example, create the translation file(messages.de.xlf) for German language</li><li><strong>Merge the completed translation file into the app:</strong> You need to use Angular CLI build command to compile the app, choosing a locale-specific configuration.</li></ol>"
            },
            {
                "name": "What is the purpose of i18n attribute?",
                "description": "<p>The Angular i18n attribute marks translatable content. It is a custom attribute, recognized by Angular tools and compilers. The compiler removes it after translation.<br><br><strong>Note:</strong> Remember that i18n is not an Angular directive.</p>"
            },
            {
                "name": "How can I translate attribute in i18n?",
                "description": "<p>You can translate attributes by attaching <code>i18n-x</code> attribute  where x is the name of the attribute to translate. For example, you can translate image title attribute as below, <br><br>&lt;img &lsqb;src&rsqb;=\"example\" i18n-title title=\"Internationlization\" /&gt;</p>"
            },
            {
                "name": "How do you use jquery in Angular?",
                "description": "<p><img src='./assets/angular/usejquery.png'><br><br><img src='./assets/angular/usejquery1.png'></p>"
            },
            {
                "name": "What is index property in ngFor directives?",
                "description": "<p>The index property of the NgFor directive is used to return the zero-based index of the item in each iteration. You can capture the index in a template input variable and use it in the template.<br><code><div *ngFor='let todo of todos; let i=index'>{{i + 1}} - {{todo.name}}</div></code></p>"
            },
            {
                "name": "What is the purpose of ngFor trackBy?",
                "description": "<p>The main purpose of using *ngFor with trackBy option is performance optimization. Normally if you use NgFor with large data sets, a small change to one item by removing or adding an item, can trigger a cascade of DOM manipulations. In this case, Angular sees only a fresh list of new object references and to replace the old DOM elements with all new DOM elements. You can help Angular to track which items added or removed by providing a trackBy function which takes the index and the current item as arguments and needs to return the unique identifier for this item.<br><img src='./assets/angular/trackByFunction.png'><p>"
            },
            {
                "name": "What is safe navigation / Elvis operator?",
                "description": "<p>The safe navigation operator(?)(or known as Elvis Operator) is used to guard against <code>null</code> and <code>undefined</code> values in property paths when you are not aware whether a path exists or not. i.e. It returns value of the object path if it exists, else it returns the null value.<br><br>For example, you can access nested properties of a user profile easily without null reference errors <code>{{user?.fullName.firstName}}</code><br><br>Using this safe navigation operator, Angular framework stops evaluating the expression when it hits the first null value and renders the view without any errors.</p>"
            },
            {
                "name": "Which have higher precedence between pipe and ternary operator ?",
                "description": "<p>The pipe operator has a higher precedence than the ternary operator (?:). For example, the expression <strong><code>first ? second : third | fourth is parsed as first ? second : (third | fourth)</code></strong>.<br><br>Due to precedence, if you want a pipe to apply to the result of a ternary, wrap the entire expression in parentheses</p>"
            },
            {
                "name": "What is a bootstrapped component?",
                "description": "<p>A bootstrapped component is an entry component that Angular loads into the DOM during the bootstrap process or application launch time. Generally, this bootstrapped or root component is named as <code>AppComponent</code> in your root module using <code>bootstrap</code> property as below.</p>"
            },
            {
                "name": "What is Angular compiler?",
                "description": "<p>The Angular compiler is used to convert the application code into JavaScript code. It reads the template markup, combines it with the corresponding component class code, and emits component factories which creates JavaScript representation of the component along with elements of @Component metadata.</p>"
            },
            {
                "name": "How does angular finds components, directives and pipes?",
                "description": "<p>The Angular compiler finds a component or directive in a template when it can match the selector of that component or directive in that template. Whereas it finds a pipe if the pipe's name appears within the pipe syntax of the template HTML.</p>"
            },
            {
                "name": "What happens if browserModule used in feature module?",
                "description": "<p>If you do import <code>BrowserModule</code> into a lazy loaded feature module, Angular returns an error telling you to use <code>CommonModule</code> instead. Because BrowserModule’s providers are for the entire app so it should only be in the root module, not in feature module. Whereas Feature modules only need the common directives in CommonModule.</p>"
            },
            {
                "name": "How to set ngFor and ngIf on the same element?",
                "description": "<p><strong>ngFor</strong> and <strong>ngIf</strong> on the same element will unfortunately throw a template parse error. i.e. <br><strong>Template parse errors: Can't have multiple template bindings on one element.</strong><br><br>In this case, You need to either use ng-container or ng-template.<br><img src='./assets/angular/iffor.png'></p>"
            },
            {
                "name": "ng-template, ng-content, ng-container, and *ngTemplateOutlet?",
                "description": "<p><strong>ng-template</strong>: As the name suggests the <ng-template> is a template element that Angular uses with structural directives (*ngIf, *ngFor, [ngSwitch] and custom directives).These template elements only work in the presence of structural directives.<br><br><strong>ng-container</strong>: The Angular <ng-container> is a grouping element that doesn't interfere with styles or layout because Angular doesn't put it in the DOM. It is especially helpful when you want to apply two structural directives to the same element.Example - *ngIf and *ngFor on same element.<br><br><strong>ng-content</strong>: is used to project content into Angular components. In plain HTML, you can create children in any element, like this:</p><br><img src='./assets/angular/ngcontent.png'><p>If instead of divs you do something similar with Angular components, your child div won't be displayed... except if you tell Angular where to display it in the parent template using ng-content.. this in technical terms is known as 'Content Projection'</p><br><img src='./assets/angular/ngcontent1.png'><br><br>Output<br><img src='./assets/angular/ngcontent2.png'>"
            },
            {
                "name": "What is host property in css?",
                "description": "<p>The <code>:host</code> pseudo-class selector is used to target styles in the element that hosts the component. Since the host element is in a parent component's template, you can't reach the host element from inside the component by other means. For example, you can create a border for parent element as below,<br><img src='./assets/angular/hostcss.png'></p>"
            },
            {
                "name": "Sharing/Communicating Data between Angular Components",
                "description": "<p>There are Four Methods</p><ul><li><strong>Parent to Child: Sharing Data via Input:</strong> This is probably the most common and straightforward method of sharing data. It works by using the <code>@Input()</code> decorator to allow data to be passed via the template.<br><img src='./assets/angular/parent.png'><br><img src='./assets/angular/child.png'></li><li><strong>Child to Parent: Sharing Data via ViewChild:</strong> ViewChild allows a one component to be injected into another, giving the parent access to its attributes and functions. However, in that child won't be available until after the view has been initialized. This means we need to implement the AfterViewInit lifecycle hook to receive the data from the child.<br><img src='./assets/angular/parent1.png'><br><img src='./assets/angular/child1.png'></li><li><strong>Child to Parent: Sharing Data via Output() and EventEmitter:(aka - Two-Way Data Binding)</strong> Another way to share data is to emit data from the child, which can be listed to by the parent. This approach is ideal when you want to share data changes that occur on things like button clicks, form entires, and other user events.<br><br>In the parent, we create a function to receive the message and set it equal to the message variable.<br><br>In the child, we declare a messageEvent variable with the Output decorator and set it equal to a new event emitter. Then we create a function named sendMessage that calls emit on this event with the message we want to send. Lastly, we create a button to trigger this function.<br><br>The parent can now subscribe to this messageEvent that's outputted by the child component, then run the receive message function whenever this event occurs.<br><img src='./assets/angular/parent2.png'><br><img src='./assets/angular/child2.png'></li><li><strong>Unrelated Components: Sharing Data with a Service:</strong>: When passing data between components that lack a direct connection, such as siblings, grandchildren, etc, you should you a shared service. When you have data that should aways been in sync, I find the <code>RxJS BehaviorSubject</code> very useful in this situation.<br><br>In the service, we create a private BehaviorSubject that will hold the current value of the message. We define a currentMessage variable handle this data stream as an observable that will be used by the components. Lastly, we create function that calls next on the BehaviorSubject to change its value.<br><br>The parent, child, and sibling components all receive the same treatment. We inject the DataService in the constructor, then subscribe to the currentMessage observable and set its value equal to the message variable.<br><br>Now if we create a function in any one of these components that changes the value of the message. when this function is executed the new data it's automatically broadcast to all other components.<br><img src='./assets/angular/shareddataservice.png'><br><img src='./assets/angular/parent3.png'><br><img src='./assets/angular/sibling.png'></li></ul>"
            },
            {
                "name": "In Parent to child component communication. Suppose an object have two properties only change in one property in parent, Will change reflect in the child component?",
                "description": "<p>Yes, By Using OnPush change detection strategy for specific components in Angular. This will instruct Angular to run change detection on these components and their sub-tree only when new references are passed to them versus when data is mutated. </p>"
            },
            {
                "name": "What is a component factory resolver?",
                "description": "<p>A factory is a type with a single method that returns a new component instance each time it is called. The parameters of that method allow the caller to provide the modules, dependencies and bound instances required by the component. <br><br>Where as A <strong>component factory resolver</strong> is a registry that maps Components to generated ComponentFactory classes that can be used to create instances of components.</p>"
            },
            {
                "name": "Explain Styling precedence",
                "description": "<p>When there are multiple bindings to the same class name or style attribute, Angular uses a set of precedence rules to determine which classes or styles to apply to the element. These rules specify an order for which style and class related bindings have priority.</p><ul><li><strong>Template bindings</strong> are the most specific because they apply to the element directly and exclusively, so they have the highest precedence.<br><br><strong>Property binding</strong> - &lt;div [class.foo]=\"hasFoo\"&gt; / &lt;div [style.color]=\"color\">&gt;<br><strong>Map binding</strong> - &lt;div [class]=\"classExpression\"&gt; / &lt;div [style]=\"styleExpression\"&gt;<br><strong>Static value</strong> - &lt;div class=\"foo\"&gt; / &lt;div style=\"color: blue\"&gt;<br><br></li><li><strong>Directive host bindings</strong> are less specific because you can use directives in multiple locations, so they have a lower precedence than template bindings. <br><br><strong>Property binding</strong> - host: {'[class.foo]': 'hasFoo'} / host: {'[style.color]': 'color'} <br><strong>Map binding</strong> - host: {'[class]': 'classExpr'} / host: {'[style]': 'styleExpr'} <br><strong>Static value</strong> - host: {'class': 'foo'} / host: {'style': 'color: blue'}<br><br></li><li><strong>Component host bindings</strong> have the lowest precedence. <br><br><strong>Property binding</strong> - host: {'[class.foo]': 'hasFoo'} / host: {'[style.color]': 'color'}<br><strong>Map binding</strong> - host: {'[class]': 'classExpression'} / host: {'[style]': 'styleExpression'} <br><strong>Static value</strong> - host: {'class': 'foo'} / host: {'style': 'color: blue'}</li>"
            },
            {
                "name": "Difference between @Attribute() vs @Input()?",
                "description": "<p><strong>@Input():</strong> Used to pass values into the directive or to pass data from one component to another (typically parent to child).<br><br><strong>@Attribute():</strong> we can map the constant value of an attribute on html to a property on your component.<br><br>In Short - one is declared as parameter in the constructor and one is declared as property.</p>"
            },
            {
                "name": "Template type checking in custom directive?",
                "description": "<p>To support type checking, we will need to work with two handy type guards provided by Angular:</p><ul><li><strong>ngTemplateContextGuard</strong>: Declare a custom type for the context of our custom directive.</li><li><strong>ngTemplateGuard_[customInputProperty]</strong>: Narrow the rendered type of an input property.</li></ul><br><br><p><strong>ngTemplateContextGuard</strong><br>If we need to provide a context to our custom directive, we can ensure it is properly typed in the template using the static function <strong>ngTemplateContextGuard</strong>. It works like a Typescript type guard function and returns a type predicate.<br>Let's look at an example to better understand the concept.<br><br><br><img src='./assets/expertAngular/ngTemplateContextGuard.png'><br><img src='./assets/expertAngular/ngTemplateContextGuard1.png'><br><img src='./assets/expertAngular/ngTemplateContextGuard2.png'><br><br><code>The ngTemplateContextGuard returns true since this directive will always pass a context of type DemoContext to the template.</code><br><br>Now when we use this directive in our template, we get nice correctly typed properties.<br><img src='./assets/expertAngular/ngTemplateContextGuard3.png'></p><br><br><p><strong>ngTemplateGuard_[customInputProperty]</strong><br><p>This guard is a bit more complex to understand. A structural directive controls how a template will be rendered at runtime. <em>(NgIf for example, will add a template to the DOM only if the input condition is thrustly.)</em></p><br><br>If the input of our custom directive has a complex type and the directive will only render the template when certain condition are met, we can narrow the rendered type with this guard.</p>"
            },
            {
                "name": "How to disable type checking on template expression?",
                "description": "<ul><li>Use the <code>$any()</code> type-cast function in certain contexts to opt out of type-checking for a part of the expression</li><li>Disable strict checks entirely by setting <code>strictTemplates: false</code> in the application's TypeScript configuration file, <code>tsconfig.json</code></li><li>Disable certain type-checking operations individually, while maintaining strictness in other aspects, by setting a <em>strictness flag</em> to <code>false</code></li><li>If you want to use <code>strictTemplates</code> and <code>strictNullChecks</code> together, opt out of strict null type checking specifically for input bindings using <code>strictNullInputTypes</code></li></ul>"
            },
            {
                "name": "Describe 3 Mode of template type checking?",
                "description": "<p>With Angular 9, there are 3 different template type checking \"modes\" or \"levels\":</p><ul><li><strong>Basic</strong> - This mode mostly works in the same way as the previous versions of Angular; it will only check top-level expressions in your templates (e.g., fields & properties that you use exist on the component class). Honestly, this level of type checking is really <code>weak</code>. The basic mode is enabled when the <strong><code>fullTemplateTypeCheckflag</code></strong> is set to <strong><code>false</code></strong>.</li><li><strong>Full</strong> - If you enable the \"full\" mode, then Angular will be more careful and it'll also type check things like pipes and embedded views (created when you use things like ngIf, ngFor, ng-template, etc). Overall, this mode provides additional safety, but who likes half measures? To enable it, set the  <strong><code>fullTemplateTypeCheckflag</code></strong> to <strong><code>true</code></strong>.</li><li><strong>Strict</strong> - Finally, the new \"strict\" mode enforces full template type checking and catches many more errors at build time. In strict mode, the \"full\" mode checks are enabled and, in addition, many more things are checked: <ul><li>component bindings and assignability (obeying TypeScript's strictNullChecksflag)</li><li>types of components and directives (including generics!)</li><li>context types (e.g., allowing to fully type check ngFor loops)</li><li>event objects (i.e., $event) for components, directives, DOM & animation bindings</li><li>type of references to DOM elements</li><li>(and probably more)</li></ul></li></ul><p>To enable the strict mode, you just have to set the <strong><code>strictTemplates</code></strong> flag to <strong><code>true</code></strong>. Note that these flags are configured in your “tsconfig.json” file:<br><br><img src='./assets/expertAngular/tsconfig.png'></p>"
            },
            {
                "name": "What happens if assign template local reference variable on ng-template?",
                "description": "<p>If you declare the variable on an  element, the variable refers to a TemplateRef instance which represents the template.<br><br><strong>ng-template with ngIf, then & else</strong> In the *ngIf condition we specify the template to render by pointing to the template variable to the then & else condition.<br><br>Here we use the ng-template specify the template for the then & else clause. We use the template reference variable to get the reference to those blocks.<br><img src='./assets/expertAngular/ngTemplateIf.png'><br><br><strong>ng-template with ngFor</strong><br><img src='./assets/expertAngular/ngTemplateFor.png'><br><br><strong>ng-template with ngSwitch</strong><br><img src='./assets/expertAngular/ngTemplateSwitch.png'></p>"
            },
            {
                "name": "What is Template Reference Variable",
                "description": "<p>The <strong>Template reference variable</strong> is a reference to any DOM element, component or a directive in the Template. We can use it elsewhere in the template. We can also pass it to a method in the component. It can contain a reference to elements like h1, div, etc.<br><br>We declare Template reference variables using <code>#</code> followed by the name of the variable ( <code>#variable</code>). We can also declare them using <code>#variable=\"customer\"</code> when the component/directive defines a customer as the <code>exportAs</code> Property.<br><br><strong>HTML Element</strong><br>&lt;input type=\"text\" #firstName&gt; <br><br><strong>Component/Directive</strong><br>&lt;app-customer #customerList=”customer”&gt;&lt;/app-customer&gt;</p>"
            },
            {
                "name": "Is angular selector support parent child relationship ?",
                "description": "<p>Yes, there are different ways to call selectors in parent child component</p><ul><li><strong>Using selector as HTML tag</strong> - In this selector of child component is used in the parent component i.e. app component in this case, as normal HTML tag. Example - &lt;app-wheels&gt;&lt;/app-wheels&gt;</li><li><strong>Using selector as Class</strong> - Include child component by using selector as class name. This way will require some changes in selector metadata of the component.ts file of child. <br>A \". \"(dot) is needed to be add to use selector as class name. It is similar to the way we define CSS class, e.g. \".btn-group\" <br><img src='./assets/expertAngular/selectorClass.png'><br>Now the child component can be included in the parent using class name like this. <br>&lt;div class=\"app-wheels\"&gt;&lt;/div&gt;</li><li><strong>Using selector as Directive</strong> - To use selector as directive, change is required in the selector of the child component. Selector name need to be closed in square bracket, just like in case of property binding. <br><img src='./assets/expertAngular/selectorDirective.png'><br>Now the child component can be included in the parent using directive like this.&lt;div app-wheels&gt;&lt;/div&gt;</li></ul>"
            },
            {
                "name": "Explain Hostbinding, Hostlistener?",
                "description": "<p><code>@HostBinding</code> and <code>@HostListener</code> are two decorators in Angular that can be really useful in custom directives. <code>@HostBinding</code> lets you set properties on the element or component that hosts the directive, and <code>@HostListener</code> lets you listen for events on the host element or component. <br><img src='./assets/expertAngular/host.png'><br><br>And the directive can be used on elements like this: <br><img src='./assets/expertAngular/host1.png'><br><br>Our <code>Rainbow</code> directive uses two <code>@HostBinding</code> decorators to define two class members, one that's attached to the host's <code>style.color</code> binding and the other to <code>style.border-color</code>. You can also bind to any class, property, or attribute of the host.</p><ul><li><code>@HostBinding('class.active')</code></li><li><code>@HostBinding('disabled')</code></li><li><code>@HostBinding('attr.role')</code></li></ul>"
            },
            {
                "name": "Write the syntax for ngClass use cases?",
                "description": "<p>There are two ways to use this directive, the first is by passing an object literal to the directive,<br><br>Syntax - [ngClass]=\"{'text-success':true}\" <br>Example - [ngClass]=\"{'text-success':person.country === 'UK'}\" <br><img src='./assets/expertAngular/ngClass.png'><br><br>We can also set a class on an element by binding to the input property binding called class<br><br>Syntax - [class.text-success]=\"true\" <br>Example - [class.card-success]=\"person.country === 'UK'\" <br><img src='./assets/expertAngular/ngClass1.png'></p>"
            },
            {
                "name": "Tell the use case of ngModelChange ?",
                "description": "<p><strong>ngModelChange</strong> is the <code>@output</code> property of <code>ngModel</code> directive. and it's specific to Angular framework. Hence we need to use it along with it.<br><br>ngModel raises the NgModelChange event, which is why it is used to track the changes happened to ngModel property.<br><br><strong>NgModelChange Vs Change</strong></p><table><thead><tr><th>ngModelChange</th><th>onChange</th></tr></thead><tbody><tr><td>ngModelChange is an Angular Event</td><td>change event is classic HTML DOM event independent of Angular</td></tr><tr><td>We cannot use ngModelChange without <code>ngModel</code></td><td>change event is not related to two way binding we can use it on any HTML form element</td></tr><tr><td>ngModelChange event is called on each input change</td><td>change event is called only when focus move away from the element</td></tr><tr><td>ngModelChange parameter contains the changed value</td><td>change contains event parameter, to access the changed value we need to use e.target.value</td></tr><tr><td>ngModelChange triggered when a change happened to ngModel irrespective of focus of the element.</td><td>change event triggers when the user changes the input.(depends on focus of the element)</td></tr></tbody></table>"
            },
            {
                "name": "How to host a directive without Dom?",
                "description": "Use &lt;ng-container&gt;, as it doesn't interfere with styles or layout because Angular doesn't put it in the DOM. As a use case of this it can act as the host to structural directives like *ngIf, *ngFor"
            },
            {
                "name": "What is ElementRef use?",
                "description": "<p>Angular <strong>ElementRef</strong> is a wrapper around a native DOM element (HTML element) object. It contains the property <code>nativeElement</code>, which holds the reference to the underlying DOM object. We can use it to manipulate the DOM. We use the ViewChild to get the ElementRef of an HTML element in the component class. <br>Angular also inject <strong>ElementRef</strong> of the Host element of the component or directive when you request for it in the constructor. <br><br> 2nd Definition  - Angular <strong>ElementRef</strong> is simply a class that wraps native DOM elements in the browser and allows you to work with the DOM by providing the nativeElement object which exposes all the methods and properties of the native elements. </p><ul><li><strong>Getting ElementRef in Component Class</strong> - <br>In HTML - &lt;div #hello&gt;Hello Angular&lt;/div&gt; <br>In Component - @ViewChild('hello', { static: false }) divHello: ElementRef;</li><li><strong>Read token</strong> - <br>In HTML - &lt;input #nameInput [(ngModel)]=\"name\"&gt;<br>//ViewChild returns ElementRef i.e. input HTML Element <br>@ViewChild('nameInput',{static:false, read: ElementRef}) elRef;<br><br>//ViewChild returns NgModel associated with the nameInput<br>@ViewChild('nameInput',{static:false, read: NgModel}) inRef;</li><li><strong>ElementRef in Custom Directive</strong> - <br><img src='./assets/expertAngular/elementRef.png'></li><li><strong>ElementRef & XSS Injection Attack</strong> - <br><img src='./assets/expertAngular/elementRef1.png'></li></ul>"
            },
            {
                "name": "How to stop/Deactivate the processing of directive or binding ?",
                "description": "<p>We use <strong>ngNonBindable</strong> when we want tell Angular not to compile, or bind, a particular section of our page. <br>Example - This {{ 5+5 }} expression will result 10 in the brower , now If I pass &lt;pre ngNonBindable&gt;{{ 5+5 }}&lt;/pre&gt; will result {{ 5+5 }} in the browser</p>"
            },
            {
                "name": "How to provide an alternative / alias Class provider?",
                "description": "<p>You can then use the Inject using the @Inject method<br><br><img src='./assets/expertAngular/inject.png'><br><img src='./assets/expertAngular/inject1.png'><br><br>This way I'll have the instance of MyAnotherService injected by MyService while having the interface of MyAnotherService.</p>"
            },
            {
                "name": "What is Resolution Modifiers?",
                "description": "<p>@Self, @SkipSelf, @Optional & @Host are Angular Decorators that configure how the DI Framework should resolve the dependencies. These decorators are called Resolution Modifiers because they modify the behavior of injectors.<br><br><strong>Example</strong> - The Code contains a RandomService, which generates a Random Number when initialized. The Angular Service is added to the Providers array of the AppModule. We can inject this service anywhere in our Application. <br><img src='./assets/expertAngular/injectableRoot.png'><br>The project contains three Angular Components (AppComponent, ChildComponent & GrandChildComponent) all inject the RandomService and displays the Random Number from the Service. <br>We also have testDirective, which we include in the template of GrandChildComponent. It also displays the Random Number from the Service. <br>Ensure that the Providers array is empty in all components & directives. Run the App. Angular creates only one instance of the RandomService. That is why all the components and directives show the same number. <br><img src='./assets/expertAngular/Self-SkipSelf-Optional-Host-Angular-Example.png'><br><br><strong>@Self</strong> - The <strong>@Self</strong> decorator instructs Angular to look for the dependency only in the local injector. The local injector is the injector that is part of the current component or directive. <br>Open the <code>GrandChildComponent</code> and add the <strong>@Self()</strong> on <code>randomService</code><br><img src='./assets/expertAngular/self.png'><br>This forces the Angular DI Framework to look for the Dependency attached to the current Component. Since it does find one it will throw the error <br><img src='./assets/expertAngular/noProvider.png'><br>Add the <code>RandomService</code> to the providers array of the <code>GrandChildComponent</code> and the error goes away.<br><img src='./assets/expertAngular/self1.png'><br>Angular creates two instances of RandomService. One from the <code>AppModule</code> and another from the <code>GrandChildComponent</code>. Also, note that <code>testDirective</code> picks up the <code>RandomService</code> provided from the <code>GrandChildComponent</code> and not from the <code>AppModule</code><br><img src='./assets/expertAngular/self2.png'></p><br><p><strong>@SkipSelf</strong> - The <code>@SkipSelf</code> decorator instructs Angular to look for the dependency in the Parent Injector and upwards. <br>It tells Angular not to look for the injector in the local injector, but start from the Parent. You can think of this decorator as the opposite of the @Self <br><img src='./assets/expertAngular/skipSelf.png'><br>the <code>GrandChildComponent</code>, picks up <code>RandomService</code> instance provided by the Module and not the one provided by itself. <br>But, the <code>testDirective</code> still picks up the <code>RandomService</code> provided by the <code>GrandChildComponent</code>.<br><img src='./assets/expertAngular/skipSelf1.png'></p><br><p><strong>@Optional</strong> - Optional marks the dependency as Optional. If the dependency is not found, then it returns <code>null</code> instead of throwing an error <br>In the <code>GrandChildComponent</code> remove the <code>RandomService</code> from the Providers Array and add the <code>@Self</code> decorator. You will instantly receive the error <strong>\"No provider for RandomService found in NodeInjector\"</strong>. <br>Also, remember to add the ? in randomService?, else you will get the “Cannot read property 'RandomNo' of null\" error.<br><img src='./assets/expertAngular/optional.png'><br><code>GrandChildComponent</code> does not receive any values, while <code>testDirective</code> picks up the <code>RandomService</code> provided by the <code>AppModule</code><br><img src='./assets/expertAngular/optional1.png'></p><br><p><strong>@Host</strong> - decorator makes Angular to look for the injector on the component itself, so in that regard it may look similar to the @Self() decorator (7.). But that's actually not the end: if the injector is not found there, it looks for the injector up to its host component.</p>"
            },
            {
                "name": "How to support PWA in angular?",
                "description": "<p><strong>Step 1</strong> - install the @angular/pwa package. The @angular/pwa package is an Angular schematics that adds Progressive Web App support to an Angular app.</p><ul><li>Automatically imports and registers the service worker in the app module.</li><li>Updates <code>index.html</code> to include the <code>manifest.json</code> file which has details about the progress web application.</li><li>Creates the icon files to support the PWA. These are place in the <code>src/assets/icons</code> folder and should be updated with the apps icon for branding purposes.</li><li>Creates <code>src/ngsw-config.json</code>. This file is used to configure the service worker.</li></ul>"
            },
            {
                "name": "What is a lightweight injection token?",
                "description": "<p>First let us understand what is Tree Shaking? - It refers to the process of removing unused code during the build phase. <br><br>For example — If we use a library that has 5 functions but in our code we only make use of 3, then in the final bundle we wont have the code for the 2 unused functions, this helps reduce bundle size and may seem like a trivial thing but in larger enterprise applications it has a lot of impact.<br><br>In order to prevent the retention of unused components it is necessary for the library author to use the lightweight token pattern. The pattern consist of using a small abstract class as injection token. Later implement that abstract class with actual implementation. The result is that the abstract class will be retained but it is small and so it has almost no impact on the application developer.<br><br>Injection of the lightweight pattern, using <strong>@ContentChild()</strong> or <strong>@ContentChildren()</strong>.</p>"
            },
            {
                "name": "Defer and Async in script tag",
                "description": "<p>With <b>async</b>, the file gets downloaded <b>asynchronously</b> and then executed as soon as it's downloaded. With <b>defer</b>, the file gets downloaded <b>asynchronously</b>, but executed only when the document parsing is completed. <b>preload</b> is a declarative fetch, allowing you to force the browser to make a request for a resource without blocking the document’s onload event. <b>Prefetch</b> is a hint to the browser that a resource might be needed, but delegates deciding whether and when loading it is a good idea or not to the browser.<br><br>With async, in the head: The script is fetched asynchronously, and when it's ready the HTML parsing is paused to execute the script, then it's resumed. <img src='./assets/angular/with-async.png'><br><br>With defer, in the head: The script is fetched asynchronously, and it's executed only after the HTML parsing is done. <img src='./assets/angular/with-defer.png'><br><br>No defer or async, in the head: The parsing is paused until the script is fetched, and executed. Once this is done, parsing resumes. <img src='./assets/angular/without-defer-async-head.png'><br><br>No defer or async, in the body: The parsing is done without any pauses, and when it finishes, the script is fetched, and executed. Parsing is done before the script is even downloaded, so the page appears to the user way before the previous example. <img src='./assets/angular/without-defer-async-body.png'></p>"
            },
            {
                "name": "How to optimize angular application?",
                "description": "<p><strong>#1. OnPush change detection strategy:</strong> Change detection is one of the most common features in Angular frameworks. This is the ability to detect when the user’s data have changed or altered then, update the DOM to reflect the changes. <br><br><strong>#2. Cache values from pure pipes and functions:</strong> Even when using pure pipes, we can optimize this further by remembering/caching previous values, so we don’t need to recompute if we already run the pipe with the same input in the past. <br><br><strong>#3. Using trackBy in ngFor:</strong> The trackBy function allows you to provide Angular with a function used for evaluating, which item has been updated or removed from the ngFor list, and then only rerender that item instead of re-rendering the entire list which is the by-default behavior of Angular. <br><br><strong>#4. For heavy computations: Detach change detection:</strong> if a component is instantiated 100’s of times on the same page and rerendering every one of them is expensive you can turn off automatic change detection completely for the component and only trigger changes manually in the places it is necessary. <br><br><strong>#5. Improving page load:</strong> Every millisecond a user is waiting, potentially means a loss in revenue, because of a higher bounce rate and worse user experience, so this is a place you should optimize. Page load time also has an impact on SEO, as faster websites are rewarded by search engines. For improving page load we want to use caching using Angular PWA, lazy loading and bundling. <br><br><strong>#6. Cache static content using Angular PWA:</strong> Caching the static content such as the js, css bundles, images and static served files - will make your Angular app load faster as it will already be in the browser. <br><br><strong>#7. Cache HTTP calls:</strong> Using HTTPInterceptors <br><br><strong>#8. Lazy load routes:</strong> Lazy loading routes will make sure that a feature will be bundled in its own bundle and that this bundle can be loaded when it is needed. <br><br><strong>#9. Further Optimizing bundling and preloading:</strong> To optimize page load even further you can choose to preload the feature modules, so navigation is instant when you want to render a lazily loaded feature module. <br><br><strong>#10. Server-side rendering with Angular Universal:</strong> It is recommended to server-side render the app which make sure the pages are being fully rendered by the server before shown to the browser which will give a faster page load. </p>"
            },
            {
                "name": "What is challenging work you have done in angular?",
                "description": "<p>Cache Heavy resources file such as video/audio to reduce Slow page load<br><br>Reduce the traffic request by caheing response and retrive data through cache<br><br>Implementation of Etag- which validates that whatever CRUD action is performed by the username is only done from one system where it is logged in and should not be duplicate that same CRUD action from another system with that same username<br><br>Automating prevention of performance problems by Creating lint rules</p>"
            },
            {
                "name": "What is webpack?",
                "description": "<p>webpack is a static module bundler for modern JavaScript applicationsIn webpack you configure the following:</p><ul><li><strong>Entry</strong>: the module where webpack should start</li><li><strong>Output</strong>: where webpack emits the <em>bundles</em> it creates</li><li><strong>Loaders</strong>: enable webpack to process more than just JavaScript files</li><li><strong>Plugins</strong>: perform a wide range of tasks like minification</li></ul>"
            },
            {
                "name": "What is HMR? ( Hot Module Replacement )",
                "description": "<p>Hot Module Replacement (HMR) is a key webpack feature that is not enable by default in Angular. It allows for modules to be replaced without need for a full browser refresh. This allows you to retain much of the application state, usually lost when reloading. Angular 11 made it easy to use HMR by providing it out-of-box in the CLI.</p>"
            },
            {
                "name": "What mean by uglification?",
                "description": "<p>This step comes after Minification was done to any file and further we want to reduce the size of the file?<br><br>The beautiful variable, parameter names present in any functions which are only made inorder for the code readability can be reduced to one or two letter variables. This process converts beautiful, human understandible variable names into ugly ones. Hence this process is called ‘Uglification’.<br><br>In Angular, This happens only in the build produced in ‘prod’ mode but not ‘dev’ mode.</p>"
            },
            {
                "name": "What type of DOM does Angular implement? ",
                "description": "<p>DOM (Document Object Model) treats an XML or HTML document as a tree structure in which each node is an object representing a part of the document.<br><br>Angular uses the regular DOM. This updates the entire tree structure of HTML tags until it reaches the data to be updated. However, to ensure that the speed and performance are not affected, Angular implements Change Detection.</p>"
            },
            {
                "name": "What is Reactive Programming and how to use one with Angular?",
                "description": "<p>Reactive programming is programming with asynchronous data streams. RxJs stands for Reactive Extensions for Javascript, and it's an implementation of Observables for Javascript. An Observable is like a Stream (in many languages) and allows to pass zero or more events where the callback is called for each event. Angular currently uses RxJs Observables in two different ways:</p><ul><li>as an internal implementation mechanism, to implement some of its core logic like <code>EventEmitter</code></li><li>as part of its public API, namely in <code>Forms</code> and the <code>HTTP module</code></li></ul>"
            },
            {
                "name": "Explain what annotations are in Angular?",
                "description": "<p>Annotation is a block of text that can be displayed over a node or connector. Annotation is used to textually represent an object with a string that can be edited at runtime</p>"
            },
            {
                "name": "Explain what view encapsulation is in Angular?",
                "description": "<p>View encapsulation defines whether the template and styles defined within the component can affect the whole application or vice versa. Angular provides three encapsulation strategies:</p><ul><li><code>Emulated (default)</code> - styles from main HTML propagate to the component. Styles defined in this component's <code>@Component</code> decorator are scoped to this component only.</li><li><code>ShadowDom</code> - styles from main HTML do not propagate to the component. Styles defined in this component's <code>@Component</code> decorator are scoped to this component only.</li><li><code>None</code> - styles from the component propagate back to the main HTML and therefore are visible to all components on the page. Be careful with apps that have <code>None</code> and <code>Native</code> components in the application. All components with <code>None</code> encapsulation will have their styles duplicated in all components with <code>Native</code> encapsulation</li></ul><br><p><img src='./assets/angular/viewNone.png'></p>"
            },
            {
                "name": "Why angular uses url segment?",
                "description": "<p>A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix parameters associated with the segment.<br><br>Matrix parameters are tied to a path segment, while query parameters are tied to the URL. They have different semantics.<br><br><img src='./assets/angular/urlsegment.png'><br><br>With an Angular app, the only people who really care about these parameters are us the developer. The user doesn't care. It is not a REST API where we should stick to well known semantics. For out Angular app, as long as we the developer know how to use params (whether matrix or query), it shouldn't matter which one we use.</p>"
            },
            {
                "name": "Explain MVC architecture.",
                "description": "<p>The Model-View-Controller (MVC) framework is an architectural/design pattern that separates an application into three main logical components <strong>Model, View, and Controller</strong>.<br><br><strong>Components of MVC :</strong></p><ul><li><strong>Controller</strong>: The controller is the component that enables the interconnection between the views and the model. It process all the business logic and incoming requests, manipulate data using the <strong>Model</strong> component and interact with the <strong>View</strong> to render the final output.</li><li><strong>Model</strong>: corresponds to all the data-related logic that the user works with. This can represent either the data that is being transferred between the View and Controller components or any other business logic-related data. It can add or retrieve data from the database.</li><li><strong>View</strong>: The View component is used for all the UI logic of the application. It generates a user interface for the user. Views are created by the data which is collected by the model component since it only interacts with the Controller</li></ul><br><br><p><strong>Features of MVC :</strong></p><ul><li>It provides a clear separation of <strong>business logic, Ul logic, and input logic.</strong></li><li>Easy planning and maintenance</li><li>Organizes large-size web applications because it makes it easier to locate certain code sections and add new functionality quickly.</li><li>Faster development process</li><li>Easily modifiable by allowing adding and updating new views</li><li>It supports <strong>Test Driven Development (TDD).</strong></li><li>SEO-friendly development platform</li></ul><br><br><p><strong>Disadvantages of MVC</strong></p><ul><li>the complexity in&nbsp;code navigation (with all updates, the structure becomes more complex),</li><li>the cost of frequent changes and updates,</li><li>MVC pattern can be&nbsp;hard to&nbsp;understand due to&nbsp;the complexity and updates,</li><li>MVC must have strict rules over methods (appropriate reactions from Controller),</li><li>developers need to&nbsp;know multiple technologies in&nbsp;order to&nbsp;understand and use MVC.</li></ul>"
            },
            {
                "name": "Explain MVVM architecture.",
                "description": "<p><strong>MVVM architecture</strong> is an architectural pattern used mainly in software engineering. It stands for <strong>Model-View-ViewModel</strong>. MVVM is a variation of the traditional MVC (Model-View-Controller) software design pattern. The main difference between the two is that MVVM separates the user interface logic from the business logic, while MVC separates the data access logic from the business logic.<br><br>The Model layer in MVVM architecture is responsible for storing and managing data. It can be a database, a web service, or a local data source. The View layer is responsible for displaying data to the user. It can be a graphical user interface (GUI), a command-line interface (CLI), or a web page. The ViewModel layer is responsible for handling user input and updating the View layer accordingly. It contains the business logic of the application.</p>"
            },
            {
                "name": "Do you know how you can run angularJS and angular side by side?  ",
                "description": "<p>In order to run both frameworks side-by-side and make components interoperable, the Angular projects comes with a module <strong>ngUpgrade</strong>. The module basically acts as an adapter facade, so we don't really feel that there are two frameworks running side-by-side.<br><br>For this to work, four things need to interoperate:</p><ul><li>Dependency Injection - Exposing Angular services into Angular 1.x components and vice-versa.</li><li>Component Nesting - Angular 1 directives can be used in Angular 2.x components and Angular 2.x components can used Angular 1 directives</li><li>Content Projection / Transclusion - Angular 1 components transclude Angular 2.x components and Angular 2.x component project Angular 1 directives</li><li>Change Detection - Angular 1 scope digest and change detectors in Angular &gt;= 2.x are interleaved</li></ul><p>Here's what a typical upgrade process would look like:</p><ul><li>Include Angular and upgrade module</li><li>Pick component to upgrade and change its controller and template Angular 2.x syntax (this is now an Angular 2.x component)</li><li>Downgrade Angular 2.x component to make it run in Angular 1.x app</li><li>Pick a service to upgrade, this usually requires little amount of change (especially if we’re on ES2015)</li><li>Repeat step 2 and 3 (and 4)</li><li>Replace Angular 1 bootstrap with Angular 2.x bootstrap</li></ul>"
            },
            {
                "name": "When to use query parameters versus matrix parameters?",
                "description": "<p><strong>Problem</strong></p><ul><li>Query parameters: http://example.com/apples?order=random&amp;color=blue</li><li>Matrix parameters: http://example.com/apples;order=random;color=blue</li></ul><p><strong>Answer</strong><br><br>The differences between Matrix parameters and Query Parameters are much more than just convention.<br><br>The main differences are:</p><ul><li>urls with query params won't have their response cached by intermediaries/proxies (at present)</li><li>matrix parameters may appear anywhere in path</li><li>calculating the relative uri is different</li><li>query params are generally abused to add new verbs instead of using existing methods on resources</li><li>matrix parameters are not resources, they are aspects that help reference a resource in an information space that is difficult to represent within a hierarchy</li></ul>"
            },
            {
                "name": "How would you control size of an element on resize of the window in a component?",
                "description": "<p><code>@HostListener</code> lets you listen for events on the host element or component.<br><br>This is a function decorator that accepts an event name as an argument. When that event gets fired on the host element it calls the associated function.<br><br>Consider:<br><br><img src='./assets/angular/resizewindowcomponent.png'></p>"
            },
            {
                "name": "What is package.json and package.lock.json?",
                "description": "<p>The package.json is used for more than dependencies - like defining project properties, description, author & license information, scripts, etc.<br><br>The package-lock.json is solely used to lock dependencies to a specific version number.<br><br>The package-lock.json is automatically generated for the project- where npm modifies either the node_modules tree, or package.json.</p>"
            },
            {
                "name": "What Is the Single Page Application(SPA)? How Is It Different From Traditional Web Technology?",
                "description": "<p>In a single page application (SPA), only the home page (index.html) is maintained throughout the application, even though the URL keeps on changing. In traditional technology, every time a user makes a request, the request is passed on to the server which takes more time. It is faster and easier to implement when compared with traditional web technology.</p>"
            },
            {
                "name": "What is progressive rendering?",
                "description": "<p><em>Progressive rendering</em> is the name given to techniques used to improve the performance of a webpage (in particular, improve perceived load time) to render content for display as quickly as possible.<br><br>Examples of such techniques:</p><ul><li>Lazy loading of images - Images on the page are not loaded all at once. JavaScript will be used to load an image when the user scrolls into the part of the page that displays the image.</li><li>Prioritizing visible content (or above-the-fold rendering) - Include only the minimum CSS/content/scripts necessary for the amount of page that would be rendered in the users browser first to display as quickly as possible, you can then use deferred scripts or listen for the <code>DOMContentLoaded</code>/<code>load</code> event to load in other resources and content.</li><li>Async HTML fragments - Flushing parts of the HTML to the browser as the page is constructed on the back end.</li></ul>"
            }
        ]
    }
]