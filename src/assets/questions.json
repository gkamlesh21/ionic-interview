[
    {
        "folder": "JavaScript",
        "title": "JavaScript",
        "url": "/folder/JavaScript",
        "icon": "logo-javascript",
        "question": [
            {
                "name": "What are the different data types present in javascript?",
                "description": "<ol><li><strong>Primitive types</strong> - Primitive data types can store only a single value. <ol><li><strong>String</strong> - It represents a series of characters and is written with quotes. A string can be represented using a single or a double quote.</li><li><strong>Number</strong> - It represents a number and can be written with or without decimals.</li><li><strong>Boolean</strong> - It represents a logical entity and can have only two values : true or false. Booleans are generally used for conditional testing. </li><li><strong>Undefined</strong> - When a variable is declared but not assigned, it has the value of undefined and it’s type is also undefined</li><li><strong>Null</strong> - It represents a non-existent or a invalid value.</li></ol></li><li><strong>Non Primitive type</strong> - To store multiple and complex values, non-primitive data types are used. <ol><li><strong>Object</strong> - Used to store collection of data.</li></ol></li></ol>"
            },
            {
                "name": "What are the possible ways to create objects in JavaScript",
                "description": "<ol><li><strong>Object literal syntax:</strong> - comma-separated set of name-value pairs wrapped in curly braces. <br><pre>var object = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: \"Kamlesh\",<br>&nbsp;&nbsp;&nbsp;&nbsp;age: 34 <br>};</pre></li><li><strong>Function constructor:</strong> - Create any function and apply the new operator to create object instances,<br><br><img src='./assets/js/objectfunction.png'><br><br></li><li><strong>Function constructor with prototype:</strong> - This is similar to function constructor but it uses prototype for their properties and methods, <br><pre>function Person() {}<br>&nbsp;&nbsp;&nbsp;&nbsp;Person.prototype.name = \"Kamlesh\";<br>&nbsp;&nbsp;&nbsp;&nbsp;var object = new Person();</pre></li><li><strong>Object's create method:</strong> - The create method of Object creates a new object by passing the prototype object as a parameter <br><pre>var object = Object.create(null);<br>&nbsp;&nbsp;&nbsp;&nbsp;a.name = \"Kamlesh\"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;// '{name: \"Kamlesh\"}'</pre></li><li><strong>Object constructor:</strong> - create an empty object is using the Object constructor <br><pre>var object = new Object();<br>&nbsp;&nbsp;&nbsp;&nbsp;a.name = \"Kamlesh\"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(a)<br>&nbsp;&nbsp;&nbsp;&nbsp;// '{name: \"Kamlesh\"}'</pre></li><li><strong>ES6 Class syntax:</strong> - ES6 introduces class feature to create the objects <br><pre>class Person {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>} <br><br>var object = new Person(\"Kamlesh\");</pre></li><li><strong>Singleton pattern:</strong>  - A Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance and this way one can ensure that they don't accidentally create multiple instances. <br><pre>var object = new (function () {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = \"Kamlesh\";<br>})();</pre></li></ol>"
            },
            {
                "name": "What is Hoisting?",
                "description": "<p>Hoisting is a JavaScript mechanism where variables, function and class declarations are moved to the top of their scope before code execution.<br><br><img src='./assets/js/hoisting.png'><br><br><strong>Note</strong> that JavaScript only hoists declarations, not initialisation. Variables declared or initialized with the var keyword will have their declaration 'moved' up to the top of their module/function-level scope, which we call as hoisting. However, only the declaration is hoisted, the assignment (if there is one), will stay where it is.</p>"
            },
            {
                "name": "What are the tools or techniques used for debugging JavaScript code",
                "description": "<ol><li>Chrome Devtools</li><li>debugger statement</li><li>Good old console.log statement</li></ol>"
            },
            {
                "name": "Difference between (equality operator) == and === ?",
                "description": "<p> JavaScript has both strict and type-converting equality comparison. For strict comparison we use === and for type-converting comparison we use == .<br><br><strong>Strict Comparison(===)</strong><br>For strict comparison the items been compared must be the same type.</p><ul> <li>Two strings are strictly equal when they have the same sequence of characters, same length, and same characters in corresponding positions.<p><img src='./assets/js/equaltwostring.png'></p></li><li>Two numbers are strictly equal when they are numerically equal (have the same number value). NaN is not equal to anything, including NaN. Positive and negative zeros are equal to one another.<p><img src='./assets/js/equaltwonum.png'></p></li><li>Two Boolean operands are strictly equal if both are true or both are false.<p><img src='./assets/js/equaltwobool.png'></p></li><li>Two objects are strictly equal if they refer to the same Object.<p><img src='./assets/js/equaltwoobj.png'></p></li><li>Null and Undefined types are not equal<p><img src='./assets/js/nullundefined.png'></p></li></ul><p><strong>Type-converting comparison</strong><br>The==does a type conversion before comparing, if both items are of different types.<br><br><img src='./assets/js/equality1.png'></p>"
            },
            {
                "name": "Difference between variables created using let var or const?",
                "description": "<p><strong>#1. Variables</strong> declared using the <code>var</code> keyword are scoped to the function in which they are created, or if created outside of any function, to the global object. <code>let</code> and <code>const</code> are block scoped, meaning they are only accessible within the nearest set of curly braces (function, if-else block, or for-loop).<br><img src='./assets/js/let-var-const.png'><br><br><strong>#2.</strong> <code>var</code> allows variables to be hoisted, meaning they can be referenced in code before they are declared, where as <code>let</code> and <code>const</code> will not allow this, instead they will<strong>throw an error.</strong><br><img src='./assets/js/let-var-const1.png'><br><br><strong>#3.</strong> Redeclaring a variable with <code>var</code> will not throw an error, but <code>let</code> and <code>const</code> will throw.<br><img src='./assets/js/let-var-const2.png'><br><br><strong>#4.</strong> <code>let</code> and <code>const</code> differ to each other in a waya that <code>let</code> allows reassigning of the variable's value while <code>const</code> does not.<br><img src='./assets/js/let-var-const3.png'></p>"
            },
            {
                "name": "What is Coercion in JavaScript?",
                "description": "<p>In JavaScript conversion between different two build-in data types is called coercion. Coercion comes in two forms in JavaScript: explicit and implicit.<br><br><strong>Implicit coercion:</strong> Type coercion is the automatic or implicit conversion of values from one data type to another.<br><img src='./assets/js/implicit.png'><br><br><strong>Explicit coercion:</strong> Type conversion is done explicitly in code using the inbuilt functions like Number(), String(), Boolean(), etc<br><img src='./assets/js/explicit.png'></p>"
            },
            {
                "name": "Difference between null and undefined",
                "description": "<table><thead><tr><th>Undefined</th><th>Null</th></tr></thead><tbody><tr><td>Undefined means the variable has been declared, but its value has not been assigned.</td><td>Null means an empty value or a blank value.</td></tr><tr><td>The typeof() operator returns<strong>undefined</strong>for an undefined variable.</td><td>The typeof() operator returns the type as an<strong>object</strong>for a variable whose value is assigned as null.</td></tr><tr><td>It returns<strong>NaN</strong>on performing arithmetic operations.</td><td>converts to 0 then perform the operation</td></tr><tr><td>As there is no value assigned to the variable, it becomes undefined when we assign to a variable.</td><td>As we assign null to a variable, it becomes as assigned value of that variable.</td></tr></tbody></table>"
            },
            {
                "name": "Why JavaScript 'var null' throw error but 'var undefined' doesn't?",
                "description": "<p><strong>null (var null)</strong> - In JavaScript, null is a reserved identifier, therefore we cannot use it as an identifier in JavaScript. An error can be seen if we will write:<br><br><img src='./assets/js/null.png'><br><br>The web browser throws an error for “var null” since it is a reserved identifier, The following is the error visible<br><strong>SyntaxError: Unexpected token null </strong><br><br><strong>undefined (var undefined)</strong> - The undefined is not a reserved identifier, therefore if you will write the following, then no error would be thrown:<br><br><img src='./assets/js/undefined.png'><br><strong>Output: Undefined</strong></p>"
            },
            {
                "name": "Difference between “undefined” and “not defined”",
                "description": "<p>In JavaScript, <strong>“undefined”</strong> and <strong>“not defined”</strong> are the two separate terms related to memory space. The keyword <strong>“undefined”</strong> means there is a variable that is defined and contains space in memory without an assigned value. While <strong>“not defined”</strong> means the variable is not yet defined in the code.<br><br>Example of undefined:<br><code>var x; // declaring x<br>console.log(x); //output: undefined</code><br><br>Example of not defined:<br><code>console.log(y); // Output: ReferenceError: y is not defined</code></p>"
            },
            {
                "name": "Difference between function declaration and function expression?",
                "description": "<p>Function declaration is like most other traditional languages, but in JavaScript we use the keyword “function”.<br>In function expression we assign an anonymous function to an variable. They are very useful when we pass function as arguments to other function or return an function.<br><br><img src='./assets/js/function.png'><br><br>One of the key difference is that, we can call a function declaration even before defining it but same is not true for function expression and it will give reference error.</p>"
            },
            {
                "name": "Is JavaScript an interpreted language or compiled language?",
                "description": "<p><strong>JavaScript</strong>is a special case where you directly execute your source code. A webpage will directly execute your JavaScript. So, for that reason many people think JavaScript as a interpreted language. <strong>However there is a compilation step just before the interpretation step in JavaScript. So, JS is both compiled and interpreted language.</strong><br><br><strong>var a = 10; <br>var b = 20; <br>console.log(a+b)</strong><br><br><strong>Compilation Step</strong> – During this step the compiler mainly registers the variable declarations.<br><br>When the compiler goes to line 1, it encounters <code>var a</code> and registers it in the global scope and then goes to line 3 and registers the <code>var b</code>.<br><br><strong>Interpretation Step</strong> – During this the actual execution takes place. <br><br>the interpreter starts at line 1 and see a variable a and ask the compiler, if it have a variable “a” in Global scope and the compiler have it. So, it assigns the value 10 to it. Next the same step is repeated for line 3 and interpreter assigns 20 to variable “b”. Now once the interpreter goes to line 5, it finds console. It first looks for console at global scope from the compiler but don’t find it. So, it checks in the JavaScript global and finds it. Inside the console there are variable a and b, which it finds at global scope. It then adds them using addition operator and display the result.</p>"
            },
            {
                "name": "Is JavaScript a pass by reference or pass by value language?",
                "description": "<p>In JavaScript, <strong>primitive data types are passed by value</strong> and <strong>non-primitive data types are passed by reference.</strong><br><br><p>Pass-by-value creates a new space in memory and makes a copy of a value with Primitive data types such as string, number, boolean etc will actually create a new copy. Hence, updating one value doesn't impact the other value. i.e, The values are independent of each other.<pre>let a = 5;<br>let b = a;<br><br>b++;<br>console.log(a, b); //5, 6 </pre><br>In the above code snippet, the value of <code>a</code> is assigned to <code>b</code> and the variable <code>b</code> has been incremented. Since there is a new space created for variable <code>b</code>, any update on this variable doesn't impact the variable <code>a</code>.<br><br><br>where as Pass by reference doesn't create a new space in memory but the new variable adopts a memory address of an initial variable. Non-primitives such as objects, arrays and functions gets the reference of the initiable variable. i.e, updating one value will impact the other variable.<br><pre>let user1 = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: 'John',<br>&nbsp;&nbsp;&nbsp;&nbsp;age: 27<br>}; <br><br>let user2 = user1;<br>user2.age = 30;<br><br>console.log(user1.age, user2.age); // 30, 30</pre></p>"
            },
            {
                "name": "Is javascript a statically typed or a dynamically typed language?",
                "description": "<p>JavaScript is a dynamically typed language. In a dynamically typed language, the type of a variable is checked during <strong>run-time </strong>in contrast to a statically typed language, where the type of a variable is checked during <strong>compile-time.</strong><br><br>Since javascript is a loosely(dynamically) typed language, variables in JS are not associated with any type. A variable can hold the value of any data type.<br><br>For example, a variable that is assigned a number type can be converted to a string type:<br><br><pre><br>var a = 23; <br>var a = \"Hello World!\";</pre></p>"
            },
            {
                "name": "What is NaN in JavaScript?",
                "description": "<p>NaN suggests that the entered value is not a legal number. It is a JavaScript property, which can also be considered as a \"Not-a-Number\" value.<br><br>To determine the entered value is a number or not, you can use the Number.isNaN() method. If the result is “True”, then it would that the given value is not a number, whereas “False” would mean the value is a legal Number.<br><br><strong>Note - </strong> To check whether entered value is a NaN or not, use the Number.isNaN() method. This method returns <strong>true</strong> if the value is not a number, else <strong>false</strong> is returned.<br><pre><strong>var a = 'z';<br><br>isNaN(a); </strong>isNaN(\"Hello\")  // Returns true<br>isNaN(345)   // Returns false<br>isNaN('1')  // Returns false, since '1' is converted to Number type which results in 0 ( a number)<br>isNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)<br>isNaN(false) // Returns false<br>isNaN(undefined) // Returns true</pre></p>"
            },
            {
                "name": "IIFE - Immediate Invoke Function Expression",
                "description": "<p>An IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined.<br><br>It is a design pattern which is also known as a Self-Executing Anonymous Function and contains two major parts:</p><ol> <li>The first is the anonymous function with lexical scope enclosed within the <code>Grouping Operator</code> <code>()</code>. This prevents accessing variables within the IIFE idiom as well as polluting the global scope.</li><li>The second part creates the immediately invoked function expression <code>()</code> through which the JavaScript engine will directly interpret the function.</li></ol><br><br><strong>Syntax:</strong><br><pre>(function(){ <br>&nbsp;&nbsp;&nbsp;&nbsp;// Do something;<br>})();</pre>"
            },
            {
                "name": "What do you mean by strict mode in javascript and characteristics of javascript strict-mode?",
                "description": "<p>In ECMAScript 5, a new feature called JavaScript Strict Mode allows you to write a code or a function in a \"strict\" operational environment. In <strong>'Strict mode,'</strong> almost all forms of errors, including silent errors, will be thrown. As a result, debugging becomes a lot simpler.&nbsp; Thus programmer's chances of making an error are lowered.<br><br>Characteristics of strict mode in javascript</p><ol><li>Duplicate arguments are not allowed by developers.</li><li>In strict mode, you won't be able to use the JavaScript keyword as a parameter or function name.</li><li>The 'use strict' keyword is used to define strict mode at the start of the script. Strict mode is supported by all browsers.</li><li>Engineers will not be allowed to create global variables in 'Strict Mode.</li></ol>"
            },
            {
                "name": "What is a first class function?",
                "description": "<p>In Javascript, functions are first class objects. First-class functions means when functions in that language are treated like any other variable.<br><br>In such a language, a function can be passed as an argument to other functions, can be returned by another function and can be assigned as a value to a variable. For example, in the below example, handler functions assigned to a listener<br><br><img src='./assets/js/first-class.png'></p>"
            },
            {
                "name": "What is a first order function?",
                "description": "<p>First-order function is a function that doesn’t accept other function as an argument and doesn’t return a function as its return value.</p><br><img src='./assets/js/first-order.png'>"
            },
            {
                "name": "What are Higher Order Functions",
                "description": "<p>Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.<br><br><strong>Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.</strong><br><br>Higher-order functions are a result of functions being <strong>first-class citizens </strong>in javascript.<br><img src='./assets/js/hoc.png'></p>"
            },
            {
                "name": "What are callbacks?",
                "description": "<p><strong>Functions that are used as an argument to another function are called callback functions.</strong>Example:<br><img src='./assets/js/callback.png'></p>"
            },
            {
                "name": "Why do we use callbacks?",
                "description": "<p>A callback function is a method that is sent as an input to another function (now let us name this other function \"thisFunction\"), and it is performed inside the thisFunction after the function has completed execution.<br><br>JavaScript is a scripting language that is based on events. Instead of waiting for a reply before continuing, JavaScript will continue to run while monitoring for additional events. Callbacks are a technique of ensuring that a particular code does not run until another code has completed its execution.</p>"
            },
            {
                "name": "“this” Keyword",
                "description": "<p><strong><code>this</code></strong> keyword is one of the most used keywords in JavaScript. But when it comes to regular functions and arrow functions, it behaves in entirely different ways.</p><br><p>In regular function, <strong><code>this</code></strong> changes according to the way that function is invoked.</p><ul><li><strong>Simple Invocation: <code>this</code></strong> equals the global object or maybe undefined if you are using strict mode.<br><img src='./assets/js/simplethis.png'></li><li><strong>Method Invocation: <code>this</code></strong> equals the object that owns the method.<br><img src='./assets/js/methodthis.png'></li><li><strong>Indirect Invocation: <code>this</code></strong> equals the first argument.<br><img src='./assets/js/indirectthis.png'></li><li><strong>Constructor Invocation: <code>this</code></strong> equals the newly created instance.<br><img src='./assets/js/constructorthis.png'></li></ul><br><br><p>But, in the arrow functions, the behavior of <strong><code>this</code></strong> changes completely.<br><br>Arrow functions don't have their own “this”, and they don’t redefine the value of “<code>this</code>” within the function. <br><br>Regardless of how you execute arrow functions, <code>this</code> inside an arrow function always refers to <code>this</code> from the outer context. This means that <code>this</code> keyword is <strong>lexically </strong>bound in arrow functions. <br>For Example: <br><img src='./assets/js/this.png'><br><br>This behavior of arrow functions makes them really useful when using callbacks inside methods.<br><br>You don't need to use workarounds like <code>const self = this</code> or <code>callback.bind(this)</code> with arrow functions, and it prevents any mistakes that can be caused by the use of <code>this</code> within callbacks.</p>"
            },
            {
                "name": "How does the \"this\" keyword work? Provide some code examples",
                "description": "<p>In JavaScript <em>this</em> always refers to the “owner” of the function we're executing, or rather, to the object that a function is a method of.<br><img src='./assets/jsCode/foo.png'></p>"
            },
            {
                "name": "Explain ”this” with call, apply and bind in JavaScript?",
                "description": "<p>Every function in JavaScript have call, apply and bind methods. These methods can be used to set the custom value of “this” to the execution context of the function.<br><br> <strong>call</strong><strong> - It's a predefined method in javascript. This method invokes a method (function) by specifying the owner object.<br/></strong>Let's say that we have an object called <strong>obj</strong>. It only has one property called <strong>num</strong>, which has a value of 3. Let's also make a function called <strong>addNumbers</strong>.<br><br> Now, in <strong>addNumbers</strong> we have this.num. But how do we pass the value obj.num to it. We need to pass it a context, which means the value of “this”. We will do this my call method by passing a first argument as obj, so the “this” is the obj now.<br><br><img src='./assets/js/call1.png'/><br><br> <strong>apply</strong><strong><br/></strong>It is totally similar to call, but the only difference is that we can pass array as the second argument. We will use the same code for apply also. But now we have an <em>arr</em>, to be passed as second argument.<br><br><img src='./assets/js/apply1.png'/><br><br> <strong>bind</strong><strong><br/></strong>Bind works in a bit different way then call and apply. It works by returning a copy of the function. We will take the returned function in <strong>bindFunc</strong> and then execute it in the next line.<br><br><img src='./assets/js/bind2.png'/></p>"
            },
            {
                "name": "When would you use the bind function?",
                "description": "<p>A good use of the <code>bind</code> function is when you have a particular function that you want to call with a specific this value. You can then use <code>bind</code> to pass a specific object to a function that uses a <code>this</code> reference.</p><br> <img src='./assets/js/bind1.png'>"
            },
            {
                "name": "Explain currying in JavaScript and implement multiply(2)(3)(4)(10) using it?",
                "description": "<p>Currying is the process of taking a function with multiple arguments and turning it into a sequence of functions each with only a single argument.<br><br>In other words, when a function, instead of taking all arguments at one time, takes the first one and return a new function that takes the second one and returns a new function which takes the third one, and so forth, until all arguments have been fulfilled.<br><br><img src='./assets/js/currying.png'><br><br><strong>Note:</strong> Currying works because of JavaScript concept of closures. The closure created by the nested functions to retain access to each of the arguments. So inner function which do “return a * b * c * d” have access to all arguments.</p>"
            },
            {
                "name": "What is Scope and Scope Chain in JavaScript?",
                "description": "<p>Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime. In other words, scope determines the visibility of variables and other resources in areas of your code.<br><br>There are three types of scopes in JS: <strong>#1. Global Scope</strong> - Variables or functions declared in the global namespace have global scope, which means all the variables and functions having global scope can be accessed from anywhere inside the code. <br><strong>#2. Local or Function Scope</strong> - Any variables or functions declared inside a function have local/function scope, which means that all the variables and functions declared inside a function, can be accessed from within the function and not outside of it. <br><strong>#3. Block Scope</strong> - Block scope is related to the variables declared using let and const. Variables declared with var do not have block scope. Block scope tells us that any variable declared inside a block { }, can be accessed only inside that block and cannot be accessed outside of it.<br><br><strong>Scope Chain</strong> - When a variable is used in JavaScript, the JavaScript engine will try to find the variable’s value in the current scope. If it could not find the variable, it will look into the outer scope and will continue to do so until it finds the variable or reaches global scope. <br>If it’s still could not find the variable, it will either implicitly declare the variable in the global scope (if not in strict mode) or return an error.<br><img src='./assets/js/scopechain.png'></p>"
            },
            {
                "name": "What is a closure and how do we use it?",
                "description": "<p>Closures are everywhere in JavaScript.<br><br>Closures are basically, the inner function having access to the variables in the outer function scope, even after the outer function has returned. To use a closure, simply define a function inside another function and expose it, I mean return it.<br><br>Consider the below code. The variable <strong>b</strong> have an scope in outer function. So, at when we call the outer function, it can access the value of b.<br><br>So, how does the innerFn() access the value of <strong>b</strong>. This is where the JS feature of Closures comes into play.<br><br><em>When the “var inner” is created, the JS engine not only stores the function object information but also its scope information.&nbsp;</em>So, it stores a scope of variable <strong>b</strong> inside the inner function object.<br><br>Now it doesn’t matter where you call inner, whether in this file. It will always remember the value of <strong>a</strong> and <strong>b</strong>, as if a snapshot is been taken.<br><br><img src='./assets/js/closure.png'></p>"
            },
            {
                "name": "What is an anonymous function",
                "description": "<p>An anonymous function is a function without a name! Anonymous functions are commonly assigned to a variable name or used as a callback function.<br><br><img src='./assets/js/anonymous.png'></p>"
            },
            {
                "name": "What are Object Prototypes and how do we use them in JavaScript?",
                "description": "<p>In JavaScript everything is an Object. So whenever we create an function, there is a one object which is created for that function. But actually there is another object which is created which is known as the <em>Prototype</em> object.<br><br>Now, let's look how to create an function using prototype and the benefit of it. The below code have two function <em>haveFun</em> and <em>drinkBreak</em>. The function <em>haveFun</em> is an normal function inside the Constructor function. The function <em>drinkBreak</em> is created outside and added to the Prototype Object using it's reference prototype.<br><br><img src='./assets/js/functionprototype.jpg'><br><br>Both the function seems to be doing the same thing, then what's the benefit.<br>The benefit of declaring function using prototype is that it's created once in the Prototype object. So, now whenever we create a new instance of the Constructor function the function is not created again. As in the below screenshot, you can see that <strong>emp1</strong> and <strong>emp2</strong> both have <strong>name</strong> and <strong>haveFun</strong>. But the <strong>drinkBreak</strong> is inside the <strong>__proto__</strong>, which is a reference to Prototype object.<br><br><img src='./assets/js/functionprototype1.jpg'></p>"
            },
            {
                "name": "What is memoization?",
                "description": "<p>Memoization is a form of caching where the return value of a function is cached based on its parameters. If the parameter of that function is not changed, the cached version of the function is returned.<br>Let’s understand memoization, by converting a simple function to a memoized function: <br><img src='./assets/js/memiozation.png'></p>"
            },
            {
                "name": "Explain recursion in JavaScript?",
                "description": "<p>Recursion is a technique for iterating over an operation by having a function call itself repeatedly until it arrives at a result.<br>Now, in recursive function there are two parts. One is <strong>termination condition</strong> and other is the <strong>recursion</strong> itself. &nbsp;The termination condition is very important or else the recursion never stops and goes into infinite loop.<br><br>Let consider the below simple example to add numbers from the current passed number backwards till 1. Say we pass 3, then 3+2+1 = 6. In the below example <em>If(n≤0)</em> is the termination condition and <em>return n + add(n-1);</em> is the recursion.<br><br><img src='./assets/js/recursive.jpg'><br><br>The recursion works as shown in the diagram below.<br>It works like loop, so the first call will go to recursion part and give “3 + add(2)”.<br><br>Now the add(2) will be called and will be expended into “2 + add(1)”.<br>After that add(1) will be called and expanded into “1 + add(0)”.<br><br>Finally the add(0) will trigger the termination condition <em>If(n≤0)&nbsp;</em>and produce 0.<br>After this everything will be added 3 + 2 + 1 + 0 to give 6.<br><br><img src='./assets/js/recursiveoutput.jpg'></p>"
            },
            {
                "name": "What are constructor functions in JavaScript?",
                "description": "<p>In JavaScript, a constructor gets called when you try to create an object using the new keyword. The purpose of a constructor is <b>If we want to create multiple objects having similar properties and methods, constructor functions are used.</b>.<br><img src='./assets/js/constructor.png'></p>"
            },
            {
                "name": "How to make variables private in Constructor functions?",
                "description": "<p>Now, we implement the same in JavaScript using Closures. We have two closure functions <strong>setName</strong> and <strong>getName</strong> which are basically “setters” and “getters”. Now, the variable <strong>_name</strong> is private and cannot be accessed outside the function by <em>person._name</em> and we can access it only by <em>person.getName()</em><br><br><img src='./assets/js/privatevarconstructor.jpg'></p>"
            },
            {
                "name": "What is DOM?",
                "description": "<ul><li>DOM stands for Document Object Model. &nbsp;DOM is a programming interface for HTML and XML documents.</li><li>When the browser tries to render an HTML document, it creates an object based on the HTML document called DOM. Using this DOM, we can manipulate or change various elements inside the HTML document.</li></ul>"
            },
            {
                "name": "List all DOM events ",
                "description": "<ul><li><strong>onblur</strong> - The onblur event occurs when an HTML element loses focus. event is often used on input fields. event is often used with form validation (when the user leaves a form field).</li><li><strong>onchange</strong> - The onchange event occurs when the value of an HTML element is changed.  This event is similar to the oninput event. The difference is that the oninput event occurs immediately after the value of an element has changed, while onchange occurs when the element loses focus, after the content has been changed. The other difference is that the onchange event also works on &lt;select&gt; elements.</li><li><strong>onclick</strong> - The onclick event occurs when the user clicks on an HTML element.</li><li><strong>oncontextmenu</strong> - The oncontextmenu event occurs when the user right-clicks an HTML element to open the context menu.</li><li><strong>onfocus, onfocusin</strong> - The onfocus event occurs when an element gets focus. This event is often used on input fields.</li><li><strong>onfocusout</strong> - The onfocusout event occurs when an element looses focus. This event is often used on input fields. This event is often used with form validation (when the user leaves a form field).</li><li><strong>oninput</strong> - The oninput event occurs when an element gets user input. This event occurs when the value of an &lt;input&gt; or &lt;textarea&gt; element is changed. This event is similar to the onchange event. The difference is that the oninput event occurs immediately after the value of an element has changed, while onchange occurs when the element loses focus, after the content has been changed. The other difference is that the onchange event also works on &lt;select&gt; elements.</li><li><strong>onkeydown</strong> - The onkeydown event occurs when the user presses a key on the keyboard.</li><li><strong>onkeyup</strong> - The onkeyup event occurs when the user releases a key on the keyboard.</li><li><strong>onload</strong> - The onload event occurs when an object has been loaded. onload is most often used within the <body> element to execute a script once a web page has completely loaded all content (including images, script files, CSS files, etc.). The onload event can be used to check the visitor's browser type and browser version, and load the proper version of the web page based on the information.</li><li><strong>onscroll</strong> - The onscroll event occurs when an element's scrollbar is being scrolled. use the CSS overflow style property to create a scrollbar for an element.</li><li><strong>onselect</strong> - The onselect event occurs after some text has been selected in an element. The onselect event is mostly used on &lt;input type=\"text\"&gt; or &lt;textarea&gt; elements.</li></ul>"
            },
            {
                "name": "Difference between DOMContentLoaded and load Events",
                "description": "<p>These two events <strong>DOMContentLoaded</strong> and <strong>load</strong> are used to check when a webpage has loaded completely. Still, there are some factors that determine the preference of one over the other.<br><br><strong>DOMContentLoaded</strong> event gets executed once the basic HTML document is loaded and its parsing has taken place. This event doesn’t wait for the completion of the loading of add-ons such as stylesheets, sub-frames and images/pictures.<br><br><img src='./assets/js/dom.png'><br><br><strong>Advantages of using DOMContentLoaded event:</strong></p><ul><li>It helps in improving user experience as it shows messages or content much faster.</li><li>It takes lesser time in loading the page.</li></ul><br><br><p><strong>load</strong> event performs its execution differently. This event gets completed once all the components i.e. DOM hierarchy along with associated features of a webpage such as CSS files, JavaScript files, images/pictures, and external links are loaded. So basically, the load event helps in knowing when the page has fully-loaded.<br><br><img src='./assets/js/load.png'><br><br><strong>Advantages of using load event:</strong></p><ul><li>This event helps in knowing when all the components of the webpage is loaded.</li></ul>"
            },
            {
                "name": "Draw a Simple JavaScript Dom (Document Object Model).",
                "description": "<p><img src='./assets/js/jsdom.png'></p>"
            },
            {
                "name": "What do you mean by Browser Object Model (BOM)?",
                "description": "<p>Browser Object Model is known as BOM. It allows users to interact with the browser. A browser's initial object is a window. As a result, you may call all of the window's functions directly or by referencing the window. The document, history, screen, navigator, location, and other attributes are available in the window object.</p>"
            },
            {
                "name": "Why Browser Object Model (BOM) introduced in JavaScript?",
                "description": "<p>To interact with the browser, the Browser Object Model has some properties and methods. Some examples include, the height and width of the window/ screen.<br><br>Some of its methods include:</p><ul><li>window.open() – To open a new window</li><li>window.close() – To close the current window</li><li>window.moveTo() – To move the current window</li><li>window.resizeTo() – To resize the current window</li></ul>"
            },
            {
                "name": "Which method is used to retrieve a character from a certain index?",
                "description": "<p>The charAt() function of the JavaScript string finds a char element at the supplied index. The index number begins at 0 and continues up to n-1, Here n is the string length. The index value must be positive, higher than, or the same as the string length.</p>"
            },
            {
                "name": "What are arrow functions?",
                "description": "<p>Arrow functions were introduced in the ES6 version of javascript. They provide us with a new and shorter syntax for declaring functions. Arrow functions can only be used as a function expression.<br><br>Let’s compare the normal function declaration and the arrow function declaration in detail:<br><br><img src='./assets/js/arrow.png'><br>Arrow functions are declared without the function keyword. If there is only one returning expression then we don’t need to use the return keyword as well in an arrow function as shown in the example above. Also, for functions having just one line of code, curly braces { } can be omitted.<br><br><img src='./assets/js/arrow1.png'><br>If the function takes in only one argument, then the parenthesis () around the parameter can be omitted as shown in the code above.<br><br><img src='./assets/js/arrow2.png'><br>The biggest difference between the traditional function expression and the arrow function is the handling of <strong>this </strong>keyword. By general definition, <strong>this </strong>keyword always refers to the object that is calling the function. As you can see in the code above, <strong>obj1.valueOfThis() </strong>returns obj1 since <strong>this </strong>keyword refers to the object calling the function.<br><br>In the arrow functions, there is no binding of <strong>this </strong>keyword. This<strong> </strong>keyword inside an arrow function does not refer to the object calling it. It rather inherits its value from the parent scope which is the window object in this case. Therefore, in the code above, <strong>obj2.valueOfThis() </strong>returns the window object.</p>"
            },
            {
                "name": "What advantages are using arrow functions?",
                "description": "<ul><li><em>Compactness</em>: Arrow functions are easier to read and write.</li><li><em>Clarity</em>: When almost everything is an arrow function, any regular function immediately sticks out for defining the scope. A developer can always look up the next-higher function statement to see what this <code>this </code>object is.</li><li><em>Scope safety</em>: Until arrow functions, every new function defined its own value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an \"object method\", etc.). An arrow function does not create its own this, the <code>this </code>value of the enclosing execution context is used.</li></ul>"
            },
            {
                "name": "When should you NOT use arrow functions in ES6 ",
                "description": "<p>Arrow functions should NOT be used:</p><ul><li>When we want function hoisting - as arrow functions are anonymous.</li><li>When we want to use this/arguments in a function - as arrow functions do not have this/arguments of their own, they depend upon their outer context.</li><li>When we want to use named function - as arrow functions are anonymous.</li><li>When we want to use function as a constructor - as arrow functions do not have their own this.</li><li>When we want to add function as a property in object literal and use object in it - as we can not access this (which should be object itself).</li></ul>"
            },
            {
                "name": "Prototypal Design Pattern?",
                "description": "<p>The Prototype Pattern produces different objects, but instead of returning uninitialized objects, it produces objects that have values replicated from a template – or sample – object. Also known as the Properties pattern, the Prototype pattern is used to create prototypes.<br><br>The introduction of business objects with parameters that match the database's default settings is a good example of where the Prototype pattern comes in handy. The default settings for a newly generated business object are stored in the prototype object.<br><br>The Prototype pattern is hardly used in traditional languages, however, it is used in the development of new objects and templates in JavaScript, which is a prototypal language.</p>"
            },
            {
                "name": "What is Prototypal Inheritance?",
                "description": "<p>Prototypal inheritance is to add new capabilities to a constructor function using Prototype.<br>Let's first understand what are Constructor functions. They are basically JavaScript way to implement the concept of Classes.<br>Let's consider the example below, where we have a “Car” constructor function. In it we have a “model”, which we are also returning by getModel(). Now we can create a new instance of it by using the “new” keyword. Each instance will have its own “this” and have its own getModel().<br><br><img src='./assets/js/functionprototype2.jpg'><br><br>Now, the problem is that every time we create a new instance we get a new copy of <em>getModel().</em> Suppose we have 100 instances, then we will have 100 copies.<br><br>In JavaScript as you know everything is an Object. Whenever a function is created there are two object one is the function object another is the prototype object. Now to access the <strong>Prototype</strong> object we have a property on the function object also known as “<strong>prototype</strong>”.<br><br>We should somehow move the logic for&nbsp;<em>getModel()</em> outside our Constructor function and that is where the concept of Prototype helps.<br><br><img src='./assets/js/functionprototype3.jpg'><br><br>We get the same result and this is known as <strong>Prototypal Inheritance</strong>. Also, each new instance don’t have its own getModel(), which we can see in below console log.<br><br><img src='./assets/js/functionprototype4.jpg'></p>"
            },
            {
                "name": "JavaScript Design Patterns?",
                "description": "<p>JavaScript design patterns are repeatable approaches for errors that arise sometimes when building JavaScript browser applications. They truly assist us in making our code more stable.<br><br>They are divided mainly into 3 categories&nbsp;</p><ul><li><strong>Creational Design Pattern: </strong>The object generation mechanism is addressed by the JavaScript Creational Design Pattern. They aim to make items that are appropriate for a certain scenario.</li><li><strong>Structural Design Pattern: </strong>The JavaScript Structural Design Pattern explains how the classes and objects we've generated so far can be combined to construct bigger frameworks. This pattern makes it easier to create relationships between items by defining a straightforward way to do so.</li><li><strong>Behavioral Design Pattern: </strong>This design pattern highlights typical patterns of communication between objects in JavaScript. As a result, the communication may be carried out with greater freedom.</li></ul>"
            },
            {
                "name": "What is the rest parameter and spread operator?",
                "description": "<p>Both rest parameter and spread operator were introduced in the ES6 version of javascript.<br><br><strong>Rest parameter ( … ):</strong></p><ul><li>It provides an improved way of handling the parameters of a function.</li><li>Using the rest parameter syntax, we can create functions that can take a variable number of arguments.</li><li>Any number of arguments will be converted into an array using the rest parameter.</li><li>It also helps in extracting all or some parts of the arguments.</li><li>Rest parameters can be used by applying three dots (...) before the parameters.</li></ul><br><img src='./assets/js/rest.png'><p><strong>**Note- Rest parameter should always be used at the last parameter of a function:</strong></p><br><br><p><strong>Spread operator (…): </strong>Although the syntax of the spread operator is exactly the same as the rest parameter, the spread operator is used to spreading an array, and object literals. We also use spread operators where one or more arguments are expected in a function call.<br><img src='./assets/js/spread.png'><br><br><strong>***Note</strong> - Key differences between rest parameter and spread operator:</p><ul><li>Rest parameter is used to take a variable number of arguments and turns them into an array while the spread operator takes an array or an object and spreads it</li><li>Rest parameter is used in function declaration whereas the spread operator is used in function calls.</li></ul><p>"
            },
            {
                "name": "What are the benefits of using spread syntax in ES6 and how is it different from rest syntax?",
                "description": "<p>ES6's spread syntax is very useful when coding in a functional paradigm as we can easily create copies of arrays or objects without resorting to <code>Object.create</code>, <code>slice</code>, or a library function. This language feature is used often in Redux and rx.js projects.<br><img src='./assets/js/es6spread.png'><br><br>ES6's rest syntax offers a shorthand for including an arbitrary number of arguments to be passed to a function. It is like an inverse of the spread syntax, taking data and stuffing it into an array rather than unpacking an array of data, and it works in function arguments, as well as in array and object destructuring assignments.<br><img src='./assets/js/es6rest.png'></p>"
            },
            {
                "name": "What are promises JavaScript?",
                "description": "<p>They are mainly used to do asynchronous task like calling a REST api and getting the result back. So, these network calls takes time.<br><br>When the network call is been made, the promise is in <strong>pending state</strong> which means promise has neither been fulfilled nor been rejected, it is in the pending state.<br><br>Once the network call is successful the promise returns a resolve function which means the async operation is completed and in case if it fails it returns reject function meaning operation has failed.<br><br>The resolve is captured by the .then() callback function and reject captured by .catch() callback function.<br><br>Optionally we can also use the fourth state called settled state which schedules a function to be called when the promise is settled i.e. either fulfilled or rejected. The settled is captured by the .finally() callback function</p>"
            },
            {
                "name": "What are classes in javascript?",
                "description": "<p>Introduced in the ES6 version, classes are nothing but syntactic sugars for constructor functions. They provide a new way of declaring constructor functions in javascript.<br><br>Key points to remember about classes:<ul><li>Unlike functions, classes are not hoisted. A class cannot be used before it is declared.</li><li>A class can inherit properties and methods from other classes by using the extend keyword.</li><li>All the syntaxes inside the class must follow the strict mode(‘use strict’) of javascript. An error will be thrown if the strict mode rules are not followed.</li></ul><br><img src='./assets/js/class.png'></p>"
            },
            {
                "name": "What are generator functions?",
                "description": "<p>Introduced in ES6 version, generator functions are a special class of functions.<br><br><strong>They can be stopped midway and then continue from where it had stopped.</strong><br><br>Generator functions are declared with the <strong>function*</strong> keyword instead of the normal <strong>function</strong> keyword<br><br><code><strong>function* genFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;// Perform operation<br>}</strong></code><br><br>In normal functions, we use the <strong>return</strong> keyword to return a value and as soon as the return statement gets executed, the function execution stops:<br><br> <code><strong> function normalFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;return 22;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(2); // This line of code does not get executed<br>}</strong></code> <br><br>In the case of generator functions, when called, they do not execute the code, instead they return a <strong>generator object</strong>. This generator object handles the execution<br><br><code><strong> function* genFunc(){<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 3;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 4;<br>}<br>genFunc(); // Returns Object [Generator]{}</strong></code><br><br>The generator object consists of a method called <strong>next()</strong> , this method when called, executes the code until the nearest <strong>yield</strong> statement, and returns the yield value.<br><br><img src='./assets/js/generator.png'><br><br>As you can see in the code above, the last line returns done:true , since the code reaches the return statement.</p>"
            },
            {
                "name": "Explain WeakSet in javascript.",
                "description": "<ul><li>Weakset contains only objects and no other type.</li><li>An object inside the weakset is referenced weakly. This means, that if the object inside the weakset does not have a reference, it will be garbage collected.</li><li>Unlike Set, WeakSet only has three methods, <strong>add() </strong>, <strong>delete() </strong>and <strong>has() </strong>.</li></ul><br><img src='./assets/js/weakset.png'>"
            },
            {
                "name": "Differences between WeakSet and Set",
                "description": "<p>The main difference is that references to objects in Set are strong while references to objects in WeakSet are weak. i.e, An object in WeakSet can be garbage collected if there is no other reference to it. Other differences are,</p><ol><li>Sets can store any value Whereas WeakSets can store only collections of objects</li><li>WeakSet does not have size property unlike Set</li><li>WeakSet does not have methods such as clear, keys, values, entries, forEach.</li><li>WeakSet is not iterable.</li></ol>"
            },
            {
                "name": "Explain WeakMap in javascript.",
                "description": "<p>In javascript, Map is used to store key-value pairs. The key-value pairs can be of both primitive and non-primitive types. WeakMap is similar to Map with key differences:</p><ul><li>The keys and values in weakmap should always be an object.</li><li>If there are no references to the object, the object will be garbage collected.</li></ul><br><img src='./assets/js/weakmap.png'>"
            },
            {
                "name": "Differences between WeakMap and Map",
                "description": "<p>The main difference is that references to key objects in Map are strong while references to key objects in WeakMap are weak. i.e, A key object in WeakMap can be garbage collected if there is no other reference to it. Other differences are,</p><ol><li>Maps can store any key type Whereas WeakMaps can store only collections of key objects</li><li>WeakMap does not have size property unlike Map</li><li>WeakMap does not have methods such as clear, keys, values, entries, forEach.</li><li>WeakMap is not iterable.</li></ol>"
            },
            {
                "name": "Explain Destructuring in ES6?",
                "description": "<p>Destructuring is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables. You can also handle nested structure by using nested destructuring syntax.<br><br><strong>Object Destructuring - You use an object literal on the left-hand-side of an assignment expression</strong> for object destructuring.<br><br><img src='./assets/js/objdestructure2.jpg'><br><br><strong>Nested Object Destructuring</strong><br>If there is nested object as in below case, we can destructure it by adding it's value to another object syntax<br><br><img src='./assets/js/objdestructure3.jpg'><br><br><strong>Array Destructuring</strong><br>Array destructuring is similar to object destructuring, but here instead of keys you assign any variable.<br><br><img src='./assets/js/objdestructure4.jpg'><br><br><strong>Skipping Items</strong><br>It is possible to skip items in array destructuring by omitting items with comma(,).<br><br><img src='./assets/js/objdestructure5.jpg'></p></div>"
            },
            {
                "name": "Difference between prototypal and classical inheritance",
                "description": "<p>Programers build objects, which are representations of real-time entities, in traditional OO programming. Classes and objects are the two sorts of abstractions. A class is a generalization of an object, whereas an object is an abstraction of an actual thing. A Vehicle, for example, is a specialization of a Car. As a result, automobiles (class) are descended from vehicles (object).<br><br>Classical inheritance differs from prototypal inheritance in that classical inheritance is confined to classes that inherit from those remaining classes, but prototypal inheritance allows any object to be cloned via an object linking method. Despite going into too many specifics, a prototype essentially serves as a template for those other objects, whether they extend the parent object or not.</p>"
            },
            {
                "name": "What is Temporal Dead Zone?",
                "description": "<p>Temporal Dead Zone is a behaviour that occurs with variables declared using <strong>let </strong>and <strong>const </strong>keywords. It is a behaviour where we try to access a variable before it is initialized. Examples of temporal dead zone:<br><br><img src='./assets/js/deadZone.png'><br><br><strong>Example 2</strong><br><br><img src='./assets/js/deadZone1.png'><br><br>In the code above, both in the global scope and functional scope, we are trying to access variables that have not been declared yet. This is called the <strong>Temporal Dead Zone</strong>.</p>"
            },
            {
                "name": "Difference between Async/Await and Generators usage to achieve the same functionality.",
                "description": "<ul><li>Generator function are executed yield by yield i.e one yield-expression at a time by its iterator (the next method) where as Async-await, they are executed sequential await by await.</li><li>Async/await makes it easier to implement a particular use case of Generators.</li><li>The return value of Generator is always {value: X, done: Boolean} where as for Async function it will always be a promise that will either resolve to the value X or throw an error.</li><li>Async function can be decomposed into Generator and promise implementation like:</li></ul><p><img src='./assets/js/asyncAwaitGenerator.png'></p>"
            },
            {
                "name": "What is the role of deferred scripts in JavaScript?",
                "description": "<p>The processing of HTML code while the page loads are disabled by nature till the script hasn't halted. Your page will be affected if your network is a bit slow, or if the script is very hefty. When you use Deferred, the script waits for the HTML parser to finish before executing it. This reduces the time it takes for web pages to load, allowing them to appear more quickly.</p>"
            },
            {
                "name": "What is the object and array type?",
                "description": "<p>The object type refers to a compound value where you can set properties (named locations) that each hold their own values of any type.<br><br><img src='./assets/js/object.png'><br><br>An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions:<br><br><img src='./assets/js/array.png'></p>"
            },
            {
                "name": "What is event bubbling and capturing in JavaScript?",
                "description": "<p>For this we need to understand Event flow is the order in which event is received on the web page. When you click an element that is nested in various other elements, before your click actually reaches its destination, or target element, it must trigger the click event for each of its parent elements first, starting at the top with the global window object. <br><br>We will first see <strong>Event Bubbling</strong>. - In this the event propagation, the event first triggers on the innermost target element .i.e. the child element first, and then successively triggers on the ancestors i.e. parents element in the order of the elements nested hierarchy till it reaches the outermost DOM element. <br><br><strong>It is totally vice-versa of Event Bubbling</strong><br><br>Where as in <strong>Event Capturing</strong>. - the event propagation, the event first triggers on the outermost element .i.e. the parent element first, and then successively triggers on the descendants i.e. child element in the order of the elements nested hierarchy till it reaches the innermost DOM element.</p>"
            },
            {
                "name": "Explain async await in JavaScript?",
                "description": "<p>The <code>Async</code> keyword is short for 'Asynchronous' and in always positioned before a function. This is done to indicate an <code>Async</code> function and more importantly, that the function being specified as <code>Async</code> will always return a promise.<br><br>The body of an <code>Async</code> function can contain zero or more <code>Await</code> keywords. The difference between an <code>Async</code> function with one or more <code>Await</code> keywords and one without any <code>Await</code> keywords is that the non <code>Await</code> function will behave in a synchronous manner while the one containing one or more <code>Await</code> keywords will act in an asynchronous way.<br><br>Next, we have the <code>Await</code> keyword. This keyword is only valid inside <code>Async</code> functions and it primarily serves to make JavaScript wait until the promise inside the <code>Async</code> function settles and returns a result. This single keyword is responsible for converting synchronous functions into asynchronous ones, just by the act of allowing other processes to run while awaiting a value from a promise(no pun intended :) ). So note that it only makes the promise containing code block wait, while the rest of the program executes normally.</p>"
            },
            {
                "name": "Explain Promise.all with async-await?",
                "description": "<p>The <em>Promise.all &nbsp;</em>method returns a single Promise that resolves when all of the promises in the <em>iterable</em> argument have resolved or when the <em>iterable</em> argument contains no promises. It rejects with the reason of the first promise that rejects.<br><br><img src='./assets/js/promiseall.jpg'><br><br>We should use <em>Promise.all</em> in only cases like above, where the result of one Promise is not dependent on other promise.</p>"
            },
            {
                "name": "Explain nested promises JavaScript?",
                "description": "<p>Nested promises are set of promises in which , the result of one promise we call another in the .then statement. It is very useful in practical applications, where the result of fetch from an API endpoint will result in sending the data to another endpoint. Nested promises can also be done with callback functions, but the code get complicated soon.<br><br>Let's look at an example of nested promises. Here we have three functions which return promises- <em>coinTossed, gotCoinTossedResult and happyTeam</em>. Now only the <em>coinTossed</em> is returning resolve() or reject() depending on random number. The other two functions are returning only resolve() for simplicity sake.<br><br>Now, when the <em>coinTossed</em> function is run and return a resolve(), then the immediate .then block will be run or else we will go to the .catch block. In the .then we are returning the next <em>gotCoinTossedResult&nbsp;</em>and in its .then we are returning the <em>happyTeam</em>. We are passing the message from one function to other, so it will be appended.<br><br><img src='./assets/js/cointoss.png'></p>"
            },
            {
                "name": "How do we handle errors in async-await function?",
                "description": "<p>In Promises we handle any error or reject in the .catch block. Let's look at the below example, where we are sending reject() from Promise inside a function expression. So, now the error will be caught by the .catch block and then we are displaying the same in console log.<br><br><strong>try…catch block available in JavaScript</strong><br><br><img src='./assets/js/tryCatch.png'></p>"
            },
            {
                "name": "What are the limitations of JavaScript?",
                "description": "<ol> <li><strong>Writing files on server</strong> - JavaScript cannot directly write files on server. However, they can do this using server-side script</li><li><strong>Disable JavaScript</strong> - Due to security reasons, every web browser provides an option to disable JavaScript.</li><li><strong>Networking</strong> - It cannot be used for Networking applications.</li><li><strong>Browser Compatibility</strong> - Applications may behave differently in different web browsers. To support all modern browsers, you need to write cross browser codes.</li><li><strong>Security</strong> - Since the code executes on client's computer, the chances are high for vulnerability and can be exploited for malicious purposes</li><li><strong>Databases</strong> - JavaScript cannot access databases. You need AJAX and a server-side script for this.</li></ol>"
            },
            
            {
                "name": "Different ways to make an object non-extensible?",
                "description": "<p>You can mark an object non-extensible in 3 ways,</p><ol> <li><strong>Object.freeze()</strong> - simply converts an object passed as the argument into a frozen state. An object called by this method can not have any further changes on it. <ul> <li>Cannot add new properties.</li><li> Cannot remove existing properties.</li><li> Cannot change existing property values.</li><li> Cannot reconfigure any existing property. writable and configurable are set to false.</li><li> Cannot change its prototype.</li></ul> <p> Trying to make any changes mentioned above after an object being frozen will fail and will throw errors in strict mode.<br><br><strong><em>Object.isFrozen()</em></strong> is an Object method to check if an object is frozen by passing the object as the argument, where the return type is a boolean</p></li><br><li> <strong>Object.seal() </strong>simply converts an object passed as the argument into a sealed state. An object called by this method can not have any new properties being added. But it <strong>can change</strong> existing property values as long as <em>writable</em> metadata is true. <ul> <li>Cannot add new properties.</li><li> Cannot remove existing properties.</li><li> Cannot reconfigure any existing property.</li><li> Cannot convert a data property to accessor property or vice versa.</li></ul> <p><strong><em>Object.isSealed()</em></strong> is an Object method to check if an object is sealed by passing the object as the argument, where the return type is a boolean</p></li><br><li> <strong>Object.preventExtensions() </strong>simply converts an object passed as the argument into a non-extensible state. An object called by this method can not have any new properties being added. This method inherits functionality from its superset object.seal. Hence, it <strong>can change</strong> existing property values as long as <em>writable</em> metadata is true. In contrast to sealed objects, non-extensible objects can be deleted or reconfigured. <p><strong><em>Object.isExtensible()</em></strong> is an Object method to check if an object is extensible by passing the object as the argument.</p></li></ol>"
            },
            {
                "name": "Difference between const vs Object.freeze()",
                "description": "<p>In <strong>const</strong> reassignment of the variable is not allowed but the value referenced by the const variable can still be changed. <br><br>#Ex. Value is Immutable<br> <img src='./assets/js/const-object.png'> <br><br>#Binding is Mutable<br> <img src='./assets/js/const-object1.png'><br><br>#Mutable binding with object<br> <img src='./assets/js/const-object2.png'></p><br><br><p><strong>Object.freeze()</strong> prevents modification or extension to the existing value of an object. <br><br>Ex. Ignoring the value modification to an object<br> <img src='./assets/js/const-object3.png'> <br><br>#But the same work on binding<br> <img src='./assets/js/const-object4.png'></p>"
            },
            {
                "name": "Difference between Object.values() vs Object.entries()",
                "description": "<p><code>Object.values()</code> takes an object and returns an array with the values, in the same order that a for…in loop function would give us. Object.values doesn’t follow the prototype chain and only iterates over the value that are directly on the provided object.<br><img src='./assets/js/object-value.png'><br><br><strong>Object.entries()</strong> returns an array with arrays of key-value pairs:<br><img src='./assets/js/object-entries.png'></p>"
            },
            {
                "name": "Difference between native, host and user objects?",
                "description": "<ul><li>Native objects are objects that are part of the JavaScript language defined by the ECMAScript specification, such as <code>String</code>, <code>Math</code>, <code>RegExp</code>, <code>Object</code>, <code>Function</code>, etc.</li><li>Host objects are provided by the runtime environment (browser or Node), such as <code>window</code>, <code>XMLHTTPRequest</code>,<code>DOM</code> nodes etc.</li><li><code>User objects</code> are objects defined in the javascript code. For example, User object created for profile information</li></ul>"
            },
            {
                "name": "'Deep-Freeze' object in JavaScript?",
                "description": "<p>To make an object immutable, we generally use utilize <code>Object.freeze()</code>, which prevents the addition of new properties and prevent deletion and changes to existing properties to some extent. However, while <code>Object.freeze()</code> provides somewhat kind of a solution, it only handles the problem to the next nesting level, as in reality it performs a shallow freeze during its process. This means that properties that are objects or arrays can still be mutated:<br><br><img src='./assets/js/freezeexample.png'><br><br>Here to solve the issue we can use recursion method, by checking if each property is itself an object using, <code>Object.isFrozen()</code> method which is returning <code >false</code>, then apply <code>Object.freeze()</code> to it:<br><br><img src='./assets/js/deepfreezeexample.png'></p>"
            },
            {
                "name": "How do you check if a key exists in an object?",
                "description": "<ul> <li>Traditional way <br><strong>var user = {name:'test'} <br>//Test condition <br>user.name === undefined //Output <br> true</strong> </li><li> The <strong><code>hasOwnProperty()</code></strong> method returns a boolean indicating whether the object has the specified property or not in it. <br><strong>object_name.hasOwnProperty('key_name')</strong> </li><li>Using <code>'in'</code> operator - <br><strong>!(keyName in objectName);</strong></li></ul>"
            },
            
            {
                "name": "instanceof / typeof operator in JavaScript",
                "description": "<p>If you want to check the type of an object at runtime, then use the instanceof operator where the result is a boolean.<br><br>where as typeof operator is used to find the data type of a JavaScript variable where the result is a string.</p>"
            },
            {
                "name": "String Reference",
                "description": "<ul> <li><strong>charAt(x)</strong> - This function will return the character at the x position within the string.<br><img src='./assets/js/stringcharat.png'><br><br></li><li><strong>charCodeAt(x)</strong> - This function will return the unicode value of the character at position ‘x’ within the string.<br><img src='./assets/js/stringchartat.png'><br><br></li><li><strong>concat(v1,v2..)</strong> - This function combines one or more strings(argv1,v2 etc) into existing one.<br><img src='./assets/js/stringconcat.png'><br><br></li><li><strong>fromCharcode(c1,c2)</strong> - This function will return a string created by using specified sequence of unicode values(argc1,c2).<br><img src='./assets/js/stringfromcharcode.png'><br><br></li><li><strong>indexOf(substr, [start])</strong> - Searches and (if found) returns the index number of the searched character or substring within the string. If not found, -1 is returned. “Start” is an optional argument specifying the position within string to begin the search. Default is 0.<br><img src='./assets/js/stringindexof.png'><br><br></li><li><strong>lastIndexOf(substr, [start])</strong> - Searches and (if found) returns the index number of the searched character or substring within the string. Searches the string from end to the beginning. If not found, -1 is returned. “Start” is an optional argument specifying the position within string to begin the search. Default is string.length-1.<br><img src='./assets/js/stringlastindexof.png'><br><br></li><li><strong>match(regexp)</strong> - Executes a search for a match within a string based on a regular expression. It returns an array of information or null if no match is found.<br><img src='./assets/js/stringmatch.png'><br><br></li><li><strong>replace(regexp/substr, replacetext)</strong> - Searches and replaces the regular expression (or sub string) portion (match) with the replaced text instead.<br><img src='./assets/js/stringreplace.png'><br><br></li><li><strong>search(regexp)</strong> - Tests for a match in a string. It returns the index of the match, or -1 if not found.<br><img src='./assets/js/stringsearch.png'><br><br></li><li><strong>slice(start, [end])</strong> - This function returns a substring of the string based on the “start” and “end” index arguments, NOT including the “end” index itself. “End” is optional, and if none is specified, the slice includes all characters from “start” to end of the string.<br><img src='./assets/js/stringslice.png'><br><br></li><li><strong>split(delimiter, [limit])</strong> - This will split a string into many according to the specified delimiter, and returns an array containing each element. The optional “limit” is an integer that lets you specify the maximum number of elements to return.<br><img src='./assets/js/stringsplit.png'><br><br></li><li><strong>substr(start, [length])</strong> - This function returns the characters in a string beginning at “start” and through the specified number of characters, “length”. “Length” is optional, and if omitted, up to the end of the string is assumed.<br><img src='./assets/js/stringsubstr.png'><br><br></li><li><strong>substring(from, [to])</strong> - It returns the characters in a string between “from” and “to” indexes, NOT including “to” itself. “To” is optional, and if omitted, up to the end of the string is assumed.<br><img src='./assets/js/stringsubstring.png'><br><br></li><li><strong>toLowerCase()</strong> - This will return the string with all of its characters converted to lowercase.<br><img src='./assets/js/stringlowercase.png'><br><br></li><li><strong>toUpperCase()</strong> - This will return the string with all of its characters converted to uppercase.<br><img src='./assets/js/stringuppercase.png'><br><br></li><li><strong>includes()</strong> - It is used to check whether a string contains the specified string or characters.<br><img src='./assets/js/stringincludes.png'><br><br></li><li><strong>endsWith()</strong> - This function checks whether a string ends with specified string or characters.<br><img src='./assets/js/stringendwith.png'><br><br></li><li><strong>repeat()</strong> - This returns a new string with a specified number of copies of an existing string.<br><img src='./assets/js/stringrepeat.png'><br><br></li><li><strong>valueOf()</strong> - It is used to return the primitive value of a String object.<br><img src='./assets/js/stringvalueof.png'><br><br></li><li><strong>trim()</strong> - This function removes whitespace from both ends of a string.<br><img src='./assets/js/stringtrim.png'><br><br></li></ul>"
            },
            {
                "name": "toString() vs join()?",
                "description": "<p>array.toString() and array.join() does the same thing of converting an array into a string. Since toSting() does not accept any arguments its is less preferred while in join() one can pass arguments. Ex. [1,2,3].join(', ')</p>"
            },
            {
                "name": "Explain join() vs concat() in Javascript",
                "description": "<p>To join two or more strings, use the JavaScript <code>string.concat(string1, string2, ..., stringX)</code> method. A new string is returned with the joined strings.<br><br>The <code>array.join(separator)</code> method returns an array as a string. The elements will be separated by a specified separator. The default separator is comma (,).<br><br><code>join()</code> does not change the original array.</p>"
            },
            {
                "name": "Remove whitespace from both sides of a string in JavaScript",
                "description": "<p>The <code>trim()</code> method is used to remove whitespace from both sides of a string.<br><br><code><strong>var myStr = \" &nbsp; &nbsp; Cup of tea! &nbsp; &nbsp;\";</code></strong></p><code><strong>myStr.trim( )</strong></code>"
            },
            {
                "name": "How do you make first letter of the string in an uppercase?",
                "description": "<img src='./assets/js/first-letter-capital.png'>"
            },
            {
                "name": "How to convert string to title case with javascript?",
                "description": "<img src='./assets/js/first-letter-capital1.png'>"
            },
            {
                "name": "How do you check whether a string contains a substring?",
                "description": "<p>There are 3 possible ways to check whether a string contains a substring or not,</p><ul><li>Using includes(): String.includes() method to test a string contains a substring<br><img src='./assets/js/substring.png'></li><li>Using indexOf(): String.indexOf() which returns the index of a substring. If the index value is not equal to -1 then it means the substring exist in the main string.<br><img src='./assets/js/substring1.png'></li><li>Using RegEx: The advanced solution is using Regular expression's test method(RegExp.test), which allows for testing for against regular expressions<br><img src='./assets/js/substring2.png'></li></ul>"
            },
            {
                "name": "Search for a string in a string with JavaScript (search() / includes())",
                "description": "<p>To search for a string in a string, use the search() method. The method searches a string for a specified value. The returned value is the position of the match. However, -1 is returned if the match isn’t found.<br><br>Where as the <code>includes()</code> method returns true if a string contains a specified string, otherwise false</p>"
            },
            {
                "name": "Difference between substr() vs substring() vs slice() in JavaScript?",
                "description": "<p>The substr() and substring() methods are simpler, yet they have some differences. The 2nd argument of the substring() method is the index to halt the search, whereas the 2nd&nbsp;parameter of substr() is the maximum length.<br><br><strong>substr() method</strong> - The substr() method returns the characters in a string beginning at the specified location. It goes through the number of characters which is specified by the user.<br><br>The parameters of substr(start, len):</p><ul><li>start&nbsp;− Location start extracting characters.</li><li>length&nbsp;− The count of characters to extract.</li></ul><strong><code>let str = \"Hello world!\"; <br> str.substr(1, 4) <br> // Console Returns \"ello\"</code></strong><p><strong>substring() method</strong> - The substring() method returns subset of a string.<br><br>The parameters of substring(i1, i2):</p><ul><li>i1&nbsp;– Index from where you want the substring.</li><li>i2&nbsp;− Index till when you want the substring.</li></ul><strong><code>let str = \"Hello world!\"; <br> str.substring(1, 4) <br> // Console Returns \"ell\"</code></strong><p></p>"
            },
            {
                "name": "Array Reference",
                "description": "<ul> <li><strong>map( )</strong> - This method creates a new array with the results of calling a provided function on every element in this array. <br><img src='./assets/js/arraymap.png'><br><br></li><li><strong>filter( )</strong> - This method creates a new array with only elements that passes the condition inside the provided function.<br><img src='./assets/js/arrayfilter.png'><br><br></li><li><strong>sort( )</strong> - This method is used to arrange/sort array's elements either in ascending or descending order.<br><img src='./assets/js/arraysort.png'><br><br></li><li><strong>forEach( )</strong> - This method helps to loop over array by executing a provided callback function for each element in an array.<br><img src='./assets/js/arrayforeach.png'><br><br></li><li><strong>concat( )</strong> - This method is used to merge two or more arrays and returns a new array, without changing the existing arrays.<br><img src='./assets/js/arrayconcat.png'><br><br></li><li><strong>every( )</strong> - This method checks every element in the array that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arrayevery.png'><br><br></li><li><strong>some( )</strong> - This method checks if at least one element in the array that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arraysome.png'><br><br></li><li><strong>includes( )</strong> - This method checks if an array includes the element that passes the condition, returning true or false as appropriate.<br><img src='./assets/js/arrayincludes.png'><br><br></li><li><strong>join( )</strong> - This method returns a new string by concatenating all of the array's elements separated by the specified separator.<br><img src='./assets/js/arrayjoin.png'><br><br></li><li><strong>reduce( )</strong> - <p>Reduce the values of an array to a single value (going left-to-right) and for right-to-left use reduceRight().<br>The reduce() method executes a provided function for each value of the array (from left-to-right)<br>The return value of the function is stored in an accumulator (result/total)<br><img src='./assets/js/reduce.png'><br><br></li><li><strong>find( )</strong> - This method returns the value of the first element in an array that pass the test in a testing function.<br><img src='./assets/js/arrayfind.png'><br><br></li><li><strong>findIndex( )</strong> - This method returns the index of the first element in an array that pass the test in a testing function.<br><img src='./assets/js/arrayfindindex.png'><br><br></li><li><strong>indexOf( )</strong> - This method returns the index of the first occurrence of the specified element in the array, or -1 if it is not found.<br><img src='./assets/js/arrayindexof.png'><br><br></li><li><strong>fill( )</strong> - This method fills the elements in an array with a static value and returns the modified array.<br><img src='./assets/js/arrayfill.png'><br><br></li><li><strong>slice( )</strong> - This method returns a new array with specified start to end elements.<br><img src='./assets/js/arrayslice.png'><br><br></li><li><strong>reverse( )</strong> - This method reverses an array in place. Element at last index will be first and element at 0 index will be last.<br><img src='./assets/js/arrayreverse.png'><br><br></li><li><strong>push( )</strong> - This method adds one or more elements to the end of array and returns the new length of the array.<br><img src='./assets/js/arraypush.png'><br><br></li><li><strong>pop( )</strong> - Remove an item from the end of an array and returns the item(string) which was removed from that array<br><img src='./assets/js/pop.png'><br><br></li><li><strong>shift( )</strong> - This method removes an item from the start of an array and returns the item which was removed from that array<br><img src='./assets/js/arrayshift.png'><br><br></li><li><strong>unshift( )</strong> - This method adds one or more elements to the beginning of an array and returns the new length of the array.<br><img src='./assets/js/arrayunshift.png'><br><br></li></ul>"
            },
            {
                "name": "Difference between some() vs every() in javascript",
                "description": "<p>The <code>some()</code> method checks if any of the elements in an array pass a test (provided as a function)., where as the <code>every()</code> method returns true if all elements in an array passes the test (provided as a function).<br><br><code>some()</code> executes the function once for each element in the array: which means, during the execution If it finds an array element where the function is returning a <em>true</em> value against the test condition, then some() method returns true (and does not check the remaining values), Otherwise it returns false<br><br>The <code>every()</code> method executes the function once for each element present in the array: which means, during the execution If it finds an array element where the function is returning a <em>false</em> value against the test condition, then every() method returns false (and does not check the remaining values), Otherwise it returns true<br><br><strong>Both</strong> does not execute the function for empty array elements.<br><br><strong>Both</strong> does not change the original array.</p>"
            },
            {
                "name": "How to check if an object is an array or not? (object is array)",
                "description": "<p><img src='./assets/js/arrayorobject.png'></p>"
            },
            {
                "name": "List different ways of empty array in Javascript?",
                "description": "<p>In Javascript,&nbsp;there are many ways to empty an array in Javascript, below we have listed 4 major<br><br><img src='./assets/js/emptyarray.png'></p>"
            },
            {
                "name": "How do you add an element at the begining of an array? How do you add one at the end?",
                "description": "<p><img src='./assets/jsCode/addelement.png'></p>"
            },
            {
                "name": "Remove element from an array in JavaScript (splice)",
                "description": "<p>To remove a single element from an array in JavaScript, the splice() method is used. With that you can also replace, and/or add elements in an array.<br><br>We are using the splice() method to remove a single element by setting the location from where it start, and the number of elements to be removed. Here, we have set 1, therefore only a single element will get removed:</p><strong>myArr.splice(3, 1);</strong>"
            },
            {
                "name": "Methods to Search Through Arrays (include, find, filter)",
                "description": "<p>The <code>.includes()</code> method returns a boolean value and is perfect for telling you whether an element exists in an array or not. It gives a simple true or false answer.<br><strong>Syntax</strong>: <code>arr.includes(valueToFind, [fromIndex]); //fromIndex is optional</code><br><strong>Example</strong>: <code>const alligator = ['thick scales', 80, '4 foot tail', 'rounded snout'];<br>alligator.includes('thick scales'); // returns true</code><br><br>The <code>.find()</code> method is used to find and return the first occurence of an element in an array, under a defined testing function. and if the condition is not met, it returns <code>undefined</code><br><strong>Syntax</strong>: <code>array.find(testingFunction);</code><br><code>const trees = [<br> { name: 'birch', count: 4 },<br> { name: 'oak', count: 2 }<br> { name: 'maple', count: 5 },<br> { name: 'oak', count: 8 }<br> ];<br><br> const result = trees.find(tree => tree.name === 'oak');<br> // { name: 'oak', count, 2 }</code><br><br>The <code>.filter()</code> method is like the find() method, in that it requires a function passed and a condition for what will be returned. The main difference is, filter() always returns an array, even if there is only one matching element. But it will return all the matching elements, whereas find() only returns the first matching. The important thing with filter is that it returns all the elements matching your criteria.<br><strong>Syntax</strong>:<code>var newArray = array.filter(function(item) {<br> return condition;<br> });</code><br><code>var heroes = [ <br> {name: 'Batman', franchise: 'DC'}, <br> {name: 'Ironman', franchise: 'Marvel'}, <br> {name: 'Thor', franchise: 'Marvel'}, <br> {name: 'Superman', franchise: 'DC'} <br> ]; <br> <br> var marvelHeroes = heroes.filter(function(hero) { <br> return hero.franchise == 'Marvel'; <br> }); <br> <br> // [ {name: 'Ironman', franchise: 'Marvel'}, {name: 'Thor', franchise: 'Marvel'} ]</code></p>"
            },
            {
                "name": "Find the intersection of two arrays",
                "description": "<p> The logic here is to create a hashmap with the elements of the firstArray as the keys. <br>After that, you can use the hashmap's O(1) look up time to check if the element exists in the hash <br>If it does exist, add that element to the new array.<br><br>Since we only want to push unique elements in our case... we can implement a counter to keep track of what we already added<br><br><img src='./assets/js/intersection.png'></p>"
            },
            {
                "name": "What are the different types of pop-up boxes in JavaScript?",
                "description": "<p><strong>Alert Box</strong> - The alert box is for an alert or message to the user. User needs to click “OK”. The alert() method is used to add a message in the alert:<br><br><strong>Prompt Box</strong> - To input a value from the user and display it, use the prompt box. Users need to click “OK” to return the entered input, else click “Cancel” to return null.<br><br><strong>Confirm Box</strong> - The confirm box is used in JavaScript to take user's consent or accept something. User need to click “OK” to return true, else click “Cancel” to return false.</p>"
            },
            {
                "name": "Role of JSON.stringify() in JavaScript",
                "description": "<p>When data is sent to a web server, it has to be in the form of string. The <code>JSON.stringify()</code> method is used in JavaScript to convert an object to string.</p>"
            },
            {
                "name": "Anonymous functions vs JavaScript closures",
                "description": "<p><strong>JavaScript Closures</strong> - Closures are basically, the inner function having access to the variables in the outer function scope, even after the outer function has returned. To use a closure, simply define a function inside another function and expose it, I mean return it.<br><br><strong>Anonymous functions</strong> - An anonymous function is a function without a name! Anonymous functions are commonly assigned to a variable name or used as a callback function.</p>"
            },
            {
                "name": "What does “javascript:void(0)” mean?",
                "description": "<p>The javascript:void(0) evaluates an expression even if its addition to a web page brings unwanted output.<br><br>Use the void(0) to get the undefined primitive value. Here, we are preventing the page from loading on clicking the hyperlink:</p>"
            },
            {
                "name": "How to unset a JavaScript variable?",
                "description": "<p>The “undefined” is used to unset a variable in JavaScript.<br><br>Declare and initialize a variable:</p><strong>var a = 50;</strong><p>Now reassign the variable with undefined since we wish to unset it:</p><strong>a = undefined; </strong><p>The output displays undefined:</p>"
            },
            {
                "name": "Is JavaScript synchronous or asynchronous and what is event loop?",
                "description": "<p>JavaScript is a synchronous, blocking, single-threaded language. That just means that only one operation can be in progress at a time.<br><br>Many people think JavaScript is asynchronous because we can do async tasks like setTimeout, callbacks, promises in it. But the asynchronous behaviour of JavaScript(setTimeout, callbacks, promises) is not a part of JavaScript itself and built on top of JavaScript language in browser and accessed through browser APIs.<br><br>The browser have a Call Stack, Browser API and Message Queue and the order of their processing is called <strong>event loop</strong>.<br><br><img src='./assets/js/eventloop.png'><br><br>The output will be A C B , even after the setTimeout() was set to display “b” after 0 ms. This happens because of the internal working of the browser.<br><br>The main() is pushed into Call Stack, which then console logs A. Then it is popped out and the setTimeout is pushed into Call Stack. Now the setTimeout() uses Browser API, so it is pushed there and the console log C is pushed into Call Stack.</p><ul><li>Even with the delay of 0ms the exec() for setTimeout have to go to the Message Queue.</li><li>After all the statements of main() is run and the Call Stack is empty, then only the exec() from Message Queue can be pushed to the Call Stack.</li></ul><p>This is how event loop works and the asynchronous, non-blocking part of JavaScript comes from.</p>"
            },
            {
                "name": "Format numbers as currency string in JavaScript",
                "description": "<p>The number formatter would allow you to format numbers as the currency you want it to work.</p><ul> <li>USD - <br><img src='./assets/js/formatus.png'></li><li>EUR - <br><img src='./assets/js/formateur.png'></li></ul>"
            },
            {
                "name": "Difference between parseInt(string) and Number(string) in JavaScript?",
                "description": "<p>The <strong>parseInt()</strong> method parses up to the first non-digit and returns the parsed value, whereas <strong>Number()</strong> converts the string into a number, which can also be a float.<br><br><strong>console.log(parseInt(\"20demo\"));<br>//Output: 20 </strong><br><br>Using the <strong>Number(string)</strong> method, the expression returns NaN:<br><strong>console.log(Number(\"20demo\"));<br>//Output: NaN</strong><br><br>Let us now workaround for a float value with both Number(string) and parseInt(string)<br><strong>console.log(Number(\"12.99demo\"));<br>console.log(\"parseInt(\"12.99demo\"));<br>//Output: NaN / 12</strong></p>"
            },
            {
                "name": "How to detect a mobile device with JavaScript?",
                "description": "<p>To detect a mobile device, let's say Android device, use the navigator.userAgent.match. Here, we have set it in a function:<br><br><strong> Android: function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return navigator.userAgent.match(/Android/i);<br>&nbsp; &nbsp; &nbsp; &nbsp; },<br><br>&nbsp; &nbsp;iOS: function() {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return navigator.userAgent.match(/iPhone|iPad/i);<br>&nbsp; &nbsp; &nbsp; &nbsp; },</strong></p>"
            },
            {
                "name": "What is the value of typeof undefined == typeof NULL?",
                "description": "<p>The expression will be evaluated to true, since NULL will be treated as any other undefined variable.<br>Note: JavaScript is case-sensitive and here we are using NULL instead of null.</p>"
            },
            {
                "name": "How do you make synchronous / asynchronous XML HTTP request?",
                "description": "<p>Browsers provide an XMLHttpRequest object which can be used to make asynchronous HTTP requests from JavaScript by passing 3rd parameter as true for asynchronous and false for synchronous.<br><br><img src='./assets/js/xmlhttprequest.png'><br><br><img src='./assets/js/xmlhttprequest1.png'></p>"
            },
            {
                "name": "How would you create a private variable in JavaScript?",
                "description": "<p>To create a private variable in JavaScript that cannot be changed you need to create it as a local variable within a function. Even if the function is executed the variable cannot be accessed outside of the function. For example:<br><img src='./assets/js/private-variable.png'><br><br>To access the variable, a helper function would need to be created that returns the private variable.<br><img src='./assets/js/private-variable1.png'></p>"
            },
            {
                "name": "Difference between: `function Person(){}`, `var person = Person()`, and `var person = new Person()`?",
                "description": "<p><code>function Person(){}</code> is just a normal function declaration.<br><br><code>var person = Person()</code> invokes the <code>Person</code> as a function, and not as a constructor. Invoking as such is a common mistake if it the function is intended to be used as a constructor. Typically, the constructor does not return anything, hence invoking the constructor like a normal function will return <code>undefined</code> and that gets assigned to the variable intended as the instance.<br><br><code>var person = new Person()</code> creates an instance of the Person object using the <code>new</code> operator, which inherits from <code>Person.prototype</code><br><br><img src='./assets/js/share.png'><br><br><strong>What will happen if I write <code>Person.name = “John”;</code></strong><br>Answer : It will throw error Cannot assign to read-only property ‘name’.</p><br><p><strong>What will happen if I write </strong><br><code>var p1 = new Person(“YYY”,21); <br>p1.name =”ZZZ”; <br>console.log(p1.name);<br>Answer: ZZZ</code></p>"
            },
            {
                "name": "Difference between a `.forEach` vs `.map()` loop",
                "description": "<p>The main difference between <code>.forEach</code> and <code>.map()</code>, is that <code>.map()</code> utilizes <code>return statement</code> and actually returns a new Array of the same size.<br><br><strong><code>forEach</code></strong></p><ul><li>Iterates through the elements in an array.</li><li>Executes a callback for each element.</li><li>Does not return a value.</li></ul><p><img src='./assets/js/foreach.png'><br><br><strong><code>map</code></strong></p><ul><li>Iterates through the elements in an array.</li><li>'Maps' each element to a new element by calling the function on each element, creating a new array as a result.</li></ul><p><img src='./assets/js/map.png'></p>"
            },
            {
                "name": "Boolean Reference",
                "description": "<p><table class='table table-striped'><tbody><tr><th style='width:20%'>Method</th><th>Description</th></tr><tr><td>toString()</td><td>Converts a boolean value to a string, and returns the result</td></tr><tr><td>valueOf()</td><td>Returns the primitive value of a boolean</td></tr></tbody></table></p>"
            },
            {
                "name": "Class Reference",
                "description": "<p>A class is a type of function, but instead of using the keyword function to initiate it, we use the keyword class, and the properties are assigned inside a constructor() method:<br><br>Class Methods<br><table class='table table-striped'><tbody><tr><th style='width:20%'>Method</th><th>Description</th></tr><tr><td>constructor()</td><td>A special method for creating and initializing objects created within a class</td></tr></tbody></table><br><br>Class Keywords<br><table class='table table-striped'><tbody><tr><th style='width:20%'>Keyword</th><th>Description</th></tr><tr><td>extends</td><td>It is used to create a child class of another class (parent)</td></tr><tr><td>static</td><td>The <code>static</code> keyword defines static methods for classes. Static methods are called directly on the class - without creating an instance/object of the class</td></tr><tr><td>super</td><td>The <code>super</code> keyword refers to the parent class. It is used to call the constructor of the parent class and to access the parent's properties and methods.</td></tr></tbody></table><br><br>Example of extends and Super keyword<br><img src='./assets/js/super-class.png'></p>"
            },
            {
                "name": "JSON Reference",
                "description": "<p><table class='table table-striped'><tbody><tr><th style='width:30%'>Method</th><th>Description</th></tr><tr><td>parse()</td><td>When receiving the data from a web server, the data is always in a string format. But you can convert this string value to javascript object using parse() method. <code>var userString = '{'name':'John','age':31}';<br> var userJSON = JSON.parse(userString);<br> console.log(userJSON);<br>// {name: 'John', age: 31}</code></td></tr><tr><td>stringify()</td><td>When sending data to a web server, the data has to be in a string format. You can achieve this by converting JSON object into a string using stringify() method.<code>var userJSON = {'name': 'John', age: 31}<br> var userString = JSON.stringify(user);<br> console.log(userString); <br>// '{'name':'John','age':31}'</code></td></tr></tbody></table></p>"
            },
            {
                "name": "Difference between splice() and slice()",
                "description": "<p>The <strong>slice()</strong> method returns a new array with a copy of sliced item from the original array. Here, the first optional argument marks the beginning index and the second optional argument marks the ending index. Where as index marked with negative number starts from the end of the array. <br>###Slice method won't mutate the original array but it returns the subset as new array.<br><br>The <strong>splice()</strong> method changes the content of the array in place and can be used to add or remove items from the array. It returns the removed items in the array. The first argument marks the array position for insertion or deletion, whereas the second optional argument marks the number of elements to be deleted. <br>###Splice method modifies the original array and returns the deleted array.</p>"
            },
            {
                "name": "Difference between filter() and map()",
                "description": "<p><strong>filter()</strong>: creates a new array with elements that fall under a given condition from an existing array.<br><br><strong>map()</strong>: 'Maps' each element to a new element by calling the function on each element, creating a new array as a result.</p>"
            },
            {
                "name": "Difference between findIndex() and indexof()",
                "description": "<p><strong>findIndex()</strong>: This function returns index of the first element of the given array which satisfies the testing function.<br><br><strong>indexof()</strong>: This function is used to find the index of the first occurrence of the element provided for search as the argument to the function. If the item is present more than once, the indexOf method returns the position of the first occurence.</p>"
            },
            {
                "name": "Difference between find() and filter()",
                "description": "<p><strong>find()</strong>: The find() method returns the first value that matches from the collection. Once it matches the value in findings, it will not check the remaining values in the array collection.<br><br><strong>filter()</strong>: creates a new array with elements that fall under a given condition from an existing array.</p>"
            },
            {
                "name": "Difference between console.dir and console.log?",
                "description": "<ul><li><code>console.log(input)</code>: The browser logs in a nicely formatted manner</li><li><code>console.dir(input)</code>:  The browser logs just the object with all its properties</li></ul>"
            },
            {
                "name": "Difference between window and document?",
                "description": "<table><thead><tr><th>Window</th><th>Document</th></tr></thead><tbody><tr><td>It is the root level element in any web page</td><td>It is the direct child of the window object. This is also known as Document Object Model(DOM)</td></tr><tr><td>By default window object is available implicitly in the page</td><td>You can access it via window.document or document.</td></tr><tr><td>It has methods like alert(), confirm() and properties like document, location</td><td>It provides methods like getElementById, getElementByTagName, createElement etc</td></tr></tbody></table>"
            },
            {
                "name": "What is a Regular Expression or RegExp?",
                "description": "<p>A regular expression is a sequence of characters that forms a search pattern. You can use this search pattern for searching data in a text. These can be used to perform all types of text search and text replace operations.</p><img src='./assets/js/searchStringPattern.png'>"
            },
            {
                "name": "What are modifiers in RegExp?",
                "description": "<p>Modifiers can be used to perform case-insensitive and global searches. Let's list down some of the modifiers,</p><table><thead><tr><th>Modifier</th><th>Description</th></tr></thead><tbody><tr><td>i</td><td>Perform case-insensitive matching</td></tr><tr><td>g</td><td>Perform a global match rather than stops at first match</td></tr><tr><td>m</td><td>Perform multiline matching</td></tr></tbody></table><br><img src='./assets/js/globalmodifier.png'>"
            },
            {
                "name": "What are RegExp patterns?",
                "description": "<p>Regular Expressions provided group of patterns in order to match characters. Basically they are categorized into 3 types,</p><ul><li><strong>Brackets:</strong> These are used to find a range of characters. For example, below are some use cases,<ul><li>[abc]: Used to find any of the characters between the brackets(a,b,c)</li><li>[0-9]: Used to find any of the digits between the brackets</li><li>(a|b): Used to find any of the alternatives separated with |</li></ul></li><li><strong>Metacharacters:</strong> These are characters with a special meaning For example, below are some use cases,<ul><li>d: Used to find a digit</li><li>s: Used to find a whitespace character</li><li>b: Used to find a match at the beginning or ending of a word</li></ul></li><li><strong>Quantifiers:</strong> These are useful to define quantities For example, below are some use cases,<ul><li>n+: Used to find matches for any string that contains at least one n</li><li>n*: Used to find matches for any string that contains zero or more occurrences of n</li><li>n?: Used to find matches for any string that contains zero or one occurrences of n</li></ul></li></ul>"
            },
            {
                "name": "Object Equality - How would you compare two objects in JavaScript?",
                "description": "<p>To check that, you can get the keys for both the objects. If the number of properties doesn't match, these two objects are not equal. Secondly, you will check each property whether they have the same value. If all the properties have same value, they are equal.<br><br><img src='./assets/js/objectcompare.png'></p>"
            },
            {
                "name": "What Is Garbage Collection in JavaScript?",
                "description": "<p>This type of <em>automatic memory management</em> monitors memory allocation to reclaim and free up allocated memory blocks that are no longer needed by the JavaScript program.</p>"
            },
            {
                "name": "List the 7 Error Types in JavaScript.",
                "description": "<ul><li><strong>EvalError:</strong> Error regarding the global function <em>eval()</em></li><li><strong>InternalError:</strong> Internal error in the JS engine (stack overflow, etc)</li><li><strong>RangeError: </strong>Numeric variable or parameter is outside of valid range</li><li><strong>ReferenceError:</strong> Invalid variable reference</li><li><strong>SyntaxError:</strong> Syntax error while parsing code in <em>eval()</em></li><li><strong>TypeError:</strong> Parameter or variable not of a valid type</li><li><strong>URIError:</strong> Invalid parameters passed to <em>decodeURI()</em> or <em>encodeURI()</em></li></ul>"
            },
            {
                "name": "What’s the Difference Between the Javascript Engine & Javascript Runtime?",
                "description": "<p>The JavaScript engine converts JavaScript code into machine code that can be executed by the computer, while the JavaScript runtime is the environment in which the code is executed, such as a web browser or <strong>Node.js</strong></p>"
            },
            {
                "name": "How Can You Optimize the Performance of a Javascript Application?",
                "description": "<ul><li>Minimize use of global variables</li><li>Prioritize access to local variables</li><li>Use caching &amp; memoization</li><li>Compressing code and further uglification of code</li><li>Use object &amp; array literals instead of constructors</li><li>Avoid unnecessary function calls</li><li>Defer the load of JavaScript that is not necessary</li><li>Use web workers when you need to execute code that needs a lot of execution time</li><li>Remove unused JavaScript such as unused library which is not in use</li></ul>"
            },
            {
                "name": "How Can You Measure the Performance of a JavaScript Function?",
                "description": "<p>You can use <em>performance.now()</em> to return high-resolution timestamps in milliseconds and thus calculate the time it takes for a function to execute, as shown below.<br><img src='./assets/js/performance.png'></p>"
            },
            {
                "name": "How does a javascript engine work behind the scenes ?",
                "description": "<p>Every browser provides a JavaScript engine that runs the JavaScript code.<br><br><strong>Execution Context</strong> - When the JavaScript engine scans a script file, it makes an environment called the Execution Context that handles the entire transformation and execution of the code. <br>During the context runtime, the parser parses the source code and allocates memory for the variables and functions. The source code is generated and gets executed. <br>There are two types of execution contexts: global and function. The global execution context is created when a JavaScript script first starts to run, and it represents the global scope in JavaScript. A function execution context is created whenever a function is called, representing the function's local scope.<br><br><strong>Phases of the JavaScript Execution Context</strong> -<br>#1. In <strong>Creation Phase</strong>, the JavaScript engine creates the execution context and sets up the script's environment. The <strong>Creation Phase</strong> includes creating the global and function execution contexts, creating the scope chain, and allocating memories for the variables and functions.<br>#2. During the <strong>Execution Phase</strong>, the JavaScript engine executes the code line by line. This includes evaluating and executing statements.</p><br><br><p><strong>Call Stack</strong> - To keep the track of all the contexts, including global and functional, the JavaScript engine uses a <strong>call stack</strong>. A call stack is also known as an 'Execution Context Stack', 'Runtime Stack', or 'Machine Stack'. <br>When the engine first starts executing the script, it creates a global context and pushes it on the stack. Whenever a function is invoked, similarly, the JS engine creates a function stack context for the function and pushes it to the top of the call stack and starts executing it. <br>When execution of the current function is complete, then the JavaScript engine will automatically remove the context from the call stack and it goes back to its parent.<br><br><img src='./assets/js/callstack.png'><br><br>In this example, the JS engine creates a global execution context that enters the creation phase.<br><br>First it allocates memory for <code>funcA</code>, <code>funcB</code>, the <code>getResult</code> function, and the <code>res</code> variable. Then it invokes <code>getResult()</code>, which will be pushed on the call stack.<br><br>Then <code>getResult()</code> will call <code>funcB()</code>. At this point, <code>funcB</code>'s context will be stored on the top of the stack. Then it will start executing and call another function <code>funcA()</code>. Similarly, <code>funcA</code>'s context will be pushed. <br><br>Once execution of each function is done, it will be removed from the call stack.</p>"
            },
            {
                "name": "Difference between TypeScript and JavaScript",
                "description": "<table><tbody><tr><td><strong>TypeScript</strong></td><td><strong>JavaScript</strong></td></tr><tr><td>Superset of JavaScript developed to overcome code complexity for large projects.</td><td>A scripting language that helps create dynamic web page content.</td></tr><tr><td>Errors can be found and corrected during compile time.</td><td>Errors can be found only during run-time as it is an interpreted language.</td></tr><tr><td>Strongly typed, supports both static and dynamic typing.</td><td>Weakly typed, no option for static typing.</td></tr><tr><td>Converted into JavaScript code to be understandable for browsers.</td><td>Can be directly used in browsers.</td></tr><tr><td>Since it is a superset, all the JavaScript libraries, and other JavaScript code works without any changes.</td><td>JS libraries work by default.</td></tr><tr><td>There is support for ES3, ES4, ES5 and ES6.</td><td>No support for compiling additional ES3, ES4, ES5 or ES6 features.</td></tr><tr><td>Supports modules, generics and interfaces to define data.</td><td>No support for modules, generics or interface.</td></tr><tr><td>Functions can have optional parameters.</td><td>Functions cannot have optional parameters.</td></tr><tr><td>Numbers and strings are considered as interfaces.</td><td>Number and string are objects.</td></tr><tr><td>Powerful and intuitive language for large projects.</td><td>Neat and clean, most suitable for simple web applications.</td></tr><tr><td>Community support is still growing.</td><td>Huge community support with lots of documentation and support for solving issues.</td></tr><tr><td>Prototyping is possible</td><td>No support for prototyping.</td></tr><tr><td>Takes time to learn and code, scripting knowledge is a must.</td><td>Can be learned on the go, no prior scripting experience is needed.</td></tr><tr><td>Proper build setup (npm package) is required for static type definitions</td><td>No build setup is required.</td></tr></tbody></table>"
            },
            {
                "name": "What are the differences between ES6 class and ES5 function constructors?",
                "description": "<p>ES6 class constructors work quite the same as class constructors in other object-oriented languages. They are used to create new objects.<br><br>ES5 function constructors are also used to create objects. The above example can be modified as following through the use of function constructors.</p><table><thead><tr><th><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ES6 class constructors</strong></th><th><strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ES5 function constructors</strong></th></tr></thead><tbody><tr><td>As discussed above ES6 class constructors creates objects by adding function to their prototypes (Blueprint).</td><td>ES5 function constructors also create objects along with inheritance property.&nbsp;</td></tr><tr><td>It ensures that<i> this</i> keyword used by the developer is referring to the object being created by the developer.&nbsp;</td><td>Any function can be used as a function constructor and it primarily focuses on the creation of reusable object creation code.</td></tr><tr><td>Its syntax is similar to object creation in other object-oriented programming languages.</td><td>Its syntax is unique and is not generally found in other object-oriented programming languages.</td></tr><tr><td>This can be said to be a syntax base for constructor functions and instantiate objects using a new operator.</td><td>This also uses a new operator for object creation but focuses on how the objects are being instantiated.</td></tr></tbody></table>"
            },
            {
                "name": "enums in JavaScript and typescript",
                "description": "<p>Enums in Javascript - <br><img src='./assets/js/enumjs.png'><br><br>Enums in Typescript - <br><img src='./assets/js/enumts.png'></p>"
            },
            
            
            {
                "name": "How do you clone an object?",
                "description": "<p><strong><code>var obj = {a: 1 ,b: 2}<br>var objclone = Object.assign({},obj);</code></strong><br><br>Now the value of <code>objclone</code> is <code>{a: 1 ,b: 2}</code> but points to a different object than <code>obj</code>.<br><br>Note the potential pitfall, though: <code>Object.assign()</code> will just do a shallow copy, <em>not</em> a deep copy.  This means that nested objects aren’t copied.  They still refer to the same nested objects as the original:<br><img src='./assets/js/objclone.png'></p>"
            },
            
            {
                "name": "What does the term Transpiling stand for?",
                "description": "<p>There's no way to polyfill new syntax that has been added to the language. So the better option is to use a tool that converts your newer code into older code equivalents. This process is commonly called&nbsp;<strong>transpiling</strong>, a term for&nbsp;<em>transforming + compiling</em>.<br><br>Typically you insert the&nbsp;<em>transpiler</em>&nbsp;into your build process, similar to your code linter or your minifier. There are quite a few great transpilers for you to choose from:</p><ul><li><p><strong>Babel</strong>: Transpiles ES6+ into ES5</p></li><li><p><strong>Traceur</strong>: Transpiles ES6, ES7, and beyond into ES5</p></li></ul>"
            },
            {
                "name": "Difference between Relative path and absolute path",
                "description": "<b>A relative path describes the location of a file relative to the current (working) directory*.</b>"
            },
            {
                "name": "Difference between Function, Method and Constructor calls in JavaScript",
                "description": "<p>In JavaScript, a <strong>function</strong> is a piece of reusable code that has the potential to take input values, perhaps do something with them, and potentially return a value.<br><br>Now, if the same function is called with the new keyword preceding it, it is known as <strong>constructor</strong> since it creates and returns a new object. (The collection of all objects that were generated using the same function constructor is then known as a class)<br><br>Likewise suppose a JavaScript Object contains as property in the form of function definition then it becomes a <strong>method</strong></p>"
            },
            {
                "name": "What are Service Workers and when can you use them?",
                "description": "<p>It’s a technology that allows your web application to use cached resources first, and provide default experience offline, before getting more data from the network later. This principle is commonly known as Offline First.<br><br>Service Workers actively use promises. A Service Worker has to be installed,activated and then it can react on fetch, push and sync events.<br><br>As of 2017, Service Workers are not supported in IE and Safari.</p>"
            }
        ]
    },
    {
        "folder": "JavaScript Coding",
        "title": "JavaScript Coding",
        "url": "/folder/JavaScript Coding",
        "icon": "logo-javascript",
        "question": [
            {
                "name": "Output - every() true/false?",
                "description": "<br><img src='./assets/jsCode/every.png'>"
            },
            {
                "name": "Output - var result NaN",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/resultnan.png'><br><br><strong>Answer: </strong> The result is <strong>NaN</strong> because the var result  variable is immediately initialized, by setting it to undefined, Inside the loop since the result in uninitialized so the value of the variable result remains undefined. as we know, undefined isn’t converted into any number, so using it in maths calculations returns NaN. i.e., <strong>undefined + 5 = NaN</strong></p>"
            },
            {
                "name": "Output - eval method",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/eval.png'><br><br><strong>Answer: </strong> The result is <strong>B) 105</strong> because The eval function we see here can be used to calculate the Javascript in the form of string also as the as multiplication operator has greater priority than addition operator so it will first execute 10 x 10 is equal to 100 and then it at 5 to it so it becomes <strong>Number 105</strong></p>"
            },
            {
                "name": "Output - string and array when updated",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/printstringhello.png'><br><br><strong>Answer: </strong> The result is <strong>\"𝗛𝗲𝗹𝗹𝗼\" ['𝗛', '𝗮', '𝗹', '𝗹', '𝗼']</strong> because string is immutable. so this will log original str i.e., \"𝗛𝗲𝗹𝗹𝗼\", and array is mutable so this will log updated value ['𝗛', '𝗮', '𝗹', '𝗹', '𝗼']</p>"
            },
            {
                "name": "Output - union of arrays",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/arrayconcat.png'><br><br><strong>Answer: </strong> The result is <strong>[1, 2, 3, 4]</strong> because here the logic is in this way <br><strong>#1.</strong> First get the elements that are contained in first array using <strong>filter method</strong> and not contained in the second array using <strong>includes method</strong>, <br><strong>#2.</strong> concat the result with the element of the second array using <strong>concat method</strong></p>"
            },
            {
                "name": "Output - unique object using Map",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/arraymap.png'><br><br><strong>Answer: </strong> The result is <strong>[{ 𝗸𝗲𝘆: 𝟭 }, { 𝗸𝗲𝘆: 𝟮 }]</strong> because the element exists in map object then skip to the next element, if not, add it to the result array.</p>"
            },
            {
                "name": "Output - Sum using Currying",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/currying.png'><br><br><strong>Answer:</strong> The result is <strong>5 5</strong> because Currying is a function that takes one argument at a time and returns a new function expecting the next argument</p>"
            },
            {
                "name": "Output - Object Key using square bracket operator",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/objectkey.png'><br><br><strong>Answer:</strong> The result is <strong>Jayesh 24</strong> because value of the key can be any expression as long as it is wrapped in brackets []. The result of an expression enclosed in brackets becomes the property name. i.e., age</p>"
            },
            {
                "name": "Ouput - replace string expression",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/replace.png'><br><br><strong>Answer:</strong> The result is <strong>jx@gmail.com logged-in</strong> replace() method is used to replace a part of a given string with a new substring</p>"
            },
            {
                "name": "output - using default value and function expression",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/defaultpara.png'><br><br><strong>Answer:</strong> The result is <strong>3 6</strong> Default values allow the named parameters to get initialized with a default value or when no value is passed. Now using a value in first parameter will overwrite it and while using function add as default value expression the value becomes 3+3 = 6</p>"
            },
            {
                "name": "Output - array using reverse and then push new item",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/arrayrev.png'><br><br><strong>Answer:</strong> The result is <strong>[3,2,1,4] [3,2,1,4]</strong> <br> <strong>#1.</strong> The reverse() method reverses the array immediately; this means that the original elements of the array are swapped, and the original sequence is lost. <strong> #2.</strong> since reverse and push both method mutates the original array.so arr2.push will also modify the arr1. <br><strong>#3.</strong> after push operation this will log [3,2,1,4] because they’re both referencing the same array</p>"
            },
            {
                "name": "Output - using Object.is check for number, string and objects.",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/objectis.png'><br><br><strong>Answer:</strong> The result is <strong>false false</strong> <br> <strong>#1.</strong> TheObject.is() workons on strict comparison operator .i.e - === <strong> #2.</strong> return false since for strict equality number and string comparison will return false. <br><strong>#3.</strong> The specified objects look the same; however, they are two different objects as they refer to different memory addresses. This is why the Object.is() method marked these objects as unequal after comparing their references and return false.</p>"
            },
            {
                "name": "Output - find a character with maximum occurrence in a string",
                "description": "<br><img src='./assets/jsCode/maxstringoccurence.png'><br><br>"
            },
            {
                "name": "Output -  compare string using sort method",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/stringsort.png'><br><br><strong>Answer:</strong> The result is <strong>true</strong> <br> since both str1 and str2 will be 'ehllo' after sorting and join. so this will return true</p>"
            },
            {
                "name": "Output - trim",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/trim.png'><br><br><strong>Answer:</strong> The result is <strong>\"&nbsp;&nbsp;Jayesh&nbsp;&nbsp;\" \"Jayesh\"</strong> <br> string.trim() removes sequences of whitespaces and line terminators from both the start and the end of the string. It doesn't change the original string but returns a new string without leading and trailing white spaces.</p>"
            },
            {
                "name": "Output  - Array with single nad multiple arguments",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/emptyarray.png'><br><br><strong>Answer:</strong> The result is <strong>[empty x 3][1,2,3]</strong> <br> <strong>#1.</strong>  arr1 = new Array(3); will create array arr1 with a specified number of empty slots (e.g. Array(3) creates the array [empty x 3]). so this will log [𝗲𝗺𝗽𝘁𝘆 × 𝟯] <br><strong>#2.</strong>new Array(1, 2, 3); //an array with three elements</p>"
            },
            {
                "name": "Output - What is the result of X, Y, Z / A, B C object?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/xyzObjectProblem.png'><br><br><strong>Solution - </strong><br><img src='./assets/jsCode/xyzObject.png'><br><br>Adding objects as properties of another object should be done carefully.<br><br>Writing x[y]={name:”Vivek”}, is same as writing x[‘object Object’]={name:”Vivek”},<br><br>While setting a property of an object, javascript coerces the parameter into a string.<br><br>Therefore, since y is an object, it will be converted to ‘object Object’.<br><br>Both x[y] and x[z] are referencing the same property.</p>"
            },
            {
                "name": "Output - Console results of string and numbers?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/stringNumberConsole.png'><br><br><strong>Solution - </strong><br><img src='./assets/jsCode/stringNumberConsoleResult.png'></p><br><br><p><strong>Problem</strong><br><img src='./assets/jsCode/stringNumberConsole1.png'><br><br><strong>Solution - </strong><br><img src='./assets/jsCode/stringNumberConsoleResult1.png'></p>"
            },
            {
                "name": "Output - Equality Coercion",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/equalityProblem.png'><br><br><strong>Solution - </strong>Output in the following order due to equality coercion:<br><img src='./assets/jsCode/equalitySolution.png'></p>"
            },
            {
                "name": "Output - Hoisting a variable and random function",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/hoistingProblem.png'><br><br><strong>Solution - </strong>Output is <strong>NaN</strong><p>random() function has functional scope, since x is declared and hoisted in the functional scope.<br><br>Rewriting the random function will give a better idea about the output:<br><img src='./assets/jsCode/hoistingSolution.png'></p>"
            },
            {
                "name": "Output - What is the issue with the below code and how it can be fixed? (console sort)",
                "description": "<p><strong>Problem</strong><br><strong>const array=[1,2,15,4,30,7,45];<br>console.log(array.sort());</strong><br><br>The sort() method is used to sort the elements of an array. But the output of the above is not what expected out of sort() function.<br><br>This is because the default sort is according to tring Unicode points. The fix to it is by adding an anonymous function and tell to sort according to ascending or descending order. <br><br><img src='./assets/jsCode/sort.png'><br><br><strong>Sorting Programatically</strong><br><img src='./assets/jsCode/sortprogram.png'></p>"
            },
            {
                "name": "Output - Recursion example Flatten array",
                "description": "<p><strong>Algorithm steps:</strong></p><ul><li>First, we iterate through the given array.</li><li>Then check each element:<ul><li>if it is not an array then push the elements in an updated array.</li><li>if it is an array then again call the same function <code>flatten()</code> i.e. recursion. Then we will combine our updated array and return values of <code>flatten()</code> using the spread operator in ES6. This will keep flatting the updated array.</li></ul></li></ul><p><strong>Solution 1</strong><br><img src='./assets/jsCode/flattenforloop.png'><br><br><strong>Solution 2</strong><br><img src='./assets/jsCode/flatten.png'></p>"
            },
            {
                "name": "Output - Recursion example 'display countdown numbers'",
                "description": "<p><strong>Algorithm steps:</strong></p><ul><li>First, we iterate through the given number.</li><li>Then we decrease the number by 1 and store that value in a variable</li><li>Then we evaluate the new stored value against the condition greater than 0, if it is then we again trigger the countdown function.</li></ul><p><img src='./assets/jsCode/recursioncountdown.png'></p>"
            },
            {
                "name": "Output - Find Factorial",
                "description": "<p>The factorial function says to multiply all the whole numbers from the chosen number down to one. In more mathematical terms, the factorial of a number <strong>(n!) is equal to n(n-1)</strong>.<br><br><img src='./assets/jsCode/factorial.png'></p>"
            },
            {
                "name": "Output - Find out prime factors of the number",
                "description": "<p><strong>Solution 1</strong><br><img src='./assets/jsCode/factors1.png'><br><br><strong>Solution 2</strong><br><img src='./assets/jsCode/factors.png'></p>"
            },
            {
                "name": "Output - Perfect number using Javascript",
                "description": "<p>In number theory, a perfect number is a positive integer that is equal to the sum of its proper positive divisors, that is, the sum of its positive divisors excluding the number itself<br><i>Example</i> : The first perfect number is 6, because 1, 2, and 3 are its proper positive divisors, and 1 + 2 + 3 = 6. Equivalently, the number 6 is equal to half the sum of all its positive divisors: ( 1 + 2 + 3 + 6 ) / 2 = 6. The next perfect number is 28 = 1 + 2 + 4 + 7 + 14.<br><br><img src='./assets/jsCode/perfectnumber.png'></p>"
            },
            {
                "name": "Output - digits from a string with numbers",
                "description": "<p><strong>var strNum = \"only123!\"; </strong><br><br>To fetch the digits from the above string, the following RegExp is used: <img src='./assets/jsCode/regexp.png'><br><br><img src='./assets/jsCode/findnumber.png'></p>"
            },
            {
                "name": "Output - non-digit characters from a string",
                "description": "<p><strong>var strNum = \"DEMO989#@#@\";</strong><br><br>The following RegExp is used to get a non-digits:&nbsp;<img src='./assets/jsCode/regexp1.png'><br><br><img src='./assets/jsCode/findalphabets.png'></p>"
            },
            {
                "name": "Output - How to shuffle an array in JavaScript?",
                "description": " <ul> <li><img src='./assets/jsCode/shuffle.png'></li><li><strong>[3,5,1,95,8,23].sort( ()=>Math.random()-0.5)</strong></li><li><img src='./assets/jsCode/shuffle1.png'></li></ul>"
            },
            {
                "name": "Output - What should be the value of “i” so that we get the mentioned result?",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/printi.png'><br><br><strong>Answer</strong><br><br>Everything is ok, but the last one produce NaN(Not a Number) because “<em>0 divide by 0 will produce infinity”</em><br><br>So, we need a number which is like zero but gives 1 if we divide it by itself. Fortunately there is such a number in JavaScript. The number is the minimum value that is allowed in JavaScript and is represented by <strong>Number.MIN_VALUE</strong><br><br><img src='./assets/jsCode/printians.png'></p>"
            },
            {
                "name": "Output - What are the different way to access “this” inside an inner function for below code?",
                "description": "<p><img src='./assets/jsCode/problem1.png'><br><br><strong>Solution 1</strong> - Use call method to use the outer “this” inside the innerFunc().<br><br><img src='./assets/jsCode/solution1.png'><br><br><strong>Solution 2</strong> - Use bind method to use the outer “this” inside the innerFunc().<br><br><img src='./assets/jsCode/solution2.png'><br><br><strong>Solution 3</strong> - Use a “that” variable in&nbsp;cleanRoom() for accessing “this” inside innerFunc(). Basically “that” is nothing but the outer “this”.<br><br><img src='./assets/jsCode/solution.png'><br><br><strong>Solution 4</strong> - Use arrow function in the innerFunc(). Arrow functions have special meaning for “this” and it is that, it takes the value of “this” from the enclosing scope and is very useful in this case.<br><br><img src='./assets/jsCode/solution3.png'></p>"
            },
            {
                "name": "Output - What is the output of the below code and why?(identity)",
                "description": "<p><img src='./assets/jsCode/problem2.png'><br><br><strong>Problem</strong>What is the issue with the code and how can it be fixed?<br><br>The output logged will be:</p><strong><code>undefined<br>Johnny Deep</code></strong><p>The first console.log prints <strong>undefined</strong> because heroIdentity()is been invoked in the global context (i.e., the window object) where the <strong>_name</strong> property doesn’t exists.<br><br>The other way to fix it is by binding, it to hero object by using bind.</p><strong><code>var heroIdentity = hero.getIdentity.bind(hero);</code></strong>"
            },
            {
                "name": "Output - What is the output of the below code and why? (method)",
                "description": "<p><img src='./assets/jsCode/method.png'><br><br>The output logged will be:</p><strong><code>10<br>2</code></strong><p>When inside the method, fn() is called the “this” of the function fn is at window level. So, “this.length” will produce <strong>10</strong>.<br>Now, when <code>arguments[0]()&nbsp;</code>is called, then <code>arguments[0]()&nbsp;</code> is equivalent to “fn” and function fn is called. But “this” now is the arguments array, which is of length 2 because it contains two arguments (fn, 1). So, “this.length” will produce <strong>2</strong>.</p>"
            },
            {
                "name": "Output - What is the output of the below code and why? (console proto)",
                "description": "<p><strong>Problem</strong></p><strong>console.log(('hello').__proto__.__proto__.__proto__);</strong></p><br><p><strong>Answer</strong> - The output logged will be: <code>null</code><br><br>The reason is for prototype chaining. The __proto__ of ‘hello’ is the global String.</p><strong>console.log(('hello').__proto__);</strong><p><img src='./assets/jsCode/proto1.png'><br><br>Then the __proto__ of it is the global Object.</p><strong>console.log(('hello').__proto__.__proto__);</strong><p><img src='./assets/jsCode/proto2.png'><br><br>Now, the Object is the final thing from which everything in JavaScript is created and it points to <strong>null</strong>.</p>"
            },
            {
                "name": "Output - Find the missing number in the array",
                "description": "<p><img src='./assets/jsCode/missingNumber.png'></p>"
            },
            {
                "name": "Output - Find the duplicate values in an string",
                "description": "<ul><li><strong>Using filter + indexOf</strong> <img src='./assets/jsCode/duplicateValue4.png'></li></ul>"
            },
            {
                "name": "Output - Find the duplicate values in an array",
                "description": "<ul> <li><strong>By simply Traversing the Array</strong> <br><img src='./assets/jsCode/duplicateValue.png'></li><li><strong>Using filter + indexOf</strong> <br><img src='./assets/jsCode/duplicateValue1.png'></li><li><strong>Using includes</strong> <br><img src='./assets/jsCode/duplicateValue2.png'></li><li><strong>Using ES6 \"Set\"</strong> <br><img src='./assets/jsCode/duplicateValue3.png'></li></ul>"
            },
            {
                "name": "Output - Remove duplicates from an array",
                "description": "<ul> <li><strong>Using empty array / helper array</strong> <br><img src='./assets/jsCode/duplicate.png'></li><li><strong>Using Object</strong> <br><img src='./assets/jsCode/duplicate1.png'></li><li><strong>Using filter + indexOf</strong> <br><img src='./assets/jsCode/duplicate2.png'></li><li><strong>Using ES6 \"Set\"</strong> <br><strong><code>var temp=[...new Set(arr)]</code></strong></li><li><strong>Using ES6 \"Set\" with from()</strong> <br><strong><code>var temp.from(new Set(arr))</code></strong><br><strong>Here, the <code>from()</code> method returns an Array object from any object which has a capability of defining length property or any iterable object.</strong></p></li></ul>"
            },
            {
                "name": "Output - Reverse each word in the sentence",
                "description": "<p><img src='./assets/jsCode/reverse2.png'><br><br><img src='./assets/jsCode/reverse.png'><br><br><img src='./assets/jsCode/reverse1.png'><br><br><strong>Reversing word greater than 5 letters</strong><br><img src='./assets/jsCode/reverse3.png'><br><br><img src='./assets/jsCode/reverseString.png'><br><br>Here, <strong>The <code>split()</code> method splits a string into an array of substrings, and returns the new array. If an empty string (\"\") is used as the separator, the string is split between each character, where as the <code>reverse()</code> method reverses the order of the elements in an array, and the <code>join()</code> method returns an array as a string.</strong></p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop",
                "description": "<p><code>// setTimeout inside a For loop<br><br>for(var i = 0;i &lt; 5; i++){<br>&nbsp;&nbsp;&nbsp;setTimeout(function(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log('count ', i);<br>&nbsp;&nbsp;&nbsp;}, 3000);<br>}</code><br><br>//Console<br><br><code>count  5<br>count  5<br>count  5<br>count  5<br>count  5</code><br><br>The <em>setTimeout</em> function callback isn’t triggered until the for loop execution has completed. When the for loop has finished executing the value of i is 5. Now when the <em>setTimeout</em> call begins to execute it uses the last set value of i which is 5. Hence 5 is printed in all the <em>setTimeout</em> callbacks.</p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using IIFE",
                "description": "<p>You can use IIFE to create a new scope for each setTimeout callback without polluting the global scope. Simply wrap up the setTimeout code inside a IIFE.</p><br><img src='./assets/jsCode/settimeoutforloop.png'>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using let Keyword",
                "description": "<p>The let keyword creates a separate scope for each iteration making it possible to print the consecutive variable value.</p><br><img src='./assets/jsCode/settimeoutforloop1.png'>"
            },
            {
                "name": "Output - indexOf",
                "description": "<p><img src='./assets/jsCode/problem3.png'><br><br><strong>Answer</strong>: The first answer is 1 because 2 is at position 1, second and third is -1 because the index does not use for object and arrays. If you want to find and element in array use map and then check the index. The last line answer is 4 because the string is consider as an array of char in javascript.</p>"
            },
            {
                "name": "Output - filter.call()",
                "description": "<p><img src='./assets/jsCode/problem4.png'><br><br>Answer: This will start reading after 5. The beauty of this question is how it is written. Sometimes look like a puzzle. It will return set of array <strong><em>[“W”, “o”, “r”, “l”, “d”]</em></strong></p>"
            },
            {
                "name": "Output - printMessage",
                "description": "<p><img src='./assets/jsCode/problem5.png'><br><br>Answer: Here, We are creating two objects printVal1 and printVal2. printVal1.printMessage() clearly logs In printVal1 …because message is initialize as “In printVal1 …”. In the next line assigning method printMessage to printVal2 Object. In printVal2 message is initialize as “In printVal2 …”. So code block will log: <strong>In printVal1 … and In printVal2 …</strong></p>"
            },
            {
                "name": "Output - return statement",
                "description": "<p><img src='./assets/jsCode/problem6.png'><br><br>Answer - when you see this example closely there is return and rest of the code is written after that. So JavaScript just return from second line of code. Code after line 2 will not be executed.</p>"
            },
            {
                "name": "Output - ===",
                "description": "<p><strong>Problem</strong><br><strong>console.log(0.1+0.2===0.3)</strong><br><br>Answer: when adding 0.1 and 0.2 in javascript it will not be 0.3. It will be more than a fraction value of 0.3.<br> Only this will work <strong>(0.1+0.2).toFixed(1)==0.3</strong></p><br><br><p><strong>Problem</strong><br><img src='./assets/jsCode/equalityProblem1.png'><br><br><strong>Answer</strong> The triple-equal operator <code>===</code> behaves like any traditional equality operator would: evaluates to true if the two expressions on either of its sides have the same type and the same value. The double-equal operator, however, tries to coerce the values before comparing them. It is therefore generally good practice to use the <code>===</code> rather than <code>==</code>.  The same holds true for <code>!==</code> vs <code>!=</code>.</p>"
            },
            {
                "name": "Output - Fibonacci series",
                "description": "<p>Fibonacci series is a series that generates subsequent series of numbers by the addition of the two previous numbers. ... The first two terms of the Fibonacci series are zero and one, respectively. And the next terms are the addition of the two previous terms.<br><br><img src='./assets/jsCode/fibonacci.png'></p>"
            },
            {
                "name": "Output - Swap number without temp",
                "description": "<p><img src='./assets/jsCode/swaping.png'></p>"
            },
            {
                "name": "Output - Sum of two / sumFinder",
                "description": "<p><strong>Problem</strong> - From a unsorted array, check whether there are any two numbers that will sum up to a given number?<br><br><strong>Answer</strong><br><img src='./assets/jsCode/sumoftwo.png'></p>"
            },
            {
                "name": "Output - Sum of two largest numbers in the array",
                "description": "<p><img src='./assets/jsCode/sumoftwo1.png'></p>"
            },
            {
                "name": "Output - delete operator with Emp Object prototype",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete1.png'><br><br><p><strong>Answer</strong> - Above code will output <strong>xyz</strong> as output. Here <strong>emp1</strong> object got company as prototype property. <strong>delete</strong> operator doesn't delete prototype property.<br><br><strong>emp1</strong> object doesn't have <strong>company</strong> as its own property. You can test it like:<br><br><img src='./assets/jsCode/delete2.png'><br><br>However, we can delete company property directly from <strong>Employee</strong> object using <strong>delete Employee.company</strong> or we can also delete from <strong>emp1</strong> object using <strong>__proto__</strong> property <strong> delete emp1.__proto__.company</strong>.</p>"
            },
            {
                "name": "How to merge two sorted Arrays into a Sorted Array?",
                "description": "<p><img src='./assets/jsCode/merge-two-sorted-array-algorithm.png'><br><br><img src='./assets/jsCode/merge-two-sorted-array-algorithm1.png'></p>"
            },
            {
                "name": "Output - let and var inside setTimeout",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/letvaroutput.png'></p><br><p><strong>Answer</strong> - Outputs 2 and 12. Since, even though let variables are not hoisted, due to the async nature of javascript, the complete function code runs before the setTimeout function. Therefore, it has access to both x and y.</p>"
            },
            {
                "name": "Output - In what order will the numbers 1-4 be logged to the console",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/order.png'></p><br><p><strong>Answer</strong> - 2<br>4<br>3<br>1 // After two seconds<br><br>Even though the second timeout function has a waiting time of zero seconds, the javascript engine always evaluates the setTimeout function using the Web API, and therefore, the complete function executes before the setTimeout function can execute.</p>"
            },
            {
                "name": "Output - hero / getPower / powerlevel",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/powerlevel.png'></p><br><p><strong>Answer</strong> - undefined<br>42<br><br>Reason - The first output is <strong>undefined </strong>since when the function is invoked, it is invoked referencing the global object:<br><br><code>window.getPower() = getPower();</code></p>"
            },
            {
                "name": "Write the code to find the vowels",
                "description": "<p><img src='./assets/jsCode/vowels.png'></p>"
            },
            {
                "name": "Output - setTimeout Inside For Loop Using const variable",
                "description": "<p><strong>Problem</strong> - <br><img src='./assets/jsCode/const.png'></p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/const1.png'></p>"
            },
            {
                "name": "Output - Given two strings, return true if they are anagrams of one another",
                "description": "<p><strong>Problem</strong> - For example: Mary is an anagram of Army</p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/anagram.png'></p>"
            },
            {
                "name": "Output - typeof F()",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/typeoff.png'></p><br><p><strong>Answer</strong> - The output would be 1undefined. The if condition statement evaluates using eval, so eval(function f(){}) returns function f(){} (which is true). Therefore, inside the if statement, executing typeof f returns undefined because the if statement code executes at run time, and the statement inside the if condition is evaluated during run time.</p>"
            },
            {
                "name": "Output - delete operator",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete3.png'></p><br><p><strong>Answer</strong> - The output would be 0. The delete operator is used to delete properties from an object. Here x is not an object but a local variable. delete operators don’t affect local variables.</p>"
            },
            {
                "name": "Output - delete operator with x object - foo bar",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/delete.png'></p><br><p><strong>Answer</strong> - The output would be undefined. The delete operator is used to delete the property of an object. Here, x is an object which has the property foo, and as it is a self-invoking function, we will delete the foo property from object x. After doing so, when we try to reference a deleted property foo, the result is undefined.</p>"
            },
            {
                "name": "Output - named function expression - foo bar typeof",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/namedexpression.png'></p><br><p><strong>Answer</strong> - The output would be Reference Error. A function definition can have only one reference variable as its function name.</p>"
            },
            {
                "name": "Write a function that would allow you to do this? addSix / createBase / closures",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/addsix.png'></p><br><p><strong>Answer</strong> - You can create a closure to keep the value passed to the function createBase even after the inner function is returned.<br><img src='./assets/jsCode/addsixfunc.png'></p>"
            },
            {
                "name": "FizzBuzz Challenge",
                "description": "<p><strong>Problem</strong>Create a for loop that iterates up to <code>100</code> while outputting <strong>\"fizz\"</strong> at multiples of <code>3</code>, <strong>\"buzz\"</strong> at multiples of <code>5</code> and <strong>\"fizzbuzz\"</strong> at multiples of <code>3</code> and <code>5</code>.</p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/fizzbuzz.png'></p>"
            },
            {
                "name": "How would you use a closure to create a private counter?",
                "description": "<p>You can create a function within an outer function (a closure) that allows you to update a private variable but the variable wouldn't be accessible from outside the function without the use of a helper function.<br><img src='./assets/jsCode/closureconter.png'></p>"
            },
            {
                "name": "Output - Value of b in expression var a=b=5",
                "description": "<p>The code above will output 5 even though it seems as if the variable was declared within a function and can't be accessed outside of it. This is because <br><strong><code>var a = b = 5</code></strong><br> is interpreted the following way: <br><strong><code>var a = b;<br>b = 5;</code></strong><br><br>But <code>b</code> is not declared anywhere in the function with var so it is set equal to <strong>5</strong> in the <strong>global scope</strong>.</p><br><br><p><strong>Another Case Problem</strong><br><img src='./assets/jsCode/aandb.png'></p><br><p><strong>Answer</strong> - <br><strong>a defined? false <br>b defined? true</strong> - since the statement <code>var a = b = 3;</code> is shorthand for the statements <code>b = 3;</code> and <code>var a = b;</code>, <code>b</code> ends up being a global variable (since it is not preceded by the <code>var</code> keyword) and is therefore still in scope even outside of the enclosing function.</p>"
            },
            {
                "name": "Output - 3>2>1 - returns false while 3>2>0 return true",
                "description": "<p>Let's pick this apart. First, it evaluates <strong>+(3 &gt; 2)</strong>. Yes, three is greater than two. Therefore, you now have expression like this <strong> +(true) &gt; 1</strong><br><br><strong>true</strong> is coerced into a number. That number happens to be <strong>1</strong>. <strong>1 &gt; 1</strong> is obviously false. Therefore, the result is: <strong>false</strong></p><br><br><p>Whereas in other case expression 1 > 0, and hence the result is true</p>"
            },
            {
                "name": "Output - 1<2<3 returns true",
                "description": "<p>Let's pick this apart. First, it evaluates <strong>+(1 &lt; 2)</strong>. Yes, one is less than two. Therefore, you now have expression like this <strong> +(true) &lt; 3</strong><br><br><strong>true</strong> is coerced into a number. That number happens to be <strong>1</strong>. <strong>1 &lt; 3</strong> is obviously true. Therefore, the result is: <strong>true</strong></p>"
            },
            {
                "name": "Output - 1<3>2 and 1>3<2",
                "description": "Result - false / true"
            },
            {
                "name": "Output - console 'this foo bar self'",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/outputfoobar.png'></p><br><p><strong>Answer</strong> - <br><img src='./assets/jsCode/outputfoobar1.png'><br>In the outer function, both <code>this</code> and <code>self</code> refer to <code>myObject</code> and therefore both can properly reference and access <code>foo</code>.<br>In the inner function, though, <code>this</code> no longer refers to <code>myObject</code>.  As a result, <code>this.foo</code> is undefined in the inner function, whereas the reference to the local variable <code>self</code> remains in scope and is accessible there.</p>"
            },
            {
                "name": "Output - Palindrome",
                "description": "<p><strong>Answer</strong><br><img src='./assets/jsCode/palindrome.png'><br><br><strong>Example</strong><br><img src='./assets/jsCode/palindrome1.png'></p>"
            },
            {
                "name": "Output - object property",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/objref.png'></p><br><p><strong>Answer</strong> - When setting an object property, JavaScript will implicitly <strong>stringify</strong> the parameter value. In this case, since <code>b</code> and <code>c</code> are both objects, they will <em>both</em> be converted to <code>\"[object Object]\"</code>. As a result, <code>a[b]</code> and<code>a[c]</code> are both equivalent to <code>a[\"[object Object]\"]</code> and can be used interchangeably.  Therefore, setting or referencing <code>a[c]</code> is precisely the same as setting or referencing <code>a[b]</code>.</p>"
            },
            {
                "name": "Output - Testing knowledge on \"this\"",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/this.png'></p><br><p><strong>Answer</strong> - <strong><code><br>10<br>2</code></strong><br><br>When setting an object property, JavaScript will implicitly <strong>stringify</strong><br><br>In the first place, as <code>fn</code> is passed as a parameter to the function <code>method</code>, the scope (<code>this</code>) of the function <code>fn</code> is <code>window</code>.  <code>var length = 10;</code> is declared at the <code>window</code> level. It also can be accessed as <code>window.length</code> or <code>length</code> or <code>this.length</code> (when <code>this === window</code>.)<br><br>Now, we know that we can access any number of arguments in a JavaScript function using the <code>arguments[]</code> array.<br><br>Hence <code>arguments[0]()</code> is nothing but calling <code>fn()</code>. Inside <code>fn</code> now, the scope of this function becomes the <code>arguments</code> array, and logging the length of <code>arguments[]</code> will return <code>2</code>.</p>"
            },
            {
                "name": "Output - try catch",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/varhoisting.png'></p><br><p><strong>Answer</strong> - <strong><code><br>1<br>undefined<br>2</code></strong><br><br><code>var</code> statements are hoisted (without their value initialization) to the top of the global or function scope it belongs to, even when it’s inside a <code>with</code> or <code>catch</code> block. However, the error’s identifier is only visible inside the <code>catch</code> block. It is equivalent to:<br><img src='./assets/jsCode/varhoisting1.png'></p>"
            },
            {
                "name": "Output - not hoisted / girl / 21 / 20",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/hoisting.png'></p><br><p><strong>Answer</strong> - Neither 21, nor 20, the result is <code>undefined</code>. It’s because JavaScript initialization is not hoisted.<br><br>(Why doesn’t it show the global value of 21? The reason is that when the function is executed, it checks that there’s a local <code>x</code> variable present but doesn’t yet declare it, so it won’t look for global one.)</p>"
            },
            {
                "name": "Output - closures / outer / inner",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/closure.png'></p><br><p><strong>Answer</strong> - Output to the console will be “3”.<br><br>There are three closures in the example, each with it’s own <code>var b</code> declaration. When a variable is invoked closures will be checked in order from local to global until an instance is found. Since the <code>inner</code> closure has a <code>b</code> variable of its own, that is what will be output.</p>"
            },
            {
                "name": "Output - Check if a given string is a isomorphic",
                "description": "<p>For two strings to be isomorphic, all occurrences of a character in string A can be replaced with another character to get string B. There must be one-to-one mapping for every char of string A to every char of string B.<br><img src='./assets/jsCode/isomorphic.png'></p><ul><li><strong>Step 1</strong> - Check if the same lenght. If not, they cannot be isomorphic</li><li><strong>Step 2</strong> - If the letter does not exist, create a map and map it to the value of the second letter</li><li><strong>Step 3</strong> - Eles if letterA already exists in the map, but it does not map to letterB, that means that A is mapping to more than one letter.</li><li><strong>Step 4</strong> - If after iterating through and conditions are satisfied, return true. They are isomorphic</li></ul>"
            },
            {
                "name": "Output - this in global/window object",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/closure1.png'></p><br><p><strong>Answer</strong> - <br><strong><code>global/window object<br>object \"b\"<br>global/window object</code></strong><br><br><br>Since we are using the arrow function inside <strong>func2, this </strong>keyword refers to the global object.<br><br><strong>Code 3 </strong>- Outputs in the following order:</p>"
            },
            {
                "name": "Output - this in IIFE",
                "description": "<p><strong>Problem</strong><br><img src='./assets/jsCode/this1.png'></p><br><p><strong>Answer</strong> - <br><strong><code>\"Vivek\"<br>blank_value/undefined<br>\"Vivek\"</code></strong> - Only in the IIFE inside the function <strong>f</strong>, <strong>this </strong>keyword refers to the global/window object.</p>"
            },
            {
                "name": "Write the code for dynamically inserting new components / append nodes to the list.",
                "description": "<p><strong>Answer</strong><br><img src='./assets/js/append.png'></p>"
            },
            {
                "name": "Output of the following code? bar boolean",
                "description": "<p><strong>Problem</strong><br><img src ='./assets/jsCode/bartrue.png'><br><br><strong>Answer<br>1<br>truexyz<br>2<br>1</strong></p>"
            },
            {
                "name": "True False Rapid Fire",
                "description": "<p><strong>Question: </strong>Is<code>'false'</code>is!1?<br><strong>Answer: </strong>No.Because,it's a string with length greater than 0. Only empty string is false.</p><p><strong>Question: </strong> Is <code>' '</code> is false?<br><strong>Answer: </strong> No. Because, it's not an empty string.There is a white space in it.</p><p><strong>Question: </strong>What about<code>{}</code>?<br><strong>Answer: </strong>!0.It's an object. An object without any property is an object can't be falsy.</p><p><strong>Question: </strong>Tell me about<code>[]</code>?<br><strong>Answer: </strong>This is also truthy.It's an array object (array is child of object) is truthy.</p><p><strong>Question: </strong>You talked bout <code>''</code> to be falsy. What about <code>new String('')</code>?<br><strong>Answer: </strong> Though you are passing empty string to the string constructor, it is creating an String object. More precisely a instance of String object. It becomes an object. Hence, it is not false. so, it is truthy.</p><p><strong>Question: </strong> Tell me about <code>new Boolean(false)</code><br><strong>Answer: </strong> truthy. As it creates an instance of the Boolean object which is an object. Object is truthy.</p><p><strong>Question: </strong> <code>Boolean(function(){})</code><br><strong>Answer: </strong> <code>true</code> if you pass a truthy value to Boolean, it will be true.</p><p><strong>Question: </strong> <code>Boolean(/foo/)</code><br><strong>Answer: </strong> <code>true</code></p><p><strong>Question: </strong> <code>true%1</code><br><strong>Answer: </strong> 0. When you are trying to find reminder of true, true becomes 1 and reminder of 1 while dividing by 1 is 0. you will get same result if you doe <code>false%1</code></p><p><strong>Question: </strong> <code>''%1</code><br><strong>Answer: </strong>0</p>"
            },
            {
                "name": "Rapid Fire",
                "description": "<p><strong>Question: </strong> What is <code>typeof []</code><br><strong>Answer: </strong> Object. Actually Array is derived from Object. If you want to check array use <code>Array.isArray(arr)</code></p><p><strong>Question: </strong> What is <code>typeof arguments</code><br><strong>Answer: </strong> Object. arguments are array like but not array. it has length, can access by index but can't push pop, etc.</p><p><strong>Question: </strong> What is <code>2+true</code><br><strong>Answer: </strong> 3. The plus operator between a number and a boolean or two boolean will convert boolean to number. Hence, true converts to 1 and you get result of 2+1</p><p><strong>Question: </strong> What is <code>'6'+9</code><br><strong>Answer: </strong> 69. If one of the operands of the plus (+) operator is string it will convert other number or boolean to string and perform a concatenation. For the same reason, <code>'2'+true</code> will return '2true'</p><p><strong>Question: </strong> What is the value of <code>4+3+2+'1'</code><br><strong>Answer: </strong> 91 . The addition starts from the left, 4+3 results 7 and 7+2 is 9. So far, the plus operator is performing addition as both the operands are number. After that 9 + '1' where one of the operands is string and plus operator will perform concatenation.</p><p><strong>Question: </strong> What is the value of <code>'1'+2+4</code><br><strong>Answer: </strong> '124'. For this one '1' + 2 will produce '12' and '12'+4 will generates '124'.</p><p><strong>Question: </strong> What is the value of <code>-'34'+10</code><br><strong>Answer: </strong> -24. minus(-) in front of a string is an unary operator that will convert the string to a number and will make it negative. Hence, -'34' becomes, -34 and then plus (+) will perform simple addition as both the operands are number.</p><p><strong>Question: </strong> What is the value of <code>+'dude'</code><br><strong>Answer: </strong> NaN. The plus (+) operator in front of a string is an unary operator that will try to convert the string to number. Here, JavaScript will fail to convert the 'dude' to a number and will produce NaN.</p><p><strong>Question: </strong> If you have <code>var y=1, x=y=typeof x;</code> What is the value of x?<br><strong>Answer: </strong> 'undefined'</p><p><strong>Question: </strong> for <code>var a=(2, 3, 5);</code> what is the value of a?<br><strong>Answer: </strong> 5. The comma operator evaluates each of its operands (from left to right) and returns the value of the last operand.</p><p><strong>Question: </strong> for <code>var a=(1, 5 - 1) * 2</code> what is the value of a?<br><strong>Answer: </strong> 8</p><p><strong>Question: </strong> What is the value of <code>!'bang'</code><br><strong>Answer: </strong> false. <code>!</code> is NOT. If you put <code>!</code> in front of truthy values, it will return false. Using !! (double bang) is a tricky way to check anything truthy or falsy by avoiding implicit type conversion of==comparison.</p><p><strong>Question: </strong> What is the value of <code>parseFloat('12.3.4')</code><br><strong>Answer: </strong> 12.3</p><p><strong>Question: </strong> What is the value of <code>Math.max([2,3,4,5]);</code><br><strong>Answer: </strong> NaN</p><p><strong>Question: </strong> <code>3 instanceof Number</code><br><strong>Answer: </strong> false</p><p><strong>Question: </strong><code>null==undefined</code><br><strong>Answer: </strong> true</p><p><strong>Question: </strong>What is the value of <code>!!function(){};</code><br><strong>Answer: </strong> true</p><p><strong>Question: </strong> What is the value of <code>typeof bar</code><br><strong>Answer: </strong> 'undefined'</p><p><strong>Question: </strong> What is the value of <code>typeof null</code><br><strong>Answer: </strong> 'object'</p><p><strong>Question: </strong> If <code> var a=2, b=3</code> what would be value of <code>a &amp;&amp; b</code><br><strong>Answer: </strong> 3</p><p><strong>Question: </strong> What would be consoled <code>var foo='outside'; function logIt(){console.log(foo); var foo='inside';}logIt();</code><br><strong>Answer: </strong> undefined</p><p><strong>Question: </strong> What is <code>-5%2</code><br><strong>Answer: </strong>-1. the result of remainder always get the symbol of first operand</p><p><strong>Question: </strong> Why <code>.1+.2 !=.3</code><br><strong>Answer: true - floating point errors in internally representing certain numbers. 0.1 + 0.2 does not nicely come out to 0.3</strong></p><p><strong>Question: <code>42..toString()</code></strong><br><strong>Anwser:</strong> <code>'42'</code></p><p><strong>Question: </strong> <code>4.2..toString</code><br><strong>Anwser:</strong> //SyntaxError: Unexpected token .</p><p><strong>Question: </strong><code>42 . toString()</code><br><strong>Anwser:</strong> <code>'42'</code></p><p><strong>Question: </strong> <code>typeof(NaN)</code><br><strong>Anwser:</strong>'number'</p><p><strong>Question: </strong> <code>2 in [1,2]</code><br><strong>Anwser:</strong> false. Because 'in' returns whether a particular property/index available in the Object. In this case object has index 0 and 1 but don't have 2. Hence you get false.</p>"
            }
        ]
    }
]